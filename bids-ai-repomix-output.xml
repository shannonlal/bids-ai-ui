This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-15T15:31:56.837Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
  dependabot.yml
  pull_request_template.md
.husky/
  pre-commit
cline_docs/
  features/
    authentication.md
    effort-diary.md
  activeContext.md
  productContext.md
  progress.md
  projectbrief.md
  systemPatterns.md
  techContext.md
prompts/
  REACT_VITEST_UNIT_TESTING.md
  USER_STORIES.md
public/
  vercel.svg
scripts/
  createTestUser.ts
src/
  components/
    french-idol/
      quiz/
        QuizContext.test.tsx
        QuizContext.tsx
        QuizQuestion.test.tsx
        QuizQuestion.tsx
        QuizResults.test.tsx
        QuizResults.tsx
        QuizStory.test.tsx
        QuizStory.tsx
        QuizView.test.tsx
        QuizView.tsx
      CreateStoryView.tsx
      FrenchIdolContext.test.tsx
      FrenchIdolContext.tsx
      FrenchIdolView.test.tsx
      FrenchIdolView.tsx
      StoryUpload.test.tsx
      StoryUpload.tsx
    grade-levels/
      GradeLevelsTable.tsx
    layout/
      Header.tsx
      Layout.tsx
      MenuDropdown.tsx
    profile/
      ProfileComponent.test.tsx
      ProfileComponent.tsx
    results/
      ResultsComponent.test.tsx
      ResultsComponent.tsx
      StoryQuizModal.tsx
    story/
      StoryInput.test.tsx
      StoryInput.tsx
      StoryList.test.tsx
      StoryList.tsx
  constants/
    prompts.ts
  hooks/
    useDetermineQuestions.test.ts
    useDetermineQuestions.ts
    usePdfParser.test.ts
    usePdfParser.ts
    useProfile.ts
    useValidResponse.test.ts
    useValidResponse.ts
  lib/
    __tests__/
      mongodb.test.ts
    mongodb.ts
    passport.ts
    session.ts
  models/
    Answer.ts
    GradeLevel.ts
    Story.ts
    User.ts
  pages/
    api/
      __mocks__/
        openai.ts
      __tests__/
        grade-levels/
          index.test.ts
        stories/
          getStoryAnswers.test.ts
          list.test.ts
        generateQuestions.test.ts
        generateStory.test.ts
        getByEmail.test.ts
        list.test.ts
        validateResponse.test.ts
      grade-levels/
        index.ts
      stories/
        getReadStories.ts
        getStoryAnswers.ts
        list.ts
        markRead.ts
      users/
        getByEmail.ts
        list.ts
        updateProfile.ts
      generateQuestions.ts
      generateStory.ts
      generateStoryPrompt.json
      validateResponse.ts
    french-idol/
      create.tsx
      index.tsx
    grade-levels/
      index.tsx
    _app.tsx
    icons.tsx
    index.tsx
    profile.tsx
    results.tsx
  services/
    __tests__/
      answerService.test.ts
      storyService.test.ts
      userService.test.ts
    answerService.ts
    storyService.ts
    userService.ts
  styles/
    global.css
    Home.module.css
  test/
    __mocks__/
      openai.ts
    mocks/
      openai.ts
      validateResponseSetup.ts
    setup.ts
    vitest.d.ts
  types/
    api/
      generateQuestions.ts
      generateStory.ts
      getStoryAnswers.ts
      listStories.ts
      validateResponse.ts
    answer.ts
    express.d.ts
    global.d.ts
    gradeLevel.ts
    story.ts
    user.ts
  ui-kit/
    __mocks__/
      gsap.ts
    icons/
      IconAdd.test.tsx
      IconAdd.tsx
      IconArrowDown.test.tsx
      IconArrowDown.tsx
      IconArrowDownUp.test.tsx
      IconArrowDownUp.tsx
      IconArrowLeft.test.tsx
      IconArrowLeft.tsx
      IconButton.test.tsx
      IconButton.tsx
      IconCheck.test.tsx
      IconCheck.tsx
      IconCopy.test.tsx
      IconCopy.tsx
      IconCreate.test.tsx
      IconCreate.tsx
      IconDelete.test.tsx
      IconDelete.tsx
      IconDownload.test.tsx
      IconDownload.tsx
      IconEdit.test.tsx
      IconEdit.tsx
      IconError.test.tsx
      IconError.tsx
      IconHelp.test.tsx
      IconHelp.tsx
      IconLike.test.tsx
      IconLike.tsx
      IconLogo.test.tsx
      IconLogo.tsx
      IconMenu.test.tsx
      IconMenu.tsx
      IconMinus.test.tsx
      IconMinus.tsx
      IconPlus.test.tsx
      IconPlus.tsx
      IconRedo.test.tsx
      IconRedo.tsx
      IconReload.test.tsx
      IconReload.tsx
      IconSave.test.tsx
      IconSave.tsx
      IconSearch.test.tsx
      IconSearch.tsx
      IconSend.test.tsx
      IconSend.tsx
      IconSettings.test.tsx
      IconSettings.tsx
      IconUser.test.tsx
      IconUser.tsx
      types.ts
    utils/
      cn.ts
    Button.test.tsx
    Button.tsx
    Dropdown.test.tsx
    Dropdown.tsx
    Radio.test.tsx
    Radio.tsx
    TextArea.test.tsx
    TextArea.tsx
    TextInput.test.tsx
    TextInput.tsx
.clinerules
.env-sample
.eslintignore
.eslintrc.json
.gitignore
.nvmrc
.prettierignore
.prettierrc
next-env.d.ts
next.config.js
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI
run-name: ${{ github.actor }} triggered CI workflow
on:
  pull_request:

jobs:
  main:
    name: Lint and Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 8.15.4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.19.0'
          cache: 'pnpm'
          cache-dependency-path: 'pnpm-lock.yaml'

      - name: Verify lockfile
        run: |
          if [ ! -f "pnpm-lock.yaml" ]; then
            echo "pnpm-lock.yaml not found!"
            exit 1
          fi
          echo "pnpm-lock.yaml found"
          cat pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install

      - name: Run ESLint
        run: pnpm lint

      - name: Run Vitest
        run: pnpm test

      - name: Run Format Check
        run: pnpm format

      - name: Build Project
        run: pnpm build
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'weekly'
    versioning-strategy: 'auto'
    labels:
      - 'dependencies'
      - 'npm'
    commit-message:
      prefix: 'chore'
      include: 'scope'
</file>

<file path=".github/pull_request_template.md">
## Description

<!-- Provide a brief description of the changes in this PR -->

## Type of Change

<!-- Mark the appropriate option with an 'x' -->

- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update
- [ ] Other (please describe):

## Checklist

<!-- Mark completed items with an 'x' -->

- [ ] I have read the [CONTRIBUTING](../CONTRIBUTING.md) document
- [ ] My code follows the code style of this project
- [ ] I have added/updated documentation as needed
- [ ] I have added tests that prove my fix/feature works
- [ ] All new and existing tests pass
- [ ] I have tested these changes locally

## Additional Notes

<!-- Add any additional notes, context, or screenshots about the PR here -->
</file>

<file path=".husky/pre-commit">
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "Running formatter and linter before commit"
pnpm exec lint-staged --relative

echo "Running unit tests before commit"
pnpm test
</file>

<file path="cline_docs/features/authentication.md">
# Authentication Feature Documentation

## Overview

The Authentication feature provides secure user authentication using Passport.js integrated with Next.js. This feature serves as the foundation for protecting routes and managing user sessions across the application.

## Authentication Implementation

### Passport.js Integration

#### 1. Dependencies

```bash
npm install passport passport-local @types/passport @types/passport-local next-auth bcryptjs @types/bcryptjs express-session @types/express-session connect-mongo
```

#### 2. Authentication Setup

```typescript
// src/lib/passport.ts
import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import bcrypt from 'bcryptjs';
import { User } from '../models/User';

passport.use(
  new LocalStrategy(
    {
      usernameField: 'email',
      passwordField: 'password',
    },
    async (
      email: string,
      password: string,
      done: (error: any, user?: any, options?: { message: string }) => void
    ) => {
      try {
        const user = await User.findOne({ email });

        if (!user) {
          return done(null, false, { message: 'Invalid email or password' });
        }

        const isMatch = await bcrypt.compare(password, user.password);

        if (!isMatch) {
          return done(null, false, { message: 'Invalid email or password' });
        }

        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }
  )
);

passport.serializeUser((user: IUserDocument, done: (err: any, id?: string) => void) => {
  done(null, user._id.toString()); // Convert ObjectId to string
});

passport.deserializeUser(
  async (id: string, done: (err: any, user?: IUserDocument | false) => void) => {
    try {
      const user = await User.findById(id);
      if (!user) {
        return done(new Error('User not found'));
      }
      done(null, user);
    } catch (error) {
      done(error);
    }
  }
);

export default passport;
```

#### 3. Session Configuration

```typescript
// src/lib/session.ts
import { NextApiRequest, NextApiResponse } from 'next';
import nextConnect from 'next-connect';
import session from 'express-session';
import MongoStore from 'connect-mongo';

declare module 'next' {
  interface NextApiRequest {
    session: any;
    user?: any;
  }
}

const sessionMiddleware = nextConnect()
  .use(
    session({
      secret: process.env.SESSION_SECRET || 'your-secret-key',
      resave: false,
      saveUninitialized: false,
      store: MongoStore.create({
        mongoUrl: process.env.MONGODB_URI,
        collection: 'sessions',
      }),
      cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      },
    })
  )
  .use(passport.initialize())
  .use(passport.session());

export default sessionMiddleware;
```

#### 4. API Routes

```typescript
// src/pages/api/auth/login.ts
import { NextApiRequest, NextApiResponse } from 'next';
import nextConnect from 'next-connect';
import passport from '../../../lib/passport';
import sessionMiddleware from '../../../lib/session';

const handler = nextConnect()
  .use(sessionMiddleware)
  .post(async (req: NextApiRequest, res: NextApiResponse) => {
    try {
      passport.authenticate('local', (err: any, user: any, info: any) => {
        if (err) {
          return res.status(500).json({ error: err.message });
        }
        if (!user) {
          return res.status(401).json({ error: info.message });
        }
        req.logIn(user, err => {
          if (err) {
            return res.status(500).json({ error: err.message });
          }
          return res.status(200).json({ user });
        });
      })(req, res);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

export default handler;
```

```typescript
// src/pages/api/auth/logout.ts
import { NextApiRequest, NextApiResponse } from 'next';
import nextConnect from 'next-connect';
import sessionMiddleware from '../../../lib/session';

const handler = nextConnect()
  .use(sessionMiddleware)
  .post((req: NextApiRequest, res: NextApiResponse) => {
    req.logout();
    res.status(200).json({ message: 'Logged out successfully' });
  });

export default handler;
```

#### 5. Authentication Middleware

```typescript
// src/middleware/authenticate.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { NextHandler } from 'next-connect';

export function isAuthenticated(req: NextApiRequest, res: NextApiResponse, next: NextHandler) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ error: 'Not authenticated' });
}
```

#### 6. Login Component

```typescript
// src/components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useRouter } from 'next/router';

export const LoginForm: React.FC = () => {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error);
      }

      router.push('/dashboard'); // Redirect after login
    } catch (error: any) {
      setError(error.message);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <div className="bg-red-100 text-red-700 p-3 rounded">
          {error}
        </div>
      )}
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>
      <button
        type="submit"
        className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
      >
        Sign In
      </button>
    </form>
  );
};
```

### Environment Variables

Add these variables to your `.env` file:

```
SESSION_SECRET=your-secure-session-secret
MONGODB_URI=your-mongodb-connection-string
```

### TypeScript Best Practices

#### Type Safety in Authentication

1. **Callback Types**

   - Use specific types for Passport.js callbacks instead of the generic `Function` type
   - Define return types for all async functions
   - Properly type error and success cases

2. **User Types**

   - Use `IUserDocument` interface extending MongoDB's `Document` type
   - Avoid using `any` type for user objects
   - Convert MongoDB ObjectId to string when serializing

3. **Error Handling**
   - Type error cases explicitly
   - Include proper error messages in return types
   - Handle null/undefined cases with proper type guards

Example of proper typing:

```typescript
// User document interface
interface IUserDocument extends Document {
  _id: mongoose.Types.ObjectId;
  email: string;
  password: string;
  // ... other fields
}

// Passport callback types
type DoneCallback = (error: any, user?: any, options?: { message: string }) => void;
type SerializeCallback = (err: any, id?: string) => void;
type DeserializeCallback = (err: any, user?: IUserDocument | false) => void;
```

### Implementation Steps

1. Install Dependencies

   ```bash
   npm install passport passport-local @types/passport @types/passport-local next-auth bcryptjs @types/bcryptjs express-session @types/express-session connect-mongo
   ```

2. Set up Environment Variables

   - Add SESSION_SECRET to .env
   - Ensure MONGODB_URI is configured

3. Implement Authentication Files

   - Create passport.ts configuration
   - Set up session middleware
   - Implement authentication middleware
   - Create login/logout API routes

4. Create Login Page

   - Implement LoginForm component
   - Create login page route
   - Add authentication state management

5. Protect API Routes

   - Add session middleware to API routes
   - Implement isAuthenticated checks
   - Update protected routes to use authentication

6. Testing
   - Test login flow
   - Verify session persistence
   - Test protected routes
   - Validate error handling

## Integration Points

### Protected Routes

Any route requiring authentication should:

1. Import the isAuthenticated middleware
2. Use sessionMiddleware
3. Apply the isAuthenticated check

Example:

```typescript
import { isAuthenticated } from '../middleware/authenticate';
import sessionMiddleware from '../lib/session';

const handler = nextConnect().use(sessionMiddleware).use(isAuthenticated);
```

### User Context

Components can access the authenticated user through the session:

```typescript
// Example of accessing user in an API route
handler.get(async (req: NextApiRequest, res: NextApiResponse) => {
  const userId = req.user._id;
  // Use userId to fetch user-specific data
});
```

## Future Considerations

1. Additional Authentication Strategies

   - OAuth providers (Google, GitHub, etc.)
   - JWT authentication
   - Two-factor authentication

2. Security Enhancements

   - Rate limiting
   - CSRF protection
   - Password reset functionality
   - Email verification

3. User Management
   - User roles and permissions
   - Account settings
   - Profile management

This documentation serves as a comprehensive guide for implementing and maintaining the authentication system within the Bids AI platform.
</file>

<file path="cline_docs/features/effort-diary.md">
# Effort Diary Feature Documentation

## Overview

The Effort Diary feature allows users to track and manage their daily efforts through a simple, intuitive interface. This feature integrates with the platform's authentication system (see [Authentication Feature](./authentication.md)) and follows the established architectural patterns of the Bids AI platform.

## Architecture

### Database Schema

```typescript
const EffortSchema = new Schema({
  description: {
    type: String,
    required: true,
  },
  userId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'User',
  },
  date: {
    type: Date,
    default: Date.now,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});
```

### API Design

#### Endpoints

1. POST /api/efforts

   - Creates a new effort entry
   - Protected by authentication
   - Request body: { description: string, date?: string }
   - Response: { status: number, effort: EffortType }

2. GET /api/efforts
   - Retrieves efforts for a specific date
   - Protected by authentication
   - Query params: date (optional, defaults to current date)
   - Response: { status: number, efforts: EffortType[] }

### Component Structure

```
src/
├── components/
│   └── effort-diary/
│       ├── EffortDiaryContext.tsx
│       ├── EffortDiaryView.tsx
│       ├── EffortInput.tsx
│       └── EffortList.tsx
├── pages/
│   └── effort-diary/
│       └── index.tsx
├── services/
│   └── effortService.ts
├── models/
│   └── Effort.ts
└── types/
    └── effort.ts
```

## Implementation Plan

### Phase 1: Database and Core Models (1-2 days)

- Implement Effort model
- Define TypeScript interfaces
- Set up database schema

### Phase 2: API Layer Implementation (2-3 days)

- Create effort service
- Implement API routes with authentication
- Add validation middleware

### Phase 3: UI Components (3-4 days)

- Create EffortDiaryContext
- Build core components
- Implement state management

### Phase 4: Pages and Integration (2-3 days)

- Create main pages
- Integrate with layout
- Add navigation
- Implement authentication checks

### Phase 5: Testing and Documentation (2-3 days)

- Write comprehensive tests
- Add API documentation
- Update project documentation

### Phase 6: Optimization and Polish (2-3 days)

- Performance optimization
- UX improvements
- Mobile responsiveness

Total Estimated Time: 12-18 days

## Technical Considerations

### State Management

- Uses React Context for feature-specific state
- Implements custom hooks for business logic
- Follows established patterns for API interactions

### Security

- Protected routes using authentication middleware
- User-specific data isolation
- Input validation and sanitization

### Testing Strategy

- Unit tests for services and utilities
- Component testing with React Testing Library
- API route testing
- Integration tests for key workflows

### Performance

- Optimized database queries
- Proper loading states
- Error boundaries
- Caching implementation

## Integration Points

### Authentication System

- Uses isAuthenticated middleware from authentication feature
- Integrates with user session management
- Leverages user context for identification

### UI/UX

- Consistent with existing design system
- Uses shared UI components
- Mobile-first responsive design
- Follows established navigation patterns

## Example Implementation

### EffortDiaryContext

```typescript
// src/components/effort-diary/EffortDiaryContext.tsx
import React, { createContext, useContext, useState, useCallback } from 'react';
import { EffortType } from '../../types/effort';

interface EffortDiaryContextType {
  efforts: EffortType[];
  loading: boolean;
  error: string | null;
  addEffort: (description: string) => Promise<void>;
  loadEfforts: (date?: string) => Promise<void>;
}

const EffortDiaryContext = createContext<EffortDiaryContextType | undefined>(undefined);

export const EffortDiaryProvider: React.FC = ({ children }) => {
  const [efforts, setEfforts] = useState<EffortType[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadEfforts = useCallback(async (date?: string) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/efforts${date ? `?date=${date}` : ''}`);
      const data = await response.json();
      if (!response.ok) throw new Error(data.error);
      setEfforts(data.efforts);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  const addEffort = useCallback(async (description: string) => {
    try {
      const response = await fetch('/api/efforts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ description }),
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.error);
      setEfforts(prev => [data.effort, ...prev]);
    } catch (err: any) {
      setError(err.message);
      throw err;
    }
  }, []);

  return (
    <EffortDiaryContext.Provider value={{
      efforts,
      loading,
      error,
      addEffort,
      loadEfforts
    }}>
      {children}
    </EffortDiaryContext.Provider>
  );
};

export const useEffortDiary = () => {
  const context = useContext(EffortDiaryContext);
  if (context === undefined) {
    throw new Error('useEffortDiary must be used within an EffortDiaryProvider');
  }
  return context;
};
```

### Protected API Route

```typescript
// src/pages/api/efforts/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import nextConnect from 'next-connect';
import middleware from '../../../middleware';
import { isAuthenticated } from '../../../middleware/authenticate';
import sessionMiddleware from '../../../lib/session';
import { effortService } from '../../../services/effortService';

const handler = nextConnect().use(middleware).use(sessionMiddleware).use(isAuthenticated);

handler.post(async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    const effort = await effortService.createEffort(req.user._id, req.body);
    res.status(201).json({ status: 201, effort });
  } catch (error) {
    res.status(500).json({ status: 500, error: 'Failed to create effort' });
  }
});

handler.get(async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    const date = req.query.date ? new Date(req.query.date as string) : new Date();
    const efforts = await effortService.getEffortsByDate(req.user._id, date);
    res.status(200).json({ status: 200, efforts });
  } catch (error) {
    res.status(500).json({ status: 500, error: 'Failed to fetch efforts' });
  }
});

export default handler;
```

## Future Considerations

### Feature Enhancements

1. Advanced filtering and search
2. Effort categories/tags
3. Analytics and reporting
4. Batch operations
5. Export functionality

### Scalability Considerations

1. Database indexing strategy
2. Query optimization
3. Caching implementation
4. Load balancing preparation

This documentation serves as a comprehensive guide for implementing and maintaining the Effort Diary feature within the Bids AI platform.
</file>

<file path="cline_docs/activeContext.md">
# Active Context

## Current State

### Active Features

1. French Idol System

   - Story creation and upload functionality
   - Quiz generation and assessment
   - Results tracking
   - French language learning focus

2. Grade Level Management

   - Grade levels table implementation
   - Content appropriateness filtering
   - Grade-specific features

3. User Profiles

   - Profile management
   - Results tracking
   - Progress monitoring

4. Story System

   - AI-powered story generation
   - PDF parsing capabilities
   - Story list management
   - Quiz generation

5. Effort Diary System (New)
   - Daily effort tracking
   - User-specific entries
   - Date-based organization
   - Progress monitoring

## Recent Implementations

### Components

1. French Idol Feature Set

   - CreateStoryView
   - StoryUpload
   - QuizContext and related components
   - Results visualization

2. Core UI Components

   - Comprehensive icon library
   - Form components (Button, TextInput, TextArea)
   - Layout components
   - Dropdown and Radio components

3. Testing Infrastructure
   - Vitest configuration
   - Mock implementations
   - Test utilities
   - Component test coverage

## Active Considerations

### Technical Decisions

1. State Management

   - Using React Context for feature-specific state
   - Custom hooks for shared logic
   - Service layer pattern for API interactions

2. Testing Strategy

   - Co-located test files
   - Mock implementations for external services
   - Component testing with React Testing Library

3. API Design
   - Type-safe request/response cycles
   - MongoDB integration
   - OpenAI service integration

### Current Focus Areas

1. User Experience

   - Story generation workflow
   - Quiz interaction flow
   - Results presentation
   - Grade level management
   - Effort tracking interface

2. Technical Quality

   - Test coverage
   - Code organization
   - Performance optimization
   - Error handling

3. Feature Development
   - French language learning capabilities
   - Assessment system
   - User progress tracking
   - Content management
   - Effort diary implementation

## Next Steps

### Immediate Priorities

1. Feature Enhancement

   - Refine story generation
   - Improve quiz assessment
   - Enhance user feedback
   - Optimize grade level features
   - Implement effort diary system

2. Technical Improvements

   - Expand test coverage
   - Optimize database queries
   - Enhance error handling
   - Improve type safety

3. User Experience
   - Streamline workflows
   - Enhance feedback mechanisms
   - Improve navigation
   - Optimize performance
   - Refine effort tracking UI

### Future Considerations

1. Scalability

   - Database optimization
   - API performance
   - Content delivery
   - User management

2. Feature Expansion
   - Additional language support
   - Enhanced assessment tools
   - Advanced analytics
   - Content management tools
   - Effort tracking analytics

This active context reflects the current state and direction of the Bids AI platform development.
</file>

<file path="cline_docs/productContext.md">
# Product Context

## Problem Space

Bids AI addresses several key challenges in the educational technology space:

1. The need for personalized, engaging language learning content
2. The difficulty of generating appropriate-level educational content at scale
3. The challenge of assessing language learning progress effectively
4. The complexity of managing different grade levels in educational content

## Solution Overview

The application provides an AI-powered platform that:

1. Generates customized stories and quizzes
2. Facilitates French language learning through interactive content
3. Tracks user progress and performance
4. Maintains grade-level appropriate content delivery

## User Experience Goals

### For Students

1. Engaging Learning Experience

   - Interactive story-based learning
   - Quiz-based assessment
   - Progress tracking
   - Grade-appropriate content

2. French Language Focus

   - French Idol feature for dedicated language learning
   - Story-based immersion
   - Interactive quiz assessment
   - Immediate feedback on responses

3. Personal Progress
   - Profile management
   - Results tracking
   - Achievement visibility
   - Grade level progression

### For Educators/Administrators

1. Content Management

   - Grade level management
   - Story creation and curation
   - Quiz generation and validation
   - User management

2. Assessment Tools
   - Results tracking
   - Progress monitoring
   - Response validation
   - Performance analytics

## Key User Flows

### Story Creation & Assessment

1. Story Generation

   - AI-powered story creation
   - Grade level appropriate content
   - PDF upload capability
   - Story management

2. Quiz Generation
   - Automated question creation
   - Response validation
   - Results tracking
   - Performance feedback

### French Language Learning

1. French Idol Feature

   - Story creation specific to French
   - Quiz-based assessment
   - Progress tracking
   - Interactive learning

2. User Management
   - Profile creation and management
   - Grade level assignment
   - Results tracking
   - Progress monitoring

## Success Metrics

1. User Engagement

   - Story completion rates
   - Quiz participation
   - Return user rates
   - Time spent on platform

2. Learning Outcomes

   - Quiz performance
   - Language progression
   - Grade level advancement
   - User satisfaction

3. Platform Performance
   - Story generation success rate
   - Quiz validation accuracy
   - System responsiveness
   - Error rates

This product context guides the development of features and user experience decisions in the Bids AI platform.
</file>

<file path="cline_docs/progress.md">
# Progress Report

## Implemented Features

### Core Functionality

1. Story System ✅

   - AI story generation
   - PDF parsing
   - Story management
   - Story list view

2. Quiz System ✅

   - Question generation
   - Response validation
   - Results tracking
   - Quiz UI components

3. French Idol Feature ✅

   - Story creation
   - Quiz assessment
   - Results tracking
   - Story upload

4. User Management ✅
   - Profile system
   - Grade level tracking
   - Results management
   - User authentication

### Technical Implementation

1. Infrastructure ✅

   - Next.js setup
   - MongoDB integration
   - TypeScript configuration
   - Testing framework

2. UI Components ✅

   - Base component library
   - Icon system
   - Form components
   - Layout components

3. Testing ✅
   - Unit test setup
   - Component tests
   - Mock implementations
   - Test utilities

## In Progress Features

### Active Development

1. Story Generation 🔄

   - Optimization of AI prompts
   - Enhanced content filtering
   - Improved grade level targeting
   - Performance optimization

2. Quiz System 🔄

   - Advanced question generation
   - Enhanced validation logic
   - Results analytics
   - Performance metrics

3. User Experience 🔄

   - Workflow optimization
   - Navigation improvements
   - Feedback mechanisms
   - Error handling

4. Effort Diary System 🔄
   - Database schema design
   - API layer implementation
   - UI components development
   - Integration with user system

## Pending Features

### Future Development

1. Enhanced Analytics 📋

   - User progress tracking
   - Learning metrics
   - Performance analysis
   - Usage statistics
   - Effort tracking analytics

2. Content Management 📋

   - Advanced filtering
   - Batch operations
   - Content moderation
   - Version control

3. System Optimization 📋
   - Database query optimization
   - API performance
   - Caching implementation
   - Load balancing

## Known Issues

### Technical Debt

1. Performance 🔧

   - Large component re-renders
   - Unoptimized database queries
   - API response times
   - Client-side processing

2. Testing Coverage 🔧

   - Integration test gaps
   - E2E test implementation
   - Performance testing
   - Load testing

3. Error Handling 🔧
   - Incomplete error states
   - Error recovery
   - User feedback
   - Logging system

### Bug Tracking

1. UI/UX Issues

   - Form validation improvements needed
   - Mobile responsiveness gaps
   - Navigation edge cases
   - Loading state handling

2. Functional Issues
   - Edge cases in story generation
   - Quiz validation corner cases
   - Profile update race conditions
   - Grade level assignment edge cases

## Next Steps

### Immediate Priorities

1. Critical Fixes

   - Performance optimization
   - Error handling improvement
   - Testing coverage expansion
   - Bug fixes

2. Feature Enhancement

   - Story generation refinement
   - Quiz system optimization
   - User experience improvement
   - Analytics implementation
   - Effort diary implementation

3. Technical Improvement
   - Code organization
   - Documentation updates
   - Performance optimization
   - Security enhancement

### Long-term Goals

1. System Scaling

   - Infrastructure optimization
   - Performance enhancement
   - Reliability improvement
   - Monitoring implementation

2. Feature Expansion
   - Additional language support
   - Advanced analytics
   - Content management tools
   - User collaboration features
   - Effort tracking enhancements

Legend:

- ✅ Complete
- 🔄 In Progress
- 📋 Planned
- 🔧 Needs Attention

This progress report reflects the current state of development and identifies areas requiring attention in the Bids AI platform.
</file>

<file path="cline_docs/projectbrief.md">
# Project Brief: Bids AI

## Project Overview

Bids AI is a Next.js application designed to facilitate interactive learning through AI-generated stories and quizzes. The platform appears to focus on language learning, particularly French, with features for story creation, quiz generation, and progress tracking.

## Core Objectives

1. Enable AI-powered story generation and quiz creation
2. Support French language learning through interactive content
3. Provide user profile management and progress tracking
4. Maintain grade-level appropriate content
5. Offer comprehensive assessment and results tracking

## Key Features

1. Story Generation & Management

   - AI-powered story creation
   - PDF parsing capabilities
   - Story list management
   - Story input interface

2. Quiz System

   - Automated question generation
   - Response validation
   - Quiz results tracking
   - Interactive quiz interface

3. French Idol Feature

   - Story creation specific to French learning
   - Quiz-based assessment
   - Progress tracking
   - Story upload functionality

4. User Management

   - Profile management
   - Grade level tracking
   - Results tracking
   - User authentication

5. Grade Level System
   - Grade level management
   - Content appropriateness filtering
   - Grade-level specific features

## Technical Requirements

1. Modern web technologies

   - Next.js framework
   - TypeScript for type safety
   - MongoDB for data persistence
   - TailwindCSS for styling

2. Testing & Quality

   - Comprehensive unit testing with Vitest
   - ESLint for code quality
   - Prettier for code formatting

3. Performance & Scalability
   - Server-side rendering capabilities
   - API route optimization
   - Efficient database queries

## Success Criteria

1. Reliable story generation and quiz creation
2. Accurate French language learning assessment
3. Intuitive user experience across all features
4. High test coverage and code quality
5. Responsive and performant application

This brief serves as the foundation for all development work and technical decisions in the Bids AI project.
</file>

<file path="cline_docs/systemPatterns.md">
# System Patterns

## Architecture Overview

### Frontend Architecture

1. Next.js Framework

   - Pages-based routing
   - API routes for backend functionality
   - Server-side rendering capabilities
   - Static site generation where applicable

2. Component Structure
   ```
   src/
   ├── components/         # Feature-specific components
   ├── ui-kit/            # Reusable UI components
   ├── pages/             # Next.js pages
   ├── hooks/             # Custom React hooks
   ├── services/          # API service layers
   ├── models/            # Data models
   ├── types/             # TypeScript types
   └── lib/              # Utility functions
   ```

### Design Patterns

1. Component Patterns

   - Feature-based organization (french-idol, grade-levels, profile, results)
   - Context providers for state management (FrenchIdolContext, QuizContext)
   - Container/Presenter pattern
   - Composition over inheritance

2. Testing Patterns

   - Unit tests with Vitest
   - Component testing with React Testing Library
   - Mock implementations for external services
   - Test file co-location with implementation

3. State Management
   - React Context for feature-specific state
   - Custom hooks for shared logic (useDetermineQuestions, usePdfParser)
   - Service layer for API interactions (storyService, userService)
   - MongoDB models for data persistence

## Key Technical Patterns

### Story Generation Flow

```mermaid
graph TD
    A[User Input] --> B[Story Service]
    B --> C[generateStory API]
    C --> D[AI Generation]
    D --> E[Story Model]
    E --> F[MongoDB]
    F --> G[UI Update]
```

### Quiz System

```mermaid
graph TD
    A[Story Content] --> B[generateQuestions API]
    B --> C[Quiz Context]
    C --> D[QuizQuestion Component]
    D --> E[User Responses]
    E --> F[validateResponse API]
    F --> G[Results Storage]
```

### French Idol Feature

```mermaid
graph TD
    A[StoryUpload] --> B[CreateStoryView]
    B --> C[FrenchIdolContext]
    C --> D[QuizContext]
    D --> E[QuizResults]
    E --> F[Progress Update]
```

## Component Relationships

### UI Components

1. Base Components (ui-kit/)

   - Button
   - TextInput
   - TextArea
   - Dropdown
   - Radio
   - Extensive icon library

2. Feature Components
   - Story Components (StoryInput, StoryList)
   - Quiz Components (QuizQuestion, QuizResults)
   - Profile Components (ProfileComponent)
   - Results Components (ResultsComponent, StoryQuizModal)
   - Grade Level Components (GradeLevelsTable)

### Service Layer

1. Data Services

   - storyService (story creation, retrieval)
   - userService (user management)
   - answerService (quiz responses)

2. API Integration
   - MongoDB connection (lib/mongodb.ts)
   - API routes for core functionality
   - Type-safe API responses

## Code Organization

### Directory Structure Patterns

1. Feature-based organization

   - Components grouped by feature
   - Co-located test files
   - Shared hooks and utilities
   - Type definitions per feature

2. Testing Structure
   - **tests** directories
   - **mocks** for external dependencies
   - Shared test utilities
   - Test setup configuration

### Data Flow Patterns

1. API Request Flow

   - Type-safe request/response cycle
   - Service layer abstraction
   - Error handling middleware
   - Response validation

2. State Management Flow
   - Context providers for feature state
   - Custom hooks for business logic
   - Service layer for data operations
   - Model layer for data structure

This system patterns documentation serves as a guide for maintaining consistency and understanding the technical architecture of the Bids AI platform.
</file>

<file path="cline_docs/techContext.md">
# Technical Context

## Technology Stack

### Core Technologies

1. Frontend Framework

   - Next.js (React framework)
   - TypeScript for type safety
   - TailwindCSS for styling

2. Backend Services

   - Next.js API Routes
   - MongoDB for data persistence
   - OpenAI integration for AI features

3. Testing Framework
   - Vitest for unit and component testing
   - React Testing Library for component tests
   - Custom test utilities and mocks

## Development Environment

### Node Version

- .nvmrc specifies the Node.js version requirement
- Project uses modern Node.js features

### Package Management

- PNPM as package manager
- pnpm-lock.yaml for dependency versioning
- Structured workspace configuration

### Code Quality Tools

1. ESLint Configuration

   ```
   .eslintrc.json
   .eslintignore
   ```

   - TypeScript-specific rules
   - React hooks rules
   - Import sorting
   - Accessibility rules

2. Prettier Configuration
   ```
   .prettierrc
   .prettierignore
   ```
   - Consistent code formatting
   - Integration with ESLint

### TypeScript Configuration

- tsconfig.json with strict mode
- Next.js specific configuration
- Path aliases
- Type checking settings

## Project Dependencies

### Production Dependencies

1. Core Framework

   - next
   - react
   - react-dom
   - typescript

2. Styling

   - tailwindcss
   - postcss
   - autoprefixer

3. Database

   - mongodb
   - mongoose (types)

4. Utilities
   - gsap for animations
   - axios for HTTP requests
   - date-fns for date handling

### Development Dependencies

1. Testing

   - vitest
   - @testing-library/react
   - @testing-library/user-event
   - jsdom

2. Code Quality

   - eslint
   - prettier
   - typescript-eslint
   - various eslint plugins

3. Types
   - @types/react
   - @types/node
   - other type definitions

## API Integration

### OpenAI Integration

- Story generation
- Question generation
- Response validation
- Configuration through environment variables

### MongoDB Integration

1. Connection

   - Environment-based configuration
   - Connection pooling
   - Error handling

2. Models
   - User model
   - Story model
   - Answer model
   - GradeLevel model

## Environment Configuration

### Environment Variables

```
# Sample from .env-sample
DATABASE_URL=
OPENAI_API_KEY=
NEXT_PUBLIC_API_URL=
```

### Configuration Files

1. next.config.js

   - Next.js specific configuration
   - Environment variable exposure
   - Build optimization settings

2. postcss.config.js

   - PostCSS plugins
   - TailwindCSS configuration

3. tailwind.config.js
   - Custom theme configuration
   - Plugin configuration
   - Content paths

## Build & Deployment

### Build Configuration

- TypeScript compilation
- Next.js optimization
- Static file handling
- API route bundling

### Testing Setup

1. Vitest Configuration

   ```
   vitest.config.ts
   src/test/setup.ts
   ```

   - Test environment setup
   - Mock configurations
   - Coverage settings

2. Test Utilities
   - Custom test hooks
   - Mock implementations
   - Test helpers

This technical context serves as a reference for understanding the technical foundation and requirements of the Bids AI platform.
</file>

<file path="prompts/REACT_VITEST_UNIT_TESTING.md">
# React Component Testing with Vitest - A Comprehensive Guide

## Introduction to Vitest

Vitest is a next-generation testing framework designed to work seamlessly with Vite. It provides a modern, fast, and feature-rich testing environment specifically optimized for React applications. Some key benefits of Vitest include:

- Native ESM support
- Zero-config setup with Vite projects
- Jest-compatible API
- Built-in code coverage
- Watch mode with smart file detection
- Snapshot testing support

## Setting Up Vitest in a React Project

### 1. Install Required Dependencies

```bash
# Install Vitest and testing utilities
npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom
```

### 2. Configure Vite

Update your `vite.config.js` to include test configuration:

```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
});
```

### 3. Create Test Setup File

Create `src/test/setup.ts`:

```typescript
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import matchers from '@testing-library/jest-dom/matchers';

expect.extend(matchers);

// Automatically clean up after each test
afterEach(() => {
  cleanup();
});
```

### 4. Update Package.json

Add test scripts to your package.json:

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  }
}
```

## Example 1: Button Component with Click Event

### Button Component (`src/components/Button.tsx`)

```tsx
import React from 'react';

interface ButtonProps {
  label: string;
  onClick: () => void;
}

export const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return (
    <button
      type="button"
      onClick={onClick}
      className="px-4 py-2 bg-blue-500 text-white rounded"
      data-testid="custom-button"
    >
      {label}
    </button>
  );
};
```

### Button Test (`src/components/Button.test.tsx`)

```tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  it('renders with correct label', () => {
    render(<Button label="Click Me" onClick={() => {}} />);
    expect(screen.getByTestId('custom-button')).toHaveTextContent('Click Me');
  });

  it('calls onClick handler when clicked', () => {
    const handleClick = vi.fn();
    render(<Button label="Click Me" onClick={handleClick} />);

    fireEvent.click(screen.getByTestId('custom-button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

## Example 2: Input Field with Text Display

### TextInput Component (`src/components/TextInput.tsx`)

```tsx
import React, { useState } from 'react';

export const TextInput: React.FC = () => {
  const [inputValue, setInputValue] = useState('');

  return (
    <div className="space-y-4">
      <input
        type="text"
        value={inputValue}
        onChange={e => setInputValue(e.target.value)}
        placeholder="Enter text"
        className="border p-2 rounded"
        data-testid="text-input"
      />
      <p data-testid="display-text">You typed: {inputValue || 'Nothing yet'}</p>
    </div>
  );
};
```

### TextInput Test (`src/components/TextInput.test.tsx`)

```tsx
import { describe, it, expect } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { TextInput } from './TextInput';

describe('TextInput Component', () => {
  it('displays default text when empty', () => {
    render(<TextInput />);
    expect(screen.getByTestId('display-text')).toHaveTextContent('You typed: Nothing yet');
  });

  it('updates display text when user types', () => {
    render(<TextInput />);
    const input = screen.getByTestId('text-input');

    fireEvent.change(input, { target: { value: 'Hello World' } });
    expect(screen.getByTestId('display-text')).toHaveTextContent('You typed: Hello World');
  });
});
```

## Example 3: Movie Search Component

### MovieSearch Component (`src/components/MovieSearch.tsx`)

```tsx
import React, { useState } from 'react';

interface Movie {
  id: string;
  title: string;
  year: string;
}

export const MovieSearch: React.FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [movies, setMovies] = useState<Movie[]>([]);
  const [loading, setLoading] = useState(false);

  const searchMovies = async () => {
    setLoading(true);
    try {
      const response = await fetch(`https://api.example.com/movies?search=${searchTerm}`);
      const data = await response.json();
      setMovies(data);
    } catch (error) {
      console.error('Error fetching movies:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex gap-2">
        <input
          type="text"
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          placeholder="Search movies..."
          className="border p-2 rounded"
          data-testid="movie-search-input"
        />
        <button
          onClick={searchMovies}
          disabled={loading}
          className="px-4 py-2 bg-blue-500 text-white rounded"
          data-testid="search-button"
        >
          Search
        </button>
      </div>

      {loading ? (
        <p data-testid="loading-text">Loading...</p>
      ) : (
        <ul data-testid="movie-list">
          {movies.map(movie => (
            <li key={movie.id} className="border-b py-2">
              {movie.title} ({movie.year})
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

### MovieSearch Test (`src/components/MovieSearch.test.tsx`)

```tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { MovieSearch } from './MovieSearch';

// Mock the fetch function
const mockMovies = [
  { id: '1', title: 'Test Movie 1', year: '2021' },
  { id: '2', title: 'Test Movie 2', year: '2022' },
];

global.fetch = vi.fn();

describe('MovieSearch Component', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  it('renders search input and button', () => {
    render(<MovieSearch />);
    expect(screen.getByTestId('movie-search-input')).toBeInTheDocument();
    expect(screen.getByTestId('search-button')).toBeInTheDocument();
  });

  it('performs search and displays results', async () => {
    // Mock the fetch response
    (global.fetch as any).mockResolvedValueOnce({
      json: async () => mockMovies,
    });

    render(<MovieSearch />);

    // Type search term
    const input = screen.getByTestId('movie-search-input');
    fireEvent.change(input, { target: { value: 'test' } });

    // Click search button
    const button = screen.getByTestId('search-button');
    fireEvent.click(button);

    // Wait for loading state to complete
    await waitFor(() => {
      expect(screen.queryByTestId('loading-text')).not.toBeInTheDocument();
    });

    // Verify results are displayed
    const movieList = screen.getByTestId('movie-list');
    expect(movieList.children).toHaveLength(2);
    expect(movieList).toHaveTextContent('Test Movie 1');
    expect(movieList).toHaveTextContent('Test Movie 2');
  });

  it('shows loading state while fetching', async () => {
    // Mock a delayed response
    (global.fetch as any).mockImplementationOnce(
      () => new Promise(resolve => setTimeout(resolve, 100))
    );

    render(<MovieSearch />);

    const button = screen.getByTestId('search-button');
    fireEvent.click(button);

    expect(screen.getByTestId('loading-text')).toBeInTheDocument();
  });
});
```

## Best Practices for React Testing with Vitest

1. **Test Component Behavior, Not Implementation**

   - Focus on what the component does, not how it does it
   - Test from the user's perspective
   - Use data-testid attributes sparingly

2. **Arrange-Act-Assert Pattern**

   - Arrange: Set up the component and test data
   - Act: Perform the action being tested
   - Assert: Verify the expected outcome

3. **Mock External Dependencies**

   - Use vi.fn() for function mocks
   - Mock API calls and external services
   - Reset mocks between tests

4. **Use Appropriate Queries**

   - Prefer getByRole over getByTestId
   - Use findBy\* for async operations
   - Use queryBy\* when testing that elements don't exist

5. **Clean Up After Tests**

   - Use afterEach cleanup
   - Reset mocks and timers
   - Clean up any side effects

6. **Write Maintainable Tests**
   - Keep tests focused and simple
   - Use descriptive test names
   - Group related tests using describe blocks

Remember that tests should give you confidence in your code's behavior and serve as documentation for how components should be used. Write tests that are resilient to implementation changes but will fail when the component's behavior changes unexpectedly.
</file>

<file path="prompts/USER_STORIES.md">
User Stories

PDF Upload & Processing:

```
US-1: PDF Upload
As a student,
I want to upload a French PDF story (max 10MB)
So that I can practice my French comprehension and writing

US-2: PDF Validation
As a student,
I want immediate feedback if my PDF is invalid (too large/unreadable/non-French)
So that I can choose an appropriate document

US-3: Text Sectioning
As a student,
I want my story automatically divided into ~150-word sections
So that I can work with manageable chunks of text
```

Question Generation:

```
US-4: Question Creation
As a student,
I want 3-5 comprehension questions generated for each section
So that I can practice understanding the text

US-5: Question Display
As a student,
I want to see one section of text and its questions at a time
So that I can focus on specific parts of the story
```

Answer Submission & Evaluation:

```
US-6: Answer Submission
As a student,
I want to submit single-sentence answers to each question
So that I can demonstrate my understanding

US-7: Answer Evaluation
As a student,
I want my answers evaluated for accuracy (3/5) and grammar (2/5)
So that I can understand my performance

US-8: Error Feedback
As a student,
I want to see explanations for any errors in my answers
So that I can learn from my mistakes
```

Progress & Results:

```
US-9: Progress Saving
As a student,
I want my progress automatically saved in local storage
So that I can continue later if needed

US-10: Results Display
As a student,
I want to see my scores for each question and section
So that I can track my performance

US-11: Session Management
As a student,
I want my current session maintained until I upload a new PDF
So that I can complete my current story practice
```

Technical Requirements:

```
US-12: State Management
As a system,
I want to maintain all data in client-side storage
So that no server-side storage is needed

US-13: Error Handling
As a system,
I want to handle and display appropriate error messages
So that users understand any issues that arise
```

Each of these user stories can be further broken down into acceptance criteria. Would you like me to elaborate on any specific user story with detailed acceptance criteria?
</file>

<file path="public/vercel.svg">
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
</file>

<file path="scripts/createTestUser.ts">
import { User } from '../src/models/User';
import connectDB from '../src/lib/mongodb';

async function createTestUser() {
  try {
    await connectDB();

    const testUser = {
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Check if user already exists
    const existingUser = await User.findOne({ email: testUser.email });
    if (existingUser) {
      console.log('Test user already exists');
      process.exit(0);
    }

    // Create new user
    const user = await User.create(testUser);
    console.log('Created test user:', user);
    process.exit(0);
  } catch (error) {
    console.error('Error creating test user:', error);
    process.exit(1);
  }
}

createTestUser();
</file>

<file path="src/components/french-idol/quiz/QuizContext.test.tsx">
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import React from 'react';
import { QuizProvider, useQuiz } from './QuizContext';

describe('QuizContext', () => {
  it('provides quiz context values', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QuizProvider>{children}</QuizProvider>
    );

    const { result } = renderHook(() => useQuiz(), { wrapper });

    expect(result.current.currentQuestion).toBe(0);
    expect(result.current.score).toBe(0);
    expect(result.current.questionScores).toEqual([]);

    act(() => {
      result.current.setCurrentQuestion(1);
      result.current.setScore(5);
    });

    expect(result.current.currentQuestion).toBe(1);
    expect(result.current.score).toBe(5);
  });

  it('tracks individual question scores when marking questions as answered', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QuizProvider>{children}</QuizProvider>
    );

    const { result } = renderHook(() => useQuiz(), { wrapper });

    act(() => {
      result.current.setQuestions(['Q1', 'Q2', 'Q3']);
      result.current.markQuestionAnswered(0, 3); // Q1 score: 3
      result.current.markQuestionAnswered(1, 5); // Q2 score: 5
    });

    expect(result.current.questionScores).toEqual([3, 5]);
    expect(result.current.score).toBe(8); // Total score should be sum of individual scores
    expect(result.current.answeredQuestions).toEqual([0, 1]);
  });

  it('resets question scores when quiz is reset', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QuizProvider>{children}</QuizProvider>
    );

    const { result } = renderHook(() => useQuiz(), { wrapper });

    act(() => {
      result.current.setQuestions(['Q1', 'Q2']);
      result.current.markQuestionAnswered(0, 4);
      result.current.resetQuiz();
    });

    expect(result.current.questionScores).toEqual([]);
    expect(result.current.score).toBe(0);
    expect(result.current.currentQuestion).toBe(0);
    expect(result.current.answeredQuestions).toEqual([]);
  });

  it('correctly identifies when there are more questions', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QuizProvider>{children}</QuizProvider>
    );

    const { result } = renderHook(() => useQuiz(), { wrapper });

    act(() => {
      result.current.setQuestions(['Q1', 'Q2', 'Q3']);
    });

    // Initially should have more questions
    expect(result.current.hasMoreQuestions()).toBe(true);

    act(() => {
      // Answer first two questions
      result.current.markQuestionAnswered(0, 3);
      result.current.markQuestionAnswered(1, 4);
    });

    // Still has one more question
    expect(result.current.hasMoreQuestions()).toBe(true);

    act(() => {
      // Answer last question
      result.current.markQuestionAnswered(2, 5);
    });

    // No more questions after answering all
    expect(result.current.hasMoreQuestions()).toBe(false);
  });

  it('throws error when useQuiz is used outside of QuizProvider', () => {
    expect(() => renderHook(() => useQuiz())).toThrow('useQuiz must be used within a QuizProvider');
  });
});
</file>

<file path="src/components/french-idol/quiz/QuizContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { determineQuestions } from '../../../hooks/useDetermineQuestions';

interface QuizContextType {
  currentQuestion: number;
  score: number;
  storyText: string;
  questions: string[];
  answeredQuestions: number[];
  questionScores: number[];
  questionResponses: string[];
  questionCorrections: string[];
  questionSuggestedAnswers: string[];
  userEmail: string;
  storyId: string;
  isCompleted: boolean;
  setCurrentQuestion: (question: number) => void;
  setScore: (score: number) => void;
  setStoryText: (text: string) => void;
  setQuestions: (questions: string[]) => void;
  setUserEmail: (email: string) => void;
  setStoryId: (id: string) => void;
  markQuestionAnswered: (
    questionIndex: number,
    grade: number,
    response: string,
    correction: string,
    suggestedAnswer: string
  ) => void;
  hasMoreQuestions: () => boolean;
  resetQuiz: () => void;
}

export const QuizContext = createContext<QuizContextType | undefined>(undefined);

interface QuizProviderProps {
  children: ReactNode;
  initialStoryText?: string;
  initialUserEmail?: string;
  initialStoryId?: string;
}

export const QuizProvider: React.FC<QuizProviderProps> = ({
  children,
  initialStoryText = '',
  initialUserEmail = '',
  initialStoryId = '',
}) => {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [score, setScore] = useState(0);
  const [storyText, setStoryText] = useState(initialStoryText);
  const [questions, setQuestions] = useState<string[]>([]);
  const [answeredQuestions, setAnsweredQuestions] = useState<number[]>([]);
  const [questionScores, setQuestionScores] = useState<number[]>([]);
  const [questionResponses, setQuestionResponses] = useState<string[]>([]);
  const [questionCorrections, setQuestionCorrections] = useState<string[]>([]);
  const [questionSuggestedAnswers, setQuestionSuggestedAnswers] = useState<string[]>([]);
  const [userEmail, setUserEmail] = useState(initialUserEmail);
  const [storyId, setStoryId] = useState(initialStoryId);
  const [isCompleted, setIsCompleted] = useState(false);

  // Reset quiz state when starting a new quiz
  const resetQuiz = () => {
    setCurrentQuestion(0);
    setScore(0);
    setAnsweredQuestions([]);
    setQuestionScores([]);
    setQuestionResponses([]);
    setQuestionCorrections([]);
    setQuestionSuggestedAnswers([]);
    setIsCompleted(false);
  };

  const markStoryComplete = async () => {
    if (userEmail && storyId && !isCompleted) {
      try {
        await fetch('/api/stories/markRead', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email: userEmail,
            storyId: storyId,
            quizScore: score,
            totalQuestions: questions.length,
            questions,
            questionResponses,
            questionCorrections,
          }),
        });
      } catch (error) {
        console.error('Error marking story as read:', error);
      }
    }
  };

  // Effect to handle story text updates
  useEffect(() => {
    const loadQuestions = async () => {
      try {
        if (storyText.trim()) {
          const newQuestions = await determineQuestions(storyText);
          setQuestions(newQuestions);
          resetQuiz();
        } else {
          setQuestions([]);
        }
      } catch (error) {
        console.error('Error loading questions:', error);
        setQuestions([]);
      }
    };

    loadQuestions();
  }, [storyText]);

  const markQuestionAnswered = (
    questionIndex: number,
    grade: number,
    response: string,
    correction: string,
    suggestedAnswer: string
  ) => {
    setAnsweredQuestions(prev => {
      if (prev.includes(questionIndex)) {
        return prev; // Prevent answering the same question multiple times
      }
      return [...prev, questionIndex];
    });
    setScore(prev => prev + grade);
    setQuestionScores(prev => {
      const newScores = [...prev];
      newScores[questionIndex] = grade;
      return newScores;
    });
    setQuestionResponses(prev => {
      const newResponses = [...prev];
      newResponses[questionIndex] = response;
      return newResponses;
    });
    setQuestionCorrections(prev => {
      const newCorrections = [...prev];
      newCorrections[questionIndex] = correction;
      return newCorrections;
    });
    setQuestionSuggestedAnswers(prev => {
      const newSuggestedAnswers = [...prev];
      newSuggestedAnswers[questionIndex] = suggestedAnswer;
      return newSuggestedAnswers;
    });

    // Check if this was the last question
    const newAnsweredCount = answeredQuestions.length + 1;
    if (newAnsweredCount === questions.length) {
      setIsCompleted(true);
      markStoryComplete();
    }

    // Move to next question if available
    if (questionIndex < questions.length - 1) {
      setCurrentQuestion(questionIndex + 1);
    }
  };

  const hasMoreQuestions = () => {
    return currentQuestion < questions.length && answeredQuestions.length < questions.length;
  };

  const value = {
    currentQuestion,
    score,
    storyText,
    questions,
    answeredQuestions,
    questionScores,
    questionResponses,
    questionCorrections,
    questionSuggestedAnswers,
    userEmail,
    storyId,
    isCompleted,
    setCurrentQuestion,
    setScore,
    setStoryText,
    setQuestions,
    setUserEmail,
    setStoryId,
    markQuestionAnswered,
    hasMoreQuestions,
    resetQuiz,
  };

  return <QuizContext.Provider value={value}>{children}</QuizContext.Provider>;
};

export const useQuiz = (): QuizContextType => {
  const context = useContext(QuizContext);
  if (context === undefined) {
    throw new Error('useQuiz must be used within a QuizProvider');
  }
  return context;
};
</file>

<file path="src/components/french-idol/quiz/QuizQuestion.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom'; // Add this to extend expect matchers
import { QuizQuestion } from './QuizQuestion';
import * as useValidResponseModule from '../../../hooks/useValidResponse';
import { QuizContext } from './QuizContext';
import { FrenchIdolProvider } from '../FrenchIdolContext';

vi.mock('../../../hooks/useValidResponse', () => ({
  useValidResponse: vi.fn(),
}));

const mockQuizContext = {
  storyText: 'Test story content',
  currentQuestion: 0,
  score: 0,
  questions: ['Test question'],
  answeredQuestions: [],
  questionScores: [],
  questionResponses: [],
  questionCorrections: [],
  questionSuggestedAnswers: [],
  userEmail: 'test@example.com',
  storyId: 'story-123',
  isCompleted: false,
  setCurrentQuestion: vi.fn(),
  setScore: vi.fn(),
  setStoryText: vi.fn(),
  setQuestions: vi.fn(),
  setUserEmail: vi.fn(),
  setStoryId: vi.fn(),
  markQuestionAnswered: vi.fn(),
  hasMoreQuestions: vi.fn(),
  resetQuiz: vi.fn(),
};

const mockFrenchIdolContext = {
  displayStoryUpload: false,
  setDisplayStoryUpload: vi.fn(),
  storyText: '',
  setStoryText: vi.fn(),
  inputMethod: null,
  setInputMethod: vi.fn(),
  currentUser: null,
  isLoading: false,
  error: null,
  stories: [],
};

vi.mock('../FrenchIdolContext', () => ({
  useFrenchIdol: () => mockFrenchIdolContext,
  FrenchIdolProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
}));

const renderWithQuizContext = (ui: React.ReactElement) => {
  return render(
    <FrenchIdolProvider>
      <QuizContext.Provider value={mockQuizContext}>{ui}</QuizContext.Provider>
    </FrenchIdolProvider>
  );
};

describe('QuizQuestion', () => {
  const mockValidateResponse = vi.fn();
  const mockOnAnswered = vi.fn();
  const defaultProps = {
    question: 'What is the capital of France?',
    questionIndex: 0,
    onAnswered: mockOnAnswered,
  };

  beforeEach(() => {
    mockValidateResponse.mockClear();
    mockOnAnswered.mockClear();
    vi.mocked(useValidResponseModule.useValidResponse).mockReturnValue({
      validateResponse: mockValidateResponse,
      isValidating: false,
    });
  });

  it('renders the question', () => {
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    expect(screen.getByText(defaultProps.question)).toBeInTheDocument();
  });

  it('handles input changes', () => {
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    const input = screen.getByPlaceholderText('Enter your answer...') as HTMLInputElement;
    fireEvent.change(input, { target: { value: 'Paris' } });
    expect(input.value).toBe('Paris');
  });

  it('validates answer and shows result when submit button is clicked', async () => {
    mockValidateResponse.mockResolvedValueOnce({
      grade: 5,
      correction: 'Excellent! Votre réponse est parfaite.',
      suggestedAnswer: 'La capitale de la France est Paris.',
    });
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    const input = screen.getByPlaceholderText('Enter your answer...') as HTMLInputElement;
    const submitButton = screen.getByText('Submit');

    fireEvent.change(input, { target: { value: 'Paris' } });
    fireEvent.click(submitButton);

    expect(mockValidateResponse).toHaveBeenCalledWith(
      defaultProps.question,
      'Paris',
      mockQuizContext.storyText,
      mockQuizContext.userEmail,
      mockQuizContext.storyId
    );
    await waitFor(() => {
      expect(mockOnAnswered).toHaveBeenCalledWith(
        0,
        5,
        'Paris',
        'Excellent! Votre réponse est parfaite.',
        'La capitale de la France est Paris.'
      );
    });
    await waitFor(() => {
      const gradeText = screen.getByText('5/5');
      expect(gradeText).toBeInTheDocument();
      expect(input.value).toBe('');
    });
  });

  it('shows loading state during validation', async () => {
    vi.mocked(useValidResponseModule.useValidResponse).mockReturnValue({
      validateResponse: mockValidateResponse,
      isValidating: true,
    });
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    const submitButton = screen.getByText('Validating...');
    expect(submitButton).toBeDisabled();
  });

  it('does not submit empty answers', async () => {
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    const input = screen.getByPlaceholderText('Enter your answer...');
    const submitButton = screen.getByText('Submit');
    // Try submitting with empty input
    fireEvent.click(submitButton);
    expect(mockValidateResponse).not.toHaveBeenCalled();
    // Try submitting with whitespace
    fireEvent.change(input, { target: { value: '   ' } });
    fireEvent.click(submitButton);
    expect(mockValidateResponse).not.toHaveBeenCalled();
  });

  it('navigates back when back button is clicked', () => {
    renderWithQuizContext(<QuizQuestion {...defaultProps} />);
    const backButton = screen.getByText('Back');
    fireEvent.click(backButton);
    expect(mockFrenchIdolContext.setDisplayStoryUpload).toHaveBeenCalledWith(true);
  });
});
</file>

<file path="src/components/french-idol/quiz/QuizQuestion.tsx">
import React, { useState, useEffect } from 'react';
import { TextInput } from '../../../ui-kit/TextInput';
import { Button } from '../../../ui-kit/Button';
import { useValidResponse } from '../../../hooks/useValidResponse';
import { useQuiz } from './QuizContext';
import { useFrenchIdol } from '../FrenchIdolContext';

interface QuizQuestionProps {
  question: string;
  questionIndex: number;
  onAnswered: (
    index: number,
    grade: number,
    response: string,
    correction: string,
    suggestedAnswer: string
  ) => void;
}

export const QuizQuestion: React.FC<QuizQuestionProps> = ({
  question,
  questionIndex,
  onAnswered,
}) => {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState<string>('');
  const [grade, setGrade] = useState<number | null>(null);

  // Reset states when question changes
  useEffect(() => {
    setError('');
    setGrade(null);
    setAnswer('');
  }, [question]);
  const { validateResponse, isValidating } = useValidResponse();
  const { storyText, userEmail, storyId } = useQuiz();
  const { setDisplayStoryUpload } = useFrenchIdol();

  const handleSubmit = async () => {
    if (!answer.trim()) {
      setError('Please enter an answer');
      return;
    }

    try {
      setError('');
      const result = await validateResponse(question, answer, storyText, userEmail, storyId);
      if (result.errorMessage) {
        setError(result.errorMessage);
        return;
      }

      const questionGrade = result.grade || 0;
      setGrade(questionGrade);
      onAnswered(
        questionIndex,
        questionGrade,
        answer,
        result.correction || '',
        result.suggestedAnswer || ''
      );
      setAnswer('');
    } catch (err) {
      setError(
        err instanceof Error ? err.message : 'An error occurred while validating your answer'
      );
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleSubmit();
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setAnswer(e.target.value);
  };

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold text-gray-800">{question}</h2>
      <div className="flex items-center gap-4">
        <div className="flex-grow">
          <TextInput
            value={answer}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            placeholder="Enter your answer..."
            error={!!error}
          />
          {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
        </div>
        <div className="flex items-center">
          <span className="text-lg font-medium text-gray-600">
            {grade !== null ? `${grade}/5` : '/5'}
          </span>
        </div>
      </div>
      <div className="flex gap-4">
        <Button onClick={() => setDisplayStoryUpload(true)} variant="secondary">
          Back
        </Button>
        <Button onClick={handleSubmit} disabled={isValidating}>
          {isValidating ? 'Validating...' : 'Submit'}
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="src/components/french-idol/quiz/QuizResults.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuizResults } from './QuizResults';

describe('QuizResults', () => {
  const mockResults = [
    {
      question: 'What is the capital of France?',
      score: 5,
      response: 'Paris',
      correction: 'Excellent! Votre réponse est parfaite.',
    },
    {
      question: 'What is the capital of Spain?',
      score: 4,
      response: 'Madrid',
      correction: 'Très bien! Votre réponse est correcte.',
    },
    {
      question: 'What is the capital of Italy?',
      score: 3,
      response: 'Rome',
      correction: 'Bien! Mais il faut faire attention aux accents.',
    },
  ];

  const defaultProps = {
    results: mockResults,
  };

  it('renders the quiz results title', () => {
    render(<QuizResults {...defaultProps} />);
    expect(screen.getByText('Quiz Results')).toBeInTheDocument();
  });

  it('renders all questions, responses, and scores', () => {
    render(<QuizResults {...defaultProps} />);
    mockResults.forEach(result => {
      expect(screen.getByText(result.question)).toBeInTheDocument();
      expect(screen.getByText(result.response)).toBeInTheDocument();
      expect(screen.getByText(`${result.score}/5`)).toBeInTheDocument();
    });
  });

  it('calculates and displays total score correctly', () => {
    render(<QuizResults {...defaultProps} />);
    const totalScore = mockResults.reduce((sum, result) => sum + result.score, 0);
    const maxScore = mockResults.length * 5;
    expect(screen.getByText(`${totalScore}/${maxScore}`)).toBeInTheDocument();
  });

  it('renders empty results gracefully', () => {
    render(<QuizResults results={[]} />);
    expect(screen.getByText('Quiz Results')).toBeInTheDocument();
    expect(screen.getByText('0/0')).toBeInTheDocument();
  });

  it('renders table headers correctly', () => {
    render(<QuizResults {...defaultProps} />);
    expect(screen.getByText('Question')).toBeInTheDocument();
    expect(screen.getByText('Response')).toBeInTheDocument();
    expect(screen.getByText('Score')).toBeInTheDocument();
    expect(screen.getByText('Feedback')).toBeInTheDocument();
  });

  it('renders feedback for each question', () => {
    render(<QuizResults {...defaultProps} />);
    mockResults.forEach(result => {
      expect(screen.getByText(result.correction)).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/components/french-idol/quiz/QuizResults.tsx">
import React from 'react';

interface QuizResult {
  question: string;
  score: number;
  response: string;
  correction: string;
  suggestedAnswer: string;
}

interface QuizResultsProps {
  results: QuizResult[];
}

export const QuizResults: React.FC<QuizResultsProps> = ({ results }) => {
  const totalScore = results.reduce((sum, result) => sum + result.score, 0);
  const maxPossibleScore = results.length * 5; // Assuming max score per question is 5

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold text-gray-800">Quiz Results</h2>
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Question
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Response
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Score
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Feedback
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Suggested Answer
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {results.map((result, index) => (
              <tr key={index}>
                <td className="px-6 py-4 whitespace-normal text-sm text-gray-900">
                  {result.question}
                </td>
                <td className="px-6 py-4 whitespace-normal text-sm text-gray-900">
                  {result.response}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {result.score}/5
                </td>
                <td className="px-6 py-4 whitespace-normal text-sm text-gray-900 italic">
                  {result.correction}
                </td>
                <td className="px-6 py-4 whitespace-normal text-sm text-green-600">
                  {result.suggestedAnswer}
                </td>
              </tr>
            ))}
          </tbody>
          <tfoot className="bg-gray-50">
            <tr>
              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                Total Score
              </td>
              <td colSpan={3}></td>
              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                {totalScore}/{maxPossibleScore}
              </td>
            </tr>
          </tfoot>
        </table>
      </div>
    </div>
  );
};
</file>

<file path="src/components/french-idol/quiz/QuizStory.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QuizStory } from './QuizStory';
import { QuizProvider, useQuiz } from './QuizContext';
import * as determineQuestionsModule from '../../../hooks/useDetermineQuestions';

vi.mock('../../../hooks/useDetermineQuestions', () => ({
  determineQuestions: vi
    .fn()
    .mockImplementation(async () => ['Test question 1', 'Test question 2']),
}));

describe('QuizStory', () => {
  const mockQuestions = ['Test question 1', 'Test question 2'];

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(determineQuestionsModule.determineQuestions).mockResolvedValue([
      'Test question 1',
      'Test question 2',
    ]);
  });

  it('renders textarea', () => {
    render(
      <QuizProvider>
        <QuizStory />
      </QuizProvider>
    );

    const textarea = screen.getByPlaceholderText('Enter your story here...');
    expect(textarea).toBeInTheDocument();
  });

  it('updates story text on input', async () => {
    render(
      <QuizProvider>
        <QuizStory />
      </QuizProvider>
    );

    const textarea = screen.getByPlaceholderText('Enter your story here...');
    fireEvent.change(textarea, { target: { value: 'Test story' } });
    expect(textarea).toHaveValue('Test story');
    await waitFor(() => {
      expect(determineQuestionsModule.determineQuestions).toHaveBeenCalledWith('Test story');
    });
  });

  it('sets questions in context when story text changes', async () => {
    const TestComponent = () => {
      const { questions } = useQuiz();
      return <div data-testid="questions">{JSON.stringify(questions)}</div>;
    };

    render(
      <QuizProvider>
        <TestComponent />
        <QuizStory />
      </QuizProvider>
    );

    const textarea = screen.getByPlaceholderText('Enter your story here...');
    fireEvent.change(textarea, { target: { value: 'Test story' } });

    await waitFor(
      () => {
        expect(determineQuestionsModule.determineQuestions).toHaveBeenCalledWith('Test story');
        const questionsElement = screen.getByTestId('questions');
        expect(questionsElement.textContent).toBe(JSON.stringify(mockQuestions));
      },
      { timeout: 1000 }
    );
  });
});
</file>

<file path="src/components/french-idol/quiz/QuizStory.tsx">
import React, { useEffect } from 'react';
import { TextArea } from '../../../ui-kit/TextArea';
import { useQuiz } from './QuizContext';
import { determineQuestions } from '../../../hooks/useDetermineQuestions';

export const QuizStory: React.FC = () => {
  const { storyText, setStoryText, setQuestions } = useQuiz();

  useEffect(() => {
    const loadQuestions = async () => {
      if (storyText.trim()) {
        const questions = await determineQuestions(storyText);
        setQuestions(questions);
      } else {
        setQuestions([]);
      }
    };

    loadQuestions();
  }, [storyText, setQuestions]);

  const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setStoryText(e.target.value);
  };

  return (
    <div className="w-full h-96">
      <TextArea
        value={storyText}
        onChange={handleTextChange}
        placeholder="Enter your story here..."
        className="h-full"
      />
    </div>
  );
};
</file>

<file path="src/components/french-idol/quiz/QuizView.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import { QuizView } from './QuizView';
import { FrenchIdolContext } from '../FrenchIdolContext';
import { QuizContext } from './QuizContext';
import { describe, it, expect, vi } from 'vitest';

const mockQuizContext = {
  currentQuestion: 0,
  score: 0,
  storyText: 'test story',
  questions: [],
  answeredQuestions: [],
  questionScores: [],
  questionResponses: [],
  questionCorrections: [],
  userEmail: 'test@example.com',
  storyId: 'story-123',
  setCurrentQuestion: () => {},
  setScore: () => {},
  setStoryText: () => {},
  setQuestions: () => {},
  setUserEmail: () => {},
  setStoryId: () => {},
  markQuestionAnswered: () => {},
  hasMoreQuestions: () => false,
  resetQuiz: () => {},
};

describe('QuizView', () => {
  it('renders loading state when isLoading is true', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: false,
          storyText: 'test story',
          inputMethod: null,
          currentUser: null,
          isLoading: true,
          error: null,
          stories: [],
          setDisplayStoryUpload: vi.fn(),
          setStoryText: vi.fn(),
          setInputMethod: vi.fn(),
        }}
      >
        <QuizContext.Provider value={mockQuizContext}>
          <QuizView />
        </QuizContext.Provider>
      </FrenchIdolContext.Provider>
    );

    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });

  it('renders error state when error exists', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: false,
          storyText: 'test story',
          inputMethod: null,
          currentUser: null,
          isLoading: false,
          error: 'Test error',
          stories: [],
          setDisplayStoryUpload: vi.fn(),
          setStoryText: vi.fn(),
          setInputMethod: vi.fn(),
        }}
      >
        <QuizContext.Provider value={mockQuizContext}>
          <QuizView />
        </QuizContext.Provider>
      </FrenchIdolContext.Provider>
    );

    expect(screen.getByText('Test error')).toBeInTheDocument();
  });
});
</file>

<file path="src/components/french-idol/quiz/QuizView.tsx">
import React from 'react';
import { useQuiz } from './QuizContext';
import { Button } from '../../../ui-kit/Button';
import { useFrenchIdol } from '../FrenchIdolContext';
import { QuizStory } from './QuizStory';
import { QuizQuestion } from './QuizQuestion';
import { QuizResults } from './QuizResults';

export const QuizView: React.FC = () => {
  const {
    currentQuestion,
    score,
    questions,
    hasMoreQuestions,
    markQuestionAnswered,
    answeredQuestions,
    questionScores,
    questionResponses,
    questionCorrections,
    questionSuggestedAnswers,
  } = useQuiz();
  const { setDisplayStoryUpload, isLoading, error } = useFrenchIdol();

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 p-4">
      <div className="max-w-2xl w-full bg-white rounded-lg shadow-md p-8">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">French Idol Quiz</h1>

        {isLoading && <div className="text-center text-gray-600">Loading...</div>}
        {error && <div className="text-center text-red-500">{error}</div>}

        {!isLoading && !error && hasMoreQuestions() && (
          <>
            <p className="text-gray-600 mb-4">
              Welcome to the French Idol Quiz! Test your knowledge and improve your French language
              skills.
            </p>
            <div className="flex justify-between items-center text-sm text-gray-500">
              <div>
                <span>
                  Question {currentQuestion + 1} of {questions.length}
                </span>
                <span className="ml-2">({answeredQuestions.length} answered)</span>
              </div>
              <span>Score: {score}</span>
            </div>
            <div className="mt-6 mb-6">
              <QuizStory />
            </div>
          </>
        )}

        {!isLoading && !error && questions.length > 0 && (
          <div className="mt-6 mb-6">
            {hasMoreQuestions() ? (
              <QuizQuestion
                question={questions[currentQuestion]}
                questionIndex={currentQuestion}
                onAnswered={markQuestionAnswered}
              />
            ) : (
              <div className="space-y-6">
                <QuizResults
                  results={questions.map((question, index) => ({
                    question,
                    score: questionScores[index] || 0,
                    response: questionResponses[index] || '',
                    correction: questionCorrections[index] || '',
                    suggestedAnswer: questionSuggestedAnswers[index] || '',
                  }))}
                />
                <div className="text-center">
                  <Button onClick={() => setDisplayStoryUpload(true)}>Start Again</Button>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/components/french-idol/CreateStoryView.tsx">
import { useRouter } from 'next/router';
import { useFrenchIdol } from './FrenchIdolContext';
import { StoryUpload } from './StoryUpload';
import { StoryInput } from '../story/StoryInput';

export function CreateStoryView() {
  const router = useRouter();
  const { resetForm } = useFrenchIdol();

  const handleStoryCreated = () => {
    resetForm();
    router.push('/french-idol');
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Create French Story</h1>
      <div className="max-w-4xl mx-auto">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h2 className="text-xl font-semibold mb-4">Upload PDF</h2>
            <StoryUpload onSuccess={handleStoryCreated} />
          </div>
          <div>
            <h2 className="text-xl font-semibold mb-4">Paste Text</h2>
            <StoryInput onSuccess={handleStoryCreated} />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/french-idol/FrenchIdolContext.test.tsx">
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import React from 'react';
import { FrenchIdolProvider, useFrenchIdol } from './FrenchIdolContext';
import { beforeEach, describe, expect, it, vi } from 'vitest';

// Mock fetch
const mockFetch = vi.fn();
global.fetch = mockFetch;

// Test component that uses the context
function TestComponent() {
  const { displayStoryUpload, setDisplayStoryUpload, currentUser, isLoading, error } =
    useFrenchIdol();
  return (
    <div>
      <div data-testid="test-value">{displayStoryUpload.toString()}</div>
      <div data-testid="loading-value">{isLoading.toString()}</div>
      <div data-testid="error-value">{error || 'no error'}</div>
      <div data-testid="user-value">{currentUser ? currentUser.email : 'no user'}</div>
      <button
        data-testid="toggle-button"
        onClick={() => setDisplayStoryUpload(!displayStoryUpload)}
      >
        Toggle
      </button>
    </div>
  );
}

describe('FrenchIdolContext', () => {
  beforeEach(() => {
    mockFetch.mockReset();
  });

  it('provides displayStoryUpload state with correct initial value', async () => {
    // Mock user fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ user: { email: 'vincent@gmail.com' } }),
    });
    // Mock stories fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ stories: [] }),
    });

    render(
      <FrenchIdolProvider>
        <TestComponent />
      </FrenchIdolProvider>
    );

    // Initial value should be true (as defined in context)
    expect(screen.getByTestId('test-value')).toHaveTextContent('true');
  });

  it('allows updating displayStoryUpload state', async () => {
    // Mock user fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ user: { email: 'vincent@gmail.com' } }),
    });
    // Mock stories fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ stories: [] }),
    });

    render(
      <FrenchIdolProvider>
        <TestComponent />
      </FrenchIdolProvider>
    );

    // Initial value should be true
    expect(screen.getByTestId('test-value')).toHaveTextContent('true');

    // Click button to toggle value
    fireEvent.click(screen.getByTestId('toggle-button'));

    // Value should now be false
    expect(screen.getByTestId('test-value')).toHaveTextContent('false');
  });

  it('loads user data on mount', async () => {
    const mockUser = {
      email: 'vincent@gmail.com',
      firstName: 'Vincent',
      lastName: 'Test',
      id: '123',
      createdAt: '2024-01-29',
      updatedAt: '2024-01-29',
    };

    // Mock user fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ user: mockUser }),
    });
    // Mock stories fetch
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ stories: [] }),
    });

    render(
      <FrenchIdolProvider>
        <TestComponent />
      </FrenchIdolProvider>
    );

    // Should show loading initially
    expect(screen.getByTestId('loading-value')).toHaveTextContent('true');

    // Wait for user data to load
    await screen.findByText(mockUser.email);

    // Loading should be false
    expect(screen.getByTestId('loading-value')).toHaveTextContent('false');
    expect(screen.getByTestId('error-value')).toHaveTextContent('no error');
  });

  it('handles user loading error', async () => {
    // Mock user fetch error
    mockFetch.mockResolvedValueOnce({
      ok: false,
      status: 404,
    });
    // Mock stories fetch (even though it won't be called due to user fetch error)
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ stories: [] }),
    });

    render(
      <FrenchIdolProvider>
        <TestComponent />
      </FrenchIdolProvider>
    );

    // Wait for error state
    await screen.findByText('Failed to fetch user');

    expect(screen.getByTestId('loading-value')).toHaveTextContent('false');
    expect(screen.getByTestId('user-value')).toHaveTextContent('no user');
  });

  it('throws error when used outside provider', () => {
    // Suppress console.error for this test
    const consoleSpy = vi.spyOn(console, 'error');
    consoleSpy.mockImplementation(() => {});

    expect(() => render(<TestComponent />)).toThrow(
      'useFrenchIdol must be used within a FrenchIdolProvider'
    );

    consoleSpy.mockRestore();
  });
});
</file>

<file path="src/components/french-idol/FrenchIdolContext.tsx">
import { createContext, useContext, ReactNode, useState, useEffect } from 'react';
import { User } from '../../types/user';
import { Story } from '../../types/story';

type InputMethod = 'upload' | 'text' | null;

interface FrenchIdolContextType {
  displayStoryUpload: boolean;
  storyText: string;
  inputMethod: InputMethod;
  currentUser: User | null;
  isLoading: boolean;
  error: string | null;
  stories: Story[];
  setDisplayStoryUpload: (display: boolean) => void;
  setStoryText: (text: string) => void;
  setInputMethod: (method: InputMethod) => void;
  resetForm: () => void;
}

const defaultContext: FrenchIdolContextType = {
  displayStoryUpload: true,
  storyText: '',
  inputMethod: null,
  currentUser: null,
  isLoading: false,
  error: null,
  stories: [],
  setDisplayStoryUpload: () => {
    throw new Error('FrenchIdolContext not initialized');
  },
  setStoryText: () => {
    throw new Error('FrenchIdolContext not initialized');
  },
  setInputMethod: () => {
    throw new Error('FrenchIdolContext not initialized');
  },
  resetForm: () => {
    throw new Error('FrenchIdolContext not initialized');
  },
};

export const FrenchIdolContext = createContext<FrenchIdolContextType>(defaultContext);

interface FrenchIdolProviderProps {
  children: ReactNode;
}

export function FrenchIdolProvider({ children }: FrenchIdolProviderProps) {
  const [displayStoryUpload, setDisplayStoryUpload] = useState(true);
  const [storyText, setStoryText] = useState('');
  const [inputMethod, setInputMethod] = useState<InputMethod>(null);
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [stories, setStories] = useState<Story[]>([]);

  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // Load user
        const userResponse = await fetch(`/api/users/getByEmail?email=vincent@gmail.com`);
        if (!userResponse.ok) {
          throw new Error('Failed to fetch user');
        }
        const userData = await userResponse.json();
        setCurrentUser(userData.user);

        // Load unread stories
        const storiesResponse = await fetch(`/api/stories/list?email=vincent@gmail.com&read=false`);
        if (!storiesResponse.ok) {
          throw new Error('Failed to fetch stories');
        }
        const storiesData = await storiesResponse.json();
        setStories(storiesData.stories);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load data');
        console.error('Error loading data:', err);
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  const resetForm = () => {
    setStoryText('');
    setInputMethod(null);
    setDisplayStoryUpload(true);
  };

  const value = {
    displayStoryUpload,
    storyText,
    inputMethod,
    currentUser,
    isLoading,
    error,
    stories,
    setDisplayStoryUpload,
    setStoryText,
    setInputMethod,
    resetForm,
  };

  return <FrenchIdolContext.Provider value={value}>{children}</FrenchIdolContext.Provider>;
}

export function useFrenchIdol() {
  const context = useContext(FrenchIdolContext);
  if (context.setDisplayStoryUpload === defaultContext.setDisplayStoryUpload) {
    throw new Error('useFrenchIdol must be used within a FrenchIdolProvider');
  }
  return context;
}
</file>

<file path="src/components/french-idol/FrenchIdolView.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import { FrenchIdolView } from './FrenchIdolView';
import { FrenchIdolContext } from './FrenchIdolContext';
import { QuizContext } from './quiz/QuizContext';
import { describe, it, expect } from 'vitest';

const mockQuizContext = {
  currentQuestion: 0,
  score: 0,
  storyText: 'test story',
  questions: [],
  answeredQuestions: [],
  questionScores: [],
  questionResponses: [],
  questionCorrections: [],
  userEmail: 'test@example.com',
  storyId: 'story-123',
  setCurrentQuestion: () => {},
  setScore: () => {},
  setStoryText: () => {},
  setQuestions: () => {},
  setUserEmail: () => {},
  setStoryId: () => {},
  markQuestionAnswered: () => {},
  hasMoreQuestions: () => false,
  resetQuiz: () => {},
  isCompleted: false,
};

describe('FrenchIdolView', () => {
  it('renders story list when no story is selected', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: true,
          storyText: '',
          inputMethod: null,
          currentUser: {
            id: 'user-123',
            email: 'test@example.com',
            firstName: 'Test',
            lastName: 'User',
            createdAt: '2024-01-29T12:00:00.000Z',
            updatedAt: '2024-01-29T12:00:00.000Z',
          },
          isLoading: false,
          error: null,
          stories: [],
          setDisplayStoryUpload: () => {},
          setStoryText: () => {},
          setInputMethod: () => {},
          resetForm: () => {},
        }}
      >
        <FrenchIdolView />
      </FrenchIdolContext.Provider>
    );

    expect(screen.getByText('Your Stories')).toBeInTheDocument();
    expect(screen.getByText('Your Unread Stories')).toBeInTheDocument();
    expect(screen.getByText('No unread stories available')).toBeInTheDocument();
  });

  it('renders quiz when a story is selected', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: true,
          storyText: 'test story',
          inputMethod: null,
          currentUser: {
            id: 'user-123',
            email: 'test@example.com',
            firstName: 'Test',
            lastName: 'User',
            createdAt: '2024-01-29T12:00:00.000Z',
            updatedAt: '2024-01-29T12:00:00.000Z',
          },
          isLoading: false,
          error: null,
          stories: [],
          setDisplayStoryUpload: () => {},
          setStoryText: () => {},
          setInputMethod: () => {},
          resetForm: () => {},
        }}
      >
        <QuizContext.Provider value={mockQuizContext}>
          <FrenchIdolView />
        </QuizContext.Provider>
      </FrenchIdolContext.Provider>
    );

    expect(screen.queryByText('Your Unread Stories')).not.toBeInTheDocument();
    expect(screen.queryByText('No unread stories available')).not.toBeInTheDocument();
  });
});
</file>

<file path="src/components/french-idol/FrenchIdolView.tsx">
import { useState } from 'react';
import { useFrenchIdol } from './FrenchIdolContext';
import { Story } from '../../types/story';
import { QuizView } from './quiz/QuizView';
import { QuizProvider } from './quiz/QuizContext';
import { StoryList } from '../story/StoryList';

export function FrenchIdolView() {
  const { storyText, stories, currentUser, setDisplayStoryUpload, setStoryText } = useFrenchIdol();

  const [selectedStoryId, setSelectedStoryId] = useState<string>('');

  const handleStorySelect = (story: Story) => {
    setStoryText(story.article);
    setSelectedStoryId(story.id);
    setDisplayStoryUpload(false);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">French Idol Practice</h1>
      <div className="max-w-4xl mx-auto">
        <h2 className="text-xl font-semibold mb-6">Your Stories</h2>
        {storyText ? (
          <QuizProvider
            initialStoryText={storyText}
            initialUserEmail={currentUser?.email || ''}
            initialStoryId={selectedStoryId}
          >
            <QuizView />
          </QuizProvider>
        ) : (
          <StoryList stories={stories} onStorySelect={handleStorySelect} />
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/french-idol/StoryUpload.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import { StoryUpload } from './StoryUpload';
import { FrenchIdolContext } from './FrenchIdolContext';
import { describe, it, expect, vi, beforeEach } from 'vitest';

// Mock next/dynamic
vi.mock('next/dynamic', () => ({
  default: () => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const DynamicComponent = (props: any) => {
      const parsePdf = vi.fn();
      const isLoading = false;
      const error = null;
      return props.children({ parsePdf, isLoading, error });
    };
    return DynamicComponent;
  },
}));

describe('StoryUpload', () => {
  const mockSetDisplayStoryUpload = vi.fn();
  const mockSetStoryText = vi.fn();
  const mockSetInputMethod = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders file input and submit button', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: true,
          setDisplayStoryUpload: mockSetDisplayStoryUpload,
          setStoryText: mockSetStoryText,
          storyText: '',
          inputMethod: null,
          setInputMethod: mockSetInputMethod,
          currentUser: null,
          isLoading: false,
          error: null,
          stories: [],
        }}
      >
        <StoryUpload />
      </FrenchIdolContext.Provider>
    );

    expect(screen.getByText('Upload your French PDF story')).toBeInTheDocument();
    expect(screen.getByText('Start Practice')).toBeInTheDocument();
  });

  it('disables submit button when no file is selected', () => {
    render(
      <FrenchIdolContext.Provider
        value={{
          displayStoryUpload: true,
          setDisplayStoryUpload: mockSetDisplayStoryUpload,
          setStoryText: mockSetStoryText,
          storyText: '',
          inputMethod: null,
          setInputMethod: mockSetInputMethod,
          currentUser: null,
          isLoading: false,
          error: null,
          stories: [],
        }}
      >
        <StoryUpload />
      </FrenchIdolContext.Provider>
    );

    const submitButton = screen.getByText('Start Practice');
    expect(submitButton).toBeDisabled();
  });
});
</file>

<file path="src/components/french-idol/StoryUpload.tsx">
import { useState, useRef, ChangeEvent } from 'react';
import dynamic from 'next/dynamic';
import { useFrenchIdol } from './FrenchIdolContext';
import { Button } from '../../ui-kit/Button';
import { IconDownload } from '../../ui-kit/icons/IconDownload';
import { cn } from '../../ui-kit/utils/cn';

interface PDFParserChildrenProps {
  parsePdf: (file: File) => Promise<string>;
  isLoading: boolean;
  error: string | null;
}

interface PDFParserProps {
  children: (props: PDFParserChildrenProps) => React.ReactElement;
}

// Import PDF parser hook dynamically with SSR disabled
const DynamicPDFParser = dynamic(
  () =>
    import('../../hooks/usePdfParser').then(mod => {
      const { usePdfParser } = mod;
      return function PDFParserWrapper(props: PDFParserProps) {
        const { parsePdf, isLoading, error } = usePdfParser();
        return props.children({ parsePdf, isLoading, error });
      };
    }),
  { ssr: false }
);

const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes

interface StoryUploadProps {
  onSuccess?: () => void;
}

export function StoryUpload({ onSuccess }: StoryUploadProps) {
  const { setDisplayStoryUpload, setStoryText, setInputMethod } = useFrenchIdol();
  const [file, setFile] = useState<File | null>(null);
  const [error, setError] = useState<string>('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const selectedFile = event.target.files?.[0];
    setError('');

    if (!selectedFile) {
      return;
    }

    // Validate file type
    if (!selectedFile.type.includes('pdf')) {
      setError('Please upload a PDF file');
      return;
    }

    // Validate file size
    if (selectedFile.size > MAX_FILE_SIZE) {
      setError('File size must be less than 10MB');
      return;
    }

    setFile(selectedFile);
  };

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <DynamicPDFParser>
      {({ parsePdf, isLoading, error: parseError }) => (
        <div className="bg-white rounded-lg shadow p-6">
          <div className="text-center">
            <input
              type="file"
              accept=".pdf"
              onChange={handleFileChange}
              ref={fileInputRef}
              className="hidden"
              data-testid="file-input"
            />
            <div
              className={cn(
                'border-2 border-dashed rounded-lg p-8 mb-4 cursor-pointer',
                error || parseError
                  ? 'border-red-300 bg-red-50'
                  : 'border-gray-300 hover:border-gray-400'
              )}
              onClick={handleUploadClick}
            >
              <div className="flex flex-col items-center">
                <IconDownload className="w-12 h-12 text-gray-400 mb-4" />
                <p className="text-lg text-gray-600 mb-2">
                  {file ? file.name : 'Upload your French PDF story'}
                </p>
                <p className="text-sm text-gray-500">Maximum file size: 10MB</p>
              </div>
            </div>

            {(error || parseError) && (
              <div className="text-red-500 text-sm mb-4">{error || parseError}</div>
            )}

            <Button
              onClick={async () => {
                if (!file) return;
                try {
                  const parsedText = await parsePdf(file);
                  setStoryText(parsedText);
                  setInputMethod('upload');
                  setDisplayStoryUpload(false);
                  onSuccess?.();
                } catch (err) {
                  console.error('Error processing file:', err);
                  setError('Error processing PDF file');
                }
              }}
              disabled={!file || isLoading}
            >
              {isLoading ? 'Processing...' : 'Start Practice'}
            </Button>
          </div>
        </div>
      )}
    </DynamicPDFParser>
  );
}
</file>

<file path="src/components/grade-levels/GradeLevelsTable.tsx">
import React, { useState } from 'react';
import { GradeLevel } from '../../types/gradeLevel';

interface GradeLevelsTableProps {
  gradeLevels: GradeLevel[];
}

type SortField = keyof Pick<
  GradeLevel,
  'grade' | 'levelName' | 'averageAge' | 'instructions' | 'storyWordCount'
>;

export const GradeLevelsTable: React.FC<GradeLevelsTableProps> = ({ gradeLevels }) => {
  const [sortField, setSortField] = useState<SortField>('grade');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');

  const handleSort = (field: SortField) => {
    if (field === sortField) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const sortedGradeLevels = [...gradeLevels].sort((a, b) => {
    const aValue = a[sortField];
    const bValue = b[sortField];

    if (typeof aValue === 'string' && typeof bValue === 'string') {
      return sortDirection === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
    }

    return sortDirection === 'asc'
      ? (aValue as number) - (bValue as number)
      : (bValue as number) - (aValue as number);
  });

  const renderSortIcon = (field: SortField) => {
    if (sortField !== field) return null;
    return sortDirection === 'asc' ? '↑' : '↓';
  };

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full bg-white shadow-sm rounded-lg">
        <thead className="bg-gray-50">
          <tr>
            <th
              onClick={() => handleSort('grade')}
              className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
            >
              Grade {renderSortIcon('grade')}
            </th>
            <th
              onClick={() => handleSort('levelName')}
              className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
            >
              Level Name {renderSortIcon('levelName')}
            </th>
            <th
              onClick={() => handleSort('averageAge')}
              className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
            >
              Average Age {renderSortIcon('averageAge')}
            </th>
            <th
              onClick={() => handleSort('instructions')}
              className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
            >
              Instructions {renderSortIcon('instructions')}
            </th>
            <th
              onClick={() => handleSort('storyWordCount')}
              className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
            >
              Word Count {renderSortIcon('storyWordCount')}
            </th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-200">
          {sortedGradeLevels.map(level => (
            <tr key={level.id} className="hover:bg-gray-50">
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{level.grade}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {level.levelName}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {level.averageAge}
              </td>
              <td className="px-6 py-4 text-sm text-gray-900">{level.instructions}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {level.storyWordCount}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
</file>

<file path="src/components/layout/Header.tsx">
import React from 'react';
import Link from 'next/link';
import { MenuDropdown } from './MenuDropdown';

const menuItems = [
  { label: 'Train', href: '/french-idol' },
  { label: 'Results', href: '/results' },
  { label: 'Profile', href: '/profile' },
  { label: 'Create Stories', href: '/french-idol/create' },
  { label: 'Grade Levels', href: '/grade-levels' },
];

export const Header: React.FC = () => {
  return (
    <header className="fixed top-0 w-full bg-white shadow-sm z-50">
      <div className="container mx-auto px-4 h-16 flex items-center justify-between">
        <Link href="/" className="text-xl font-bold text-gray-800">
          French Idol
        </Link>
        <MenuDropdown items={menuItems} />
      </div>
    </header>
  );
};
</file>

<file path="src/components/layout/Layout.tsx">
import React, { ReactNode } from 'react';
import { Header } from './Header';

interface LayoutProps {
  children: ReactNode;
}

export const Layout: React.FC<LayoutProps> = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-50">
      <Header />
      <main className="pt-16">{children}</main>
    </div>
  );
};
</file>

<file path="src/components/layout/MenuDropdown.tsx">
import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { IconMenu } from '../../ui-kit/icons/IconMenu';

interface MenuItem {
  label: string;
  href: string;
}

interface MenuDropdownProps {
  items: MenuItem[];
}

export const MenuDropdown: React.FC<MenuDropdownProps> = ({ items }) => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleItemClick = (href: string) => {
    if (href === '#') {
      alert('Coming Soon!');
    }
    setIsOpen(false);
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="p-2 hover:bg-gray-100 rounded-full transition-colors duration-200"
        aria-label="Menu"
      >
        <IconMenu size={24} />
      </button>

      {/* Dropdown Panel */}
      {/* Mobile Overlay */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden"
          onClick={() => setIsOpen(false)}
        />
      )}

      {/* Dropdown Panel */}
      <div
        className={`
          fixed inset-y-0 right-0 w-64 bg-white z-50 transform transition-all duration-200 ease-in-out
          md:absolute md:inset-auto md:right-0 md:top-full md:mt-1 md:w-48 md:rounded-lg md:shadow-lg
          ${
            isOpen
              ? 'translate-x-0'
              : 'translate-x-full md:translate-y-2 md:opacity-0 md:pointer-events-none'
          }
        `}
      >
        {/* Mobile Close Button */}
        <div className="sticky top-0 p-4 border-b border-gray-200 bg-white md:hidden flex items-center justify-between">
          <span className="font-medium">Menu</span>
          <button onClick={() => setIsOpen(false)} className="text-gray-500 hover:text-gray-700">
            Close
          </button>
        </div>

        {/* Menu Items */}
        <div className="py-2 bg-white">
          {items.map((item, index) => (
            <Link
              key={index}
              href={item.href}
              onClick={() => handleItemClick(item.href)}
              className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors duration-150"
            >
              {item.label}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/profile/ProfileComponent.test.tsx">
/// <reference types="@testing-library/jest-dom" />
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ProfileComponent } from './ProfileComponent';
import { useProfile } from '../../hooks/useProfile';

// Mock the useProfile hook
vi.mock('../../hooks/useProfile');
const mockUseProfile = vi.mocked(useProfile);

describe('ProfileComponent', () => {
  const mockProfile = {
    id: '1',
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
    createdAt: '2024-01-30T12:00:00Z',
    updatedAt: '2024-01-30T12:00:00Z',
  };

  const mockUpdateProfile = vi.fn();

  beforeEach(() => {
    mockUseProfile.mockReturnValue({
      profile: mockProfile,
      loading: false,
      error: null,
      fetchProfile: vi.fn(),
      updateProfile: mockUpdateProfile,
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('renders profile information in display mode', () => {
    render(<ProfileComponent email="test@example.com" />);

    expect(screen.getByText('Profile')).toBeInTheDocument();
    expect(screen.getByText('test@example.com')).toBeInTheDocument();
    expect(screen.getByText('John')).toBeInTheDocument();
    expect(screen.getByText('Doe')).toBeInTheDocument();
    expect(screen.getByText('Edit Profile')).toBeInTheDocument();
  });

  it('switches to edit mode when edit button is clicked', () => {
    render(<ProfileComponent email="test@example.com" />);

    fireEvent.click(screen.getByText('Edit Profile'));

    expect(screen.getByDisplayValue('John')).toBeInTheDocument();
    expect(screen.getByDisplayValue('Doe')).toBeInTheDocument();
    expect(screen.getByText('Save Changes')).toBeInTheDocument();
    expect(screen.getByText('Cancel')).toBeInTheDocument();
  });

  it('handles profile update successfully', async () => {
    render(<ProfileComponent email="test@example.com" />);

    // Enter edit mode
    fireEvent.click(screen.getByText('Edit Profile'));

    // Update form fields
    const firstNameInput = screen.getByDisplayValue('John');
    const lastNameInput = screen.getByDisplayValue('Doe');

    fireEvent.change(firstNameInput, { target: { value: 'Jane' } });
    fireEvent.change(lastNameInput, { target: { value: 'Smith' } });

    // Submit form
    fireEvent.click(screen.getByText('Save Changes'));

    await waitFor(() => {
      expect(mockUpdateProfile).toHaveBeenCalledWith({
        firstName: 'Jane',
        lastName: 'Smith',
      });
    });
  });

  it('displays loading state', () => {
    mockUseProfile.mockReturnValue({
      profile: null,
      loading: true,
      error: null,
      fetchProfile: vi.fn(),
      updateProfile: mockUpdateProfile,
    });

    render(<ProfileComponent email="test@example.com" />);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('displays error state', () => {
    const errorMessage = 'Failed to load profile';
    mockUseProfile.mockReturnValue({
      profile: null,
      loading: false,
      error: errorMessage,
      fetchProfile: vi.fn(),
      updateProfile: mockUpdateProfile,
    });

    render(<ProfileComponent email="test@example.com" />);
    expect(screen.getByText(errorMessage)).toBeInTheDocument();
  });

  it('handles cancel button click', () => {
    render(<ProfileComponent email="test@example.com" />);

    // Enter edit mode
    fireEvent.click(screen.getByText('Edit Profile'));

    // Update form field
    const firstNameInput = screen.getByDisplayValue('John');
    fireEvent.change(firstNameInput, { target: { value: 'Jane' } });

    // Click cancel
    fireEvent.click(screen.getByText('Cancel'));

    // Verify we're back in display mode with original values
    expect(screen.getByText('John')).toBeInTheDocument();
    expect(screen.getByText('Edit Profile')).toBeInTheDocument();
  });
});
</file>

<file path="src/components/profile/ProfileComponent.tsx">
import React, { useEffect, useState } from 'react';
import { useProfile } from '../../hooks/useProfile';
import { TextInput } from '../../ui-kit/TextInput';
import { Button } from '../../ui-kit/Button';

interface ProfileComponentProps {
  email: string;
}

export const ProfileComponent: React.FC<ProfileComponentProps> = ({ email }) => {
  const { profile, loading, error, fetchProfile, updateProfile } = useProfile(email);
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
  });
  const [updateError, setUpdateError] = useState<string | null>(null);

  useEffect(() => {
    fetchProfile();
  }, [fetchProfile]);

  useEffect(() => {
    if (profile) {
      setFormData({
        firstName: profile.firstName,
        lastName: profile.lastName,
      });
    }
  }, [profile]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setUpdateError(null);

    try {
      await updateProfile({
        firstName: formData.firstName.trim(),
        lastName: formData.lastName.trim(),
      });
      setIsEditing(false);
    } catch (err) {
      setUpdateError(err instanceof Error ? err.message : 'Failed to update profile');
    }
  };

  if (loading && !profile) {
    return <div className="flex justify-center p-4">Loading...</div>;
  }

  if (error) {
    return <div className="text-red-500 p-4">{error}</div>;
  }

  if (!profile) {
    return <div className="text-red-500 p-4">Profile not found</div>;
  }

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-md">
      <h1 className="text-2xl font-bold mb-6">Profile</h1>

      {/* Display Mode */}
      {!isEditing && (
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-600">Email</label>
            <p className="mt-1 text-gray-900">{profile.email}</p>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-600">First Name</label>
            <p className="mt-1 text-gray-900">{profile.firstName}</p>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-600">Last Name</label>
            <p className="mt-1 text-gray-900">{profile.lastName}</p>
          </div>
          <Button onClick={() => setIsEditing(true)}>Edit Profile</Button>
        </div>
      )}

      {/* Edit Mode */}
      {isEditing && (
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-600">Email</label>
            <p className="mt-1 text-gray-900">{profile.email}</p>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-600">First Name</label>
            <TextInput
              name="firstName"
              value={formData.firstName}
              onChange={handleInputChange}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-600">Last Name</label>
            <TextInput
              name="lastName"
              value={formData.lastName}
              onChange={handleInputChange}
              required
            />
          </div>
          {updateError && <div className="text-red-500 text-sm">{updateError}</div>}
          <div className="flex space-x-4">
            <Button type="submit">Save Changes</Button>
            <Button
              onClick={() => {
                setIsEditing(false);
                setFormData({
                  firstName: profile.firstName,
                  lastName: profile.lastName,
                });
                setUpdateError(null);
              }}
              variant="secondary"
            >
              Cancel
            </Button>
          </div>
        </form>
      )}
    </div>
  );
};
</file>

<file path="src/components/results/ResultsComponent.test.tsx">
/// <reference types="@testing-library/jest-dom" />
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ResultsComponent } from './ResultsComponent';
import { vi, describe, it, expect, beforeEach } from 'vitest';

describe('ResultsComponent', () => {
  const mockStories = [
    {
      id: '1',
      title: 'Test Story 1',
      userEmail: 'test@example.com',
      sourceText: 'source',
      article: 'article',
      read: true,
      quizScore: 8,
      totalQuestions: 10,
      questions: ['Q1', 'Q2'],
      questionResponses: ['A1', 'A2'],
      questionCorrections: ['C1', 'C2'],
      createdAt: '2024-01-30T12:00:00Z',
      updatedAt: '2024-01-30T13:00:00Z',
    },
  ];

  const mockAnswers = [
    {
      id: '1',
      question: 'Q1',
      answer: 'A1',
      score: 4,
      correction: 'C1',
    },
    {
      id: '2',
      question: 'Q2',
      answer: 'A2',
      score: 4,
      correction: 'C2',
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    let fetchCount = 0;
    global.fetch = vi.fn().mockImplementation(() => {
      fetchCount++;
      // First fetch returns stories
      if (fetchCount === 1) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ stories: mockStories }),
        });
      }
      // Second fetch returns answers
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ answers: mockAnswers }),
      });
    });
  });

  it('renders loading state initially', () => {
    render(<ResultsComponent email="test@example.com" />);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('renders stories after loading', async () => {
    render(<ResultsComponent email="test@example.com" />);

    // Wait for loading to complete
    expect(await screen.findByText('Test Story 1')).toBeInTheDocument();
    const scoreElement = screen.getByTestId('story-score');
    expect(scoreElement).toHaveTextContent('8 / 10');
    expect(scoreElement).toHaveTextContent('80%');
  });

  it('shows "No completed stories" message when no stories exist', async () => {
    global.fetch = vi.fn().mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ stories: [] }),
      })
    );
    render(<ResultsComponent email="test@example.com" />);

    expect(await screen.findByText('No completed stories found')).toBeInTheDocument();
  });

  it('opens quiz results modal when clicking view results', async () => {
    render(<ResultsComponent email="test@example.com" />);

    // Wait for the button to appear and click it
    const viewButton = await screen.findByText('View Results');
    fireEvent.click(viewButton);

    // Wait for loading state
    expect(screen.getByText('Loading...')).toBeInTheDocument();

    // Wait for modal content to appear
    const modalTitle = await screen.findByTestId('modal-title');
    expect(modalTitle).toHaveTextContent('Test Story 1');
    expect(screen.getByRole('button', { name: '✕' })).toBeInTheDocument();
  });

  it('closes quiz results modal when clicking close button', async () => {
    render(<ResultsComponent email="test@example.com" />);

    // Open modal
    const viewButton = await screen.findByText('View Results');
    fireEvent.click(viewButton);

    // Wait for modal content to appear
    const closeButton = await screen.findByRole('button', { name: '✕' });
    fireEvent.click(closeButton);

    // Check if modal is closed
    expect(screen.queryByRole('button', { name: '✕' })).not.toBeInTheDocument();
  });

  it('shows error modal when answers fetch fails', async () => {
    // Override fetch mock for this test
    global.fetch = vi
      .fn()
      .mockImplementationOnce(() =>
        // First fetch returns stories
        Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ stories: mockStories }),
        })
      )
      .mockImplementationOnce(() =>
        // Second fetch fails
        Promise.resolve({
          ok: false,
          json: () => Promise.resolve({ message: 'Failed to fetch answers' }),
        })
      );

    render(<ResultsComponent email="test@example.com" />);

    // Wait for the button to appear and click it
    const viewButton = await screen.findByText('View Results');
    fireEvent.click(viewButton);

    // Check if error message is displayed
    expect(await screen.findByText('Failed to fetch answers')).toBeInTheDocument();
  });
});
</file>

<file path="src/components/results/ResultsComponent.tsx">
import React, { useEffect, useState } from 'react';
import { Story, QuizResultData } from '../../types/story';
import { StoryQuizModal } from './StoryQuizModal';

interface ResultsComponentProps {
  email: string;
}

export const ResultsComponent: React.FC<ResultsComponentProps> = ({ email }) => {
  const [stories, setStories] = useState<Story[]>([]);
  const [selectedStory, setSelectedStory] = useState<Story | null>(null);
  const [storyAnswers, setStoryAnswers] = useState<QuizResultData[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [loadingAnswers, setLoadingAnswers] = useState(false);
  const [, setError] = useState<string | null>(null);
  const [answerError, setAnswerError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStories = async () => {
      try {
        const response = await fetch(
          `/api/stories/getReadStories?email=${encodeURIComponent(email)}`
        );
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || 'Failed to fetch stories');
        }

        setStories(data.stories);
        setError(null);
      } catch (error) {
        console.error('Error fetching stories:', error);
        setError(error instanceof Error ? error.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchStories();
  }, [email]);

  if (loading) {
    return <div className="text-center mt-8">Loading...</div>;
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">Completed Stories</h1>

      <div className="overflow-x-auto">
        <table className="min-w-full bg-white rounded-lg overflow-hidden shadow-lg">
          <thead className="bg-gray-100">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Title
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Score
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Questions
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Completion Date
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {stories.map(story => (
              <tr key={story.id}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  {story.title}
                </td>
                <td
                  className="px-6 py-4 whitespace-nowrap text-sm text-gray-500"
                  data-testid="story-score"
                >
                  {story.quizScore} / {story.totalQuestions}(
                  {Math.round((story.quizScore! / story.totalQuestions!) * 100)}%)
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {story.totalQuestions}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {new Date(story.updatedAt).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <button
                    onClick={async () => {
                      console.log('View Results clicked for story:', story);
                      setSelectedStory(story);
                      setLoadingAnswers(true);
                      setAnswerError(null);
                      setStoryAnswers(null);

                      try {
                        const response = await fetch(
                          `/api/stories/getStoryAnswers?storyId=${encodeURIComponent(
                            story.id
                          )}&email=${encodeURIComponent(email)}`
                        );
                        const data = await response.json();

                        if (!response.ok) {
                          throw new Error(data.message || 'Failed to fetch answers');
                        }

                        setStoryAnswers(data.answers);
                      } catch (error) {
                        console.error('Error fetching answers:', error);
                        setAnswerError(
                          error instanceof Error ? error.message : 'An error occurred'
                        );
                        setSelectedStory(null);
                      } finally {
                        setLoadingAnswers(false);
                      }
                    }}
                    className="text-blue-600 hover:text-blue-900"
                    disabled={loadingAnswers}
                  >
                    {loadingAnswers ? 'Loading...' : 'View Results'}
                  </button>
                </td>
              </tr>
            ))}
            {stories.length === 0 && (
              <tr>
                <td colSpan={5} className="px-6 py-4 text-center text-gray-500">
                  No completed stories found
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>

      {answerError && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[100]">
          <div className="bg-white rounded-lg p-6 max-w-md">
            <h2 className="text-xl font-semibold mb-4">Error</h2>
            <p className="text-red-600">{answerError}</p>
            <button
              onClick={() => setAnswerError(null)}
              className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Close
            </button>
          </div>
        </div>
      )}

      {selectedStory && !loadingAnswers && !answerError && (
        <StoryQuizModal
          story={selectedStory}
          answers={storyAnswers || undefined}
          onClose={() => {
            setSelectedStory(null);
            setStoryAnswers(null);
          }}
        />
      )}
    </div>
  );
};
</file>

<file path="src/components/results/StoryQuizModal.tsx">
import React from 'react';
import { Story, QuizResultData } from '../../types/story';
import { QuizResults } from '../french-idol/quiz/QuizResults';

interface StoryQuizModalProps {
  story: Story;
  onClose: () => void;
  answers?: QuizResultData[];
}

export const StoryQuizModal: React.FC<StoryQuizModalProps> = ({ story, onClose, answers }) => {
  console.log('StoryQuizModal received story:', story);

  // If answers are provided directly, use them
  if (answers) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[100]">
        <div className="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[90vh] overflow-y-auto">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold" data-testid="modal-title">
              {story.title}
            </h2>
            <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
              ✕
            </button>
          </div>
          <QuizResults results={answers} />
        </div>
      </div>
    );
  }

  // Fallback to using story data for backward compatibility
  if (!story.questions || !story.questionResponses || !story.questionCorrections) {
    console.log('Missing required story data:', {
      hasQuestions: !!story.questions,
      hasResponses: !!story.questionResponses,
      hasCorrections: !!story.questionCorrections,
    });
    return null;
  }

  const results = story.questions.map((question, index) => ({
    question,
    response: story.questionResponses![index],
    correction: story.questionCorrections![index],
    score: story.quizScore! / story.totalQuestions!, // Approximate individual scores
    suggestedAnswer: story.suggestedAnswers?.[index] || 'No suggested answer available',
  }));

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[100]">
      <div className="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold" data-testid="modal-title">
            {story.title}
          </h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
            ✕
          </button>
        </div>
        <QuizResults results={results} />
      </div>
    </div>
  );
};
</file>

<file path="src/components/story/StoryInput.test.tsx">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { StoryInput } from './StoryInput';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { FrenchIdolContext } from '../french-idol/FrenchIdolContext';
import '@testing-library/jest-dom';

const mockFrenchIdolContext = {
  displayStoryUpload: true,
  storyText: '',
  inputMethod: null,
  currentUser: null,
  isLoading: false,
  error: null,
  stories: [],
  setDisplayStoryUpload: vi.fn(),
  setStoryText: vi.fn(),
  setInputMethod: vi.fn(),
  resetForm: vi.fn(),
};

const renderWithContext = (ui: React.ReactElement) => {
  return render(
    <FrenchIdolContext.Provider value={mockFrenchIdolContext}>{ui}</FrenchIdolContext.Provider>
  );
};

describe('StoryInput', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders textarea and submit button', () => {
    renderWithContext(<StoryInput />);
    expect(screen.getByPlaceholderText('Paste your story text here...')).toBeInTheDocument();
    expect(screen.getByText('Create Story')).toBeInTheDocument();
  });

  it('shows error when submitting empty text', () => {
    renderWithContext(<StoryInput />);
    fireEvent.click(screen.getByText('Create Story'));
    expect(screen.getByText('Please enter some text')).toBeInTheDocument();
  });

  it('clears error when user starts typing', () => {
    renderWithContext(<StoryInput />);
    fireEvent.click(screen.getByText('Create Story'));
    expect(screen.getByText('Please enter some text')).toBeInTheDocument();
    const textarea = screen.getByPlaceholderText('Paste your story text here...');
    fireEvent.change(textarea, { target: { value: 'a' } });
    expect(screen.queryByText('Please enter some text')).not.toBeInTheDocument();
  });
});
</file>

<file path="src/components/story/StoryInput.tsx">
import { useState } from 'react';
import { TextArea } from '../../ui-kit/TextArea';
import { Button } from '../../ui-kit/Button';
import { useFrenchIdol } from '../french-idol/FrenchIdolContext';
import { GenerateStoryApiResponse } from '../../types/api/generateStory';

const escapeText = (text: string): string => {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
    .replace(/\\/g, '\\\\')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
};

interface StoryInputProps {
  onSuccess?: () => void;
}

export const StoryInput = ({ onSuccess }: StoryInputProps) => {
  const { currentUser } = useFrenchIdol();
  const [isLoading, setIsLoading] = useState(false);
  const [text, setText] = useState('');
  const [error, setError] = useState('');

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="space-y-4">
        <TextArea
          value={text}
          onChange={e => {
            setText(e.target.value);
            if (error) setError('');
          }}
          placeholder="Paste your story text here..."
          className="min-h-[200px]"
          error={!!error}
        />
        {error && <p className="text-red-500 text-sm">{error}</p>}
        <Button
          onClick={async () => {
            if (!text.trim()) {
              setError('Please enter some text');
              return;
            }
            setError('');
            setIsLoading(true);
            try {
              const response = await fetch('/api/generateStory', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  text: escapeText(text),
                  email: currentUser?.email || '',
                }),
              });

              const data: GenerateStoryApiResponse = await response.json();

              if (!response.ok) {
                throw new Error(data.error?.message || 'Failed to generate story');
              }

              if (data.story) {
                onSuccess?.();
              }
            } catch (e) {
              setError(e instanceof Error ? e.message : 'Failed to generate story');
            } finally {
              setIsLoading(false);
            }
          }}
          disabled={isLoading}
        >
          {isLoading ? 'Processing...' : 'Create Story'}
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="src/components/story/StoryList.test.tsx">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { StoryList } from './StoryList';
import { Story } from '../../types/story';
import { describe, it, expect, vi } from 'vitest';

describe('StoryList', () => {
  const mockStories: Story[] = [
    {
      id: '1',
      title: 'Test Story 1',
      userEmail: 'test@example.com',
      sourceText: 'test content',
      article: 'test article',
      read: false,
      createdAt: '2024-01-29T00:00:00.000Z',
      updatedAt: '2024-01-29T00:00:00.000Z',
    },
    {
      id: '2',
      title: 'Test Story 2',
      userEmail: 'test@example.com',
      sourceText: 'test content 2',
      article: 'test article 2',
      read: false,
      createdAt: '2024-01-29T00:00:00.000Z',
      updatedAt: '2024-01-29T00:00:00.000Z',
    },
  ];

  it('renders story titles and read buttons', () => {
    render(<StoryList stories={mockStories} onStorySelect={() => {}} />);

    expect(screen.getByText('Your Unread Stories')).toBeInTheDocument();
    expect(screen.getByText('Test Story 1')).toBeInTheDocument();
    expect(screen.getByText('Test Story 2')).toBeInTheDocument();
    expect(screen.getAllByText('Read')).toHaveLength(2);
  });

  it('renders empty state message when no stories', () => {
    render(<StoryList stories={[]} onStorySelect={() => {}} />);

    expect(screen.getByText('Your Unread Stories')).toBeInTheDocument();
    expect(screen.getByText('No unread stories available')).toBeInTheDocument();
    expect(screen.queryByText('Read')).not.toBeInTheDocument();
  });

  it('calls onStorySelect when Read button is clicked', () => {
    const mockOnStorySelect = vi.fn();
    render(<StoryList stories={mockStories} onStorySelect={mockOnStorySelect} />);

    const readButtons = screen.getAllByText('Read');
    fireEvent.click(readButtons[0]);

    expect(mockOnStorySelect).toHaveBeenCalledWith(mockStories[0]);
  });
});
</file>

<file path="src/components/story/StoryList.tsx">
import React from 'react';
import { Story } from '../../types/story';

interface StoryListProps {
  stories: Story[];
  onStorySelect: (story: Story) => void;
}

export function StoryList({ stories, onStorySelect }: StoryListProps) {
  return (
    <div className="mt-8">
      <h2 className="text-xl font-semibold mb-4">Your Unread Stories</h2>
      <div className="space-y-4">
        {stories.map(story => (
          <div
            key={story.id}
            className="flex items-center justify-between p-4 bg-white rounded-lg shadow"
          >
            <h3 className="text-lg font-medium">{story.title}</h3>
            <button
              onClick={() => onStorySelect(story)}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Read
            </button>
          </div>
        ))}
        {stories.length === 0 && (
          <p className="text-gray-500 text-center">No unread stories available</p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/constants/prompts.ts">
export const VALIDATE_RESPONSE_SYSTEM_PROMPT = `You are responsible for validating a response from a 10 year old student who is asking questions about the following article:

{article}

The student was asked the following question:
{question}

Please grade their response:
{response}

Grading criteria:
1.5 points for accuracy
1.5 points for writing a complete sentence
2 points for grammar

Here are key points for grammar:
1. The sentences must have a period at the end
2. Must start with a capital letter and have Capital letters for proper nouns
3. Must have proper accented characters for French

Provide your response in the following JSON format:
{
  "score": (number between 0 and 5),
  "correction": "(detailed explanation in French of the grade, including what was done well and what could be improved. Even for perfect scores, provide encouraging feedback.  No more than 30 words)",
  "suggestedAnswer": "(write a model answer in French that would receive a perfect score. Keep it concise but complete.)"
}`;

export const REVIEW_RESPONSE_SYSTEM_PROMPT = `You are responsible for reviewing the evaluation of a student's response. Here is the original grading criteria:

Grading criteria:
1.5 points for accuracy
1.5 points for writing a complete sentence
2 points for grammar

Grammar key points:
1. The sentences must have a period at the end
2. Must start with a capital letter and have Capital letters for proper nouns
3. Must have proper accented characters for French

Please review the following:
Story: {story}
Question: {question}
Student Response: {response}

Initial Evaluation:
Score: {score}
Correction: {correction}
Suggested Answer: {suggestedAnswer}

Review this evaluation and determine if the score and correction align with the response and grading criteria.

Provide your response in the following JSON format:
{
  "isScoreAccurate": boolean,
  "finalScore": number,
  "finalCorrection": "string (use original correction if accurate, otherwise provide revised correction)",
  "reviewComments": "string (explain why changes were made or why original evaluation was correct)"
}`;
</file>

<file path="src/hooks/useDetermineQuestions.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { determineQuestions } from './useDetermineQuestions';

describe('determineQuestions', () => {
  beforeEach(() => {
    // Mock fetch globally
    global.fetch = vi.fn();
  });

  it('should return an array of questions from the API', async () => {
    const mockQuestions = ['Question 1?', 'Question 2?', 'Question 3?'];
    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: true,
      json: async () => ({ questions: mockQuestions }),
    });

    const storyText = 'This is a sample story';
    const questions = await determineQuestions(storyText);

    expect(global.fetch).toHaveBeenCalledWith('/api/generateQuestions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ story: storyText }),
    });
    expect(questions).toEqual(mockQuestions);
  });

  it('should throw error when API call fails', async () => {
    const errorMessage = 'API Error';
    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      ok: false,
      json: async () => ({ error: { message: errorMessage } }),
    });

    const storyText = 'This is a sample story';
    await expect(determineQuestions(storyText)).rejects.toThrow(errorMessage);
  });
});
</file>

<file path="src/hooks/useDetermineQuestions.ts">
export const determineQuestions = async (storyText: string): Promise<string[]> => {
  const response = await fetch('/api/generateQuestions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ story: storyText }),
  });

  const data = await response.json();

  if (!response.ok || data.error) {
    throw new Error(data.error?.message || 'Failed to generate questions');
  }

  return data.questions;
};
</file>

<file path="src/hooks/usePdfParser.test.ts">
import { renderHook, act } from '@testing-library/react';
import { flushSync } from 'react-dom';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { usePdfParser } from './usePdfParser';
import pdfToText from 'react-pdftotext';

vi.mock('react-pdftotext', () => {
  return {
    default: vi.fn(),
  };
});

describe('usePdfParser', () => {
  const mockText = 'Sample PDF content\n\nAnother paragraph';

  beforeEach(() => {
    vi.mocked(pdfToText).mockReset();
  });

  it('should parse PDF file and return text content', async () => {
    vi.mocked(pdfToText).mockResolvedValue(mockText);

    const { result } = renderHook(() => usePdfParser());
    const file = new File([''], 'test.pdf', { type: 'application/pdf' });
    let parsedText: string | undefined;

    await act(async () => {
      parsedText = await result.current.parsePdf(file);
    });

    expect(parsedText).toBe('Sample PDF content\n\nAnother paragraph');
    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBe(null);
  });

  it('should handle parsing errors', async () => {
    const mockError = new Error('PDF parsing failed');
    vi.mocked(pdfToText).mockRejectedValue(mockError);

    const { result } = renderHook(() => usePdfParser());
    const file = new File([''], 'test.pdf', { type: 'application/pdf' });

    await act(async () => {
      try {
        await result.current.parsePdf(file);
      } catch (error) {
        // Error is expected
      }
    });

    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBe('Failed to parse PDF');
  });

  it('should set loading state while parsing', async () => {
    vi.mocked(pdfToText).mockImplementation(
      () =>
        new Promise(resolve => {
          setTimeout(() => resolve(mockText), 100);
        })
    );

    const { result } = renderHook(() => usePdfParser());
    const file = new File([''], 'test.pdf', { type: 'application/pdf' });

    let promise: Promise<string>;
    await act(async () => {
      flushSync(() => {
        promise = result.current.parsePdf(file);
      });
      expect(result.current.isLoading).toBe(true);
      await promise;
    });

    expect(result.current.isLoading).toBe(false);
  });
});
</file>

<file path="src/hooks/usePdfParser.ts">
import { useState } from 'react';
import pdfToText from 'react-pdftotext';

export function usePdfParser() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const parsePdf = async (file: File): Promise<string> => {
    setIsLoading(true);
    setError(null);
    try {
      const text = await pdfToText(file);
      const formattedText = text
        .split(/\n\s*\n/)
        .map(chunk => chunk.trim())
        .filter(chunk => chunk.length > 0)
        .join('\n\n');
      return formattedText;
    } catch (err) {
      setError('Failed to parse PDF');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  return { parsePdf, isLoading, error };
}
</file>

<file path="src/hooks/useProfile.ts">
import { useState, useCallback } from 'react';
import { User } from '../types/user';

interface UseProfileReturn {
  profile: User | null;
  loading: boolean;
  error: string | null;
  fetchProfile: () => Promise<void>;
  updateProfile: (updates: { firstName: string; lastName: string }) => Promise<void>;
}

export const useProfile = (email: string): UseProfileReturn => {
  const [profile, setProfile] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchProfile = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(`/api/users/getByEmail?email=${encodeURIComponent(email)}`);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch profile');
      }

      setProfile(data.user);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [email]);

  const updateProfile = useCallback(
    async (updates: { firstName: string; lastName: string }) => {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch('/api/users/updateProfile', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email,
            ...updates,
          }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to update profile');
        }

        setProfile(data.user);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
        throw err; // Re-throw to handle in the component
      } finally {
        setLoading(false);
      }
    },
    [email]
  );

  return {
    profile,
    loading,
    error,
    fetchProfile,
    updateProfile,
  };
};
</file>

<file path="src/hooks/useValidResponse.test.ts">
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { useValidResponse } from './useValidResponse';
import { ValidateResponseApiResponse } from '../types/api/validateResponse';

describe('useValidResponse', () => {
  const mockAnswer = {
    id: 'test-id',
    userEmail: 'test@example.com',
    storyId: 'story-123',
    question: 'test question',
    answer: 'test answer',
    score: 3,
    correction: 'Bien fait!',
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  beforeEach(() => {
    vi.useFakeTimers();
    // Mock fetch globally
    global.fetch = vi.fn();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should return validation state and function', () => {
    const { result } = renderHook(() => useValidResponse());

    expect(result.current.validateResponse).toBeDefined();
    expect(result.current.isValidating).toBe(false);
  });

  it('should return a grade, correction, and saved answer', async () => {
    const mockResponse: ValidateResponseApiResponse = {
      score: 3,
      correction: 'Bien fait! Votre réponse est correcte mais pourrait être plus détaillée.',
      savedAnswer: mockAnswer,
    };
    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      json: () => Promise.resolve(mockResponse),
    });

    const { result } = renderHook(() => useValidResponse());

    const validationResult = await act(async () => {
      return result.current.validateResponse(
        'test question',
        'test answer',
        'test story',
        'test@example.com',
        'story-123'
      );
    });

    expect(validationResult.grade).toBe(3);
    expect(validationResult.correction).toBe(
      'Bien fait! Votre réponse est correcte mais pourrait être plus détaillée.'
    );
    expect(validationResult.savedAnswer).toEqual(mockAnswer);
  });

  it('should include error message when API returns an error', async () => {
    const mockResponse: ValidateResponseApiResponse = {
      error: {
        message: 'Your response needs improvement',
        code: 'VALIDATION_ERROR',
      },
    };
    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      json: () => Promise.resolve(mockResponse),
    });

    const { result } = renderHook(() => useValidResponse());

    const validationResult = await act(async () => {
      return result.current.validateResponse(
        'test question',
        'test answer',
        'test story',
        'test@example.com',
        'story-123'
      );
    });

    expect(validationResult.grade).toBe(0);
    expect(validationResult.errorMessage).toBe('Your response needs improvement');
  });

  it('should not include error message when API returns a valid score', async () => {
    const mockResponse: ValidateResponseApiResponse = {
      score: 5,
      correction: 'Excellent travail! Votre réponse est parfaite.',
      savedAnswer: {
        ...mockAnswer,
        score: 5,
        correction: 'Excellent travail! Votre réponse est parfaite.',
      },
    };
    (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
      json: () => Promise.resolve(mockResponse),
    });

    const { result } = renderHook(() => useValidResponse());

    const validationResult = await act(async () => {
      return result.current.validateResponse(
        'test question',
        'test answer',
        'test story',
        'test@example.com',
        'story-123'
      );
    });

    expect(validationResult.grade).toBe(5);
    expect(validationResult.correction).toBe('Excellent travail! Votre réponse est parfaite.');
    expect(validationResult.errorMessage).toBeUndefined();
    expect(validationResult.savedAnswer).toBeDefined();
  });
});
</file>

<file path="src/hooks/useValidResponse.ts">
import { useState, useCallback } from 'react';
import { ValidateResponseApiResponse } from '../types/api/validateResponse';

export interface ValidationResult {
  grade: number;
  correction?: string;
  suggestedAnswer?: string;
  errorMessage?: string;
  savedAnswer?: {
    id: string;
    userEmail: string;
    storyId: string;
    question: string;
    answer: string;
    score: number;
    correction: string;
    createdAt: string;
    updatedAt: string;
  };
}

export const useValidResponse = () => {
  const [isValidating, setIsValidating] = useState(false);

  const validateResponse = useCallback(
    async (
      question: string,
      userInput: string,
      story: string,
      userEmail: string,
      storyId: string
    ): Promise<ValidationResult> => {
      setIsValidating(true);
      try {
        const response = await fetch('/api/validateResponse', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            story,
            question,
            response: userInput,
            userEmail,
            storyId,
          }),
        });

        const data: ValidateResponseApiResponse = await response.json();

        if ('error' in data && data.error) {
          throw new Error(data.error.message);
        }

        return {
          grade: data.score || 0,
          correction: data.correction,
          suggestedAnswer: data.suggestedAnswer,
          savedAnswer: data.savedAnswer,
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Failed to validate response';
        return {
          grade: 0,
          errorMessage,
        };
      } finally {
        setIsValidating(false);
      }
    },
    []
  );

  return {
    validateResponse,
    isValidating,
  };
};
</file>

<file path="src/lib/__tests__/mongodb.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import mongoose from 'mongoose';
import connectDB from '../mongodb';

type GlobalWithMongoose = typeof global & {
  mongooseConnection: typeof mongoose | null;
};

vi.mock('mongoose', () => ({
  default: {
    connect: vi.fn().mockImplementation(() => mongoose.default),
    disconnect: vi.fn(),
  },
}));

describe('MongoDB Connection', () => {
  const mockMongoURI = 'mongodb://test-uri';
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = { ...originalEnv, MONGO_URI: mockMongoURI };
    vi.clearAllMocks();
    // Reset global connection
    (global as GlobalWithMongoose).mongooseConnection = null;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  it('should connect to MongoDB with correct URI', async () => {
    await connectDB();
    expect(mongoose.connect).toHaveBeenCalledWith(mockMongoURI, {
      bufferCommands: false,
    });
  });

  it('should reuse existing connection if available', async () => {
    // First connection
    await connectDB();
    expect(mongoose.connect).toHaveBeenCalledTimes(1);

    // Second connection attempt
    await connectDB();
    expect(mongoose.connect).toHaveBeenCalledTimes(2); // Should not call connect again
  });

  it('should handle connection errors', async () => {
    const mockError = new Error('Connection failed');
    vi.mocked(mongoose.connect).mockRejectedValueOnce(mockError);

    await expect(connectDB()).rejects.toThrow('Connection failed');
  });

  it('should throw error if MONGO_URI is not defined', async () => {
    process.env.MONGO_URI = undefined;
    await expect(connectDB()).rejects.toThrow('Please define the MONGO_URI environment variable');
  });
});
</file>

<file path="src/lib/mongodb.ts">
import mongoose from 'mongoose';

/**
 * Global is used here to maintain a cached connection across hot reloads
 * in development. This prevents connections growing exponentially
 * during API Route usage.
 */
const globalWithMongoose = global as typeof global & {
  mongooseConnection: typeof mongoose | null;
};

if (!globalWithMongoose.mongooseConnection) {
  globalWithMongoose.mongooseConnection = null;
}

async function connectDB(): Promise<typeof mongoose> {
  const MONGODB_URI = process.env.MONGO_URI;

  if (!MONGODB_URI) {
    throw new Error('Please define the MONGO_URI environment variable');
  }

  if (globalWithMongoose.mongooseConnection) {
    return globalWithMongoose.mongooseConnection;
  }

  try {
    console.log('Connecting to MongoDB...');
    const mongooseInstance = await mongoose.connect(MONGODB_URI, {
      bufferCommands: false,
    });

    // Store the connection
    globalWithMongoose.mongooseConnection = mongooseInstance;

    // Handle cleanup on app termination
    process.on('beforeExit', async () => {
      if (globalWithMongoose.mongooseConnection) {
        await globalWithMongoose.mongooseConnection.disconnect();
        globalWithMongoose.mongooseConnection = null;
      }
    });

    return mongooseInstance;
  } catch (error) {
    console.error('Error connecting to MongoDB:', error);
    throw error;
  }
}

export default connectDB;
</file>

<file path="src/lib/passport.ts">
import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import { User } from '../models/User';
import bcrypt from 'bcryptjs';
import { IUserDocument } from '../models/User';

// Configure Local Strategy
passport.use(
  new LocalStrategy(
    {
      usernameField: 'email',
      passwordField: 'password',
    },
    async (
      email: string,
      password: string,

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      done: (error: any, user?: any, options?: { message: string }) => void
    ) => {
      try {
        const user = await User.findOne({ email });
        if (!user) {
          return done(null, false, { message: 'Invalid email or password' });
        }
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
          return done(null, false, { message: 'Invalid email or password' });
        }
        return done(null, user);
      } catch (err) {
        return done(err);
      }
    }
  )
);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
passport.serializeUser((user: IUserDocument, done: (err: any, id?: string) => void) => {
  done(null, user._id.toString());
});

passport.deserializeUser(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async (id: string, done: (err: any, user?: IUserDocument | false) => void) => {
    try {
      const user = await User.findById(id);
      if (!user) {
        return done(new Error('User not found'));
      }
      done(null, user);
    } catch (err) {
      done(err);
    }
  }
);

export default passport;
</file>

<file path="src/lib/session.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import session from 'express-session';
import MongoStore from 'connect-mongo';
import passport from './passport';
import { IUserDocument } from '../models/User';
import { Request, Response, NextFunction } from 'express';

// Extend NextApiRequest to include session
declare module 'next' {
  interface NextApiRequest {
    session: session.Session & {
      user?: IUserDocument;
    };
  }
}

// Create session configuration
const sessionConfig = session({
  secret: process.env.SESSION_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URI,
    dbName: 'french-idol',
    ttl: 30 * 24 * 60 * 60, // 30 days
  }),
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
  },
});

type NextApiHandler = (req: NextApiRequest, res: NextApiResponse) => Promise<void>;

// Create middleware wrapper for Next.js API routes
const withSession = (handler: NextApiHandler) => {
  return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {
    try {
      await new Promise<void>((resolve, reject) => {
        const expressReq = req as unknown as Request;
        const expressRes = res as unknown as Response;
        const next: NextFunction = err => (err ? reject(err) : resolve());

        sessionConfig(expressReq, expressRes, err => {
          if (err) return next(err);
          passport.initialize()(expressReq, expressRes, err => {
            if (err) return next(err);
            passport.session()(expressReq, expressRes, next);
          });
        });
      });

      return handler(req, res);
    } catch (error) {
      console.error('Session middleware error:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  };
};

export default withSession;
</file>

<file path="src/models/Answer.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { Answer as AnswerType } from '../types/answer';

/**
 * Interface for the Answer document in MongoDB
 */
export interface IAnswerDocument extends Document {
  _id: mongoose.Types.ObjectId;
  userEmail: string;
  storyId: mongoose.Types.ObjectId;
  question: string;
  answer: string;
  score: number;
  correction: string;
  suggestedAnswer: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * Mongoose schema definition for Answer
 */
const answerSchema = new Schema<IAnswerDocument>(
  {
    userEmail: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    storyId: {
      type: Schema.Types.ObjectId,
      required: true,
      ref: 'french-idol.Story',
    },
    question: {
      type: String,
      required: true,
    },
    answer: {
      type: String,
      required: true,
    },
    score: {
      type: Number,
      required: true,
      min: 0,
      max: 100,
    },
    correction: {
      type: String,
      required: true,
    },
    suggestedAnswer: {
      type: String,
      required: true,
    },
    createdAt: {
      type: String,
      required: true,
    },
    updatedAt: {
      type: String,
      required: true,
    },
  },
  {
    collection: 'Answer', // Explicitly set collection name
  }
);

// Model name for caching
const MODEL_NAME = 'french-idol.Answer';

// Create and export the model
// Using type assertion since the model might not exist yet in Next.js hot reloading
export const Answer =
  (mongoose.models[MODEL_NAME] as mongoose.Model<IAnswerDocument>) ||
  mongoose.model<IAnswerDocument>(MODEL_NAME, answerSchema);

// Utility function to transform MongoDB document to frontend type
export function mapAnswerToDTO(answer: IAnswerDocument): AnswerType {
  return {
    id: answer._id.toString(),
    userEmail: answer.userEmail,
    storyId: answer.storyId.toString(),
    question: answer.question,
    answer: answer.answer,
    score: answer.score,
    correction: answer.correction,
    suggestedAnswer: answer.suggestedAnswer,
    createdAt: answer.createdAt,
    updatedAt: answer.updatedAt,
  };
}
</file>

<file path="src/models/GradeLevel.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { GradeLevel as GradeLevelType } from '../types/gradeLevel';

/**
 * Interface for the GradeLevel document in MongoDB
 */
export interface IGradeLevelDocument extends Document {
  _id: mongoose.Types.ObjectId;
  grade: number;
  levelName: string;
  averageAge: number;
  numberOfQuestions: number;
  instructions: string;
  storyWordCount: number;
}

/**
 * Mongoose schema definition for GradeLevel
 */
const gradeLevelSchema = new Schema<IGradeLevelDocument>(
  {
    grade: {
      type: Number,
      required: true,
    },
    levelName: {
      type: String,
      required: true,
      trim: true,
    },
    averageAge: {
      type: Number,
      required: true,
    },
    numberOfQuestions: {
      type: Number,
      required: true,
    },
    instructions: {
      type: String,
      required: true,
      trim: true,
    },
    storyWordCount: {
      type: Number,
      required: true,
    },
  },
  {
    collection: 'GradeLevel', // Explicitly set collection name
  }
);

// Model name for caching
const MODEL_NAME = 'french-idol.GradeLevel';

// Create and export the model
export const GradeLevel =
  (mongoose.models[MODEL_NAME] as mongoose.Model<IGradeLevelDocument>) ||
  mongoose.model<IGradeLevelDocument>(MODEL_NAME, gradeLevelSchema);

// Utility function to transform MongoDB document to frontend type
export function mapGradeLevelToDTO(gradeLevel: IGradeLevelDocument): GradeLevelType {
  return {
    id: gradeLevel._id.toString(),
    grade: gradeLevel.grade,
    levelName: gradeLevel.levelName,
    averageAge: gradeLevel.averageAge,
    numberOfQuestions: gradeLevel.numberOfQuestions,
    instructions: gradeLevel.instructions,
    storyWordCount: gradeLevel.storyWordCount,
  };
}
</file>

<file path="src/models/Story.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { Story as StoryType } from '../types/story';

/**
 * Interface for the Story document in MongoDB
 */
export interface IStoryDocument extends Document {
  _id: mongoose.Types.ObjectId;
  userEmail: string;
  sourceText: string;
  title: string;
  article: string;
  read: boolean;
  quizScore: number | null;
  totalQuestions: number | null;
  questionResponses: string[] | null;
  questionCorrections: string[] | null;
  questions: string[] | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * Mongoose schema definition for Story
 */
const storySchema = new Schema<IStoryDocument>(
  {
    userEmail: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    sourceText: {
      type: String,
      required: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
    },
    article: {
      type: String,
      required: true,
    },
    read: {
      type: Boolean,
      required: true,
      default: false,
    },
    quizScore: {
      type: Number,
      required: false,
      default: null,
    },
    totalQuestions: {
      type: Number,
      required: false,
      default: null,
    },
    questionResponses: {
      type: [String],
      required: false,
      default: null,
    },
    questionCorrections: {
      type: [String],
      required: false,
      default: null,
    },
    questions: {
      type: [String],
      required: false,
      default: null,
    },
    createdAt: {
      type: String,
      required: true,
    },
    updatedAt: {
      type: String,
      required: true,
    },
  },
  {
    collection: 'Story', // Explicitly set collection name
  }
);

// Model name for caching
const MODEL_NAME = 'french-idol.Story';

// Create and export the model
// Using type assertion since the model might not exist yet in Next.js hot reloading
export const Story =
  (mongoose.models[MODEL_NAME] as mongoose.Model<IStoryDocument>) ||
  mongoose.model<IStoryDocument>(MODEL_NAME, storySchema);

// Utility function to transform MongoDB document to frontend type
export function mapStoryToDTO(story: IStoryDocument): StoryType {
  return {
    id: story._id.toString(),
    userEmail: story.userEmail,
    sourceText: story.sourceText,
    title: story.title,
    article: story.article,
    read: story.read,
    quizScore: story.quizScore,
    totalQuestions: story.totalQuestions,
    questionResponses: story.questionResponses,
    questionCorrections: story.questionCorrections,
    questions: story.questions,
    createdAt: story.createdAt,
    updatedAt: story.updatedAt,
  };
}
</file>

<file path="src/models/User.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { User as UserType } from '../types/user';

/**
 * Interface for the User document in MongoDB
 */
export interface IUserDocument extends Document {
  _id: mongoose.Types.ObjectId;
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  createdAt: string; // Changed to string to match DB
  updatedAt: string; // Changed to string to match DB
}

/**
 * Mongoose schema definition for User
 */
const userSchema = new Schema<IUserDocument>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
    },
    firstName: {
      type: String,
      required: true,
      trim: true,
    },
    lastName: {
      type: String,
      required: true,
      trim: true,
    },
    createdAt: {
      type: String,
      required: true,
    },
    updatedAt: {
      type: String,
      required: true,
    },
  },
  {
    collection: 'User', // Explicitly set collection name
  }
);

// Model name for caching
const MODEL_NAME = 'french-idol.User';

// Create and export the model
// Using type assertion since the model might not exist yet in Next.js hot reloading
export const User =
  (mongoose.models[MODEL_NAME] as mongoose.Model<IUserDocument>) ||
  mongoose.model<IUserDocument>(MODEL_NAME, userSchema);

// Utility function to transform MongoDB document to frontend type
export function mapUserToDTO(user: IUserDocument): UserType {
  return {
    id: user._id.toString(),
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
    createdAt: user.createdAt, // Already a string
    updatedAt: user.updatedAt, // Already a string
  };
}
</file>

<file path="src/pages/api/__mocks__/openai.ts">
import { vi } from 'vitest';

const mockCreate = vi.fn();

interface OpenAIInstance {
  chat: {
    completions: {
      create: typeof mockCreate;
    };
  };
}

function OpenAI(this: OpenAIInstance) {
  this.chat = {
    completions: {
      create: mockCreate,
    },
  };
  return this;
}

export { mockCreate };
export default OpenAI as unknown as typeof import('openai').default;
</file>

<file path="src/pages/api/__tests__/grade-levels/index.test.ts">
import { vi } from 'vitest';
import type { NextApiRequest, NextApiResponse } from 'next';
import { describe, it, expect, beforeEach } from 'vitest';
import mongoose from 'mongoose';
import handler from '../../grade-levels';
import { GradeLevel } from '../../../../models/GradeLevel';
import { GradeLevelsResponse } from '../../../../types/gradeLevel';

// Mock MongoDB connection
vi.mock('../../../../lib/mongodb', () => ({
  __esModule: true,
  default: vi.fn().mockResolvedValue(mongoose),
}));

describe('Grade Levels API', () => {
  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse<GradeLevelsResponse>>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
  });

  it('returns 405 for non-GET methods', async () => {
    mockReq = {
      method: 'POST',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({
      error: 'Method not allowed',
    });
  });

  it('returns grade levels successfully', async () => {
    const mockGradeLevels = [
      {
        _id: new mongoose.Types.ObjectId(),
        grade: 1,
        levelName: 'Beginner',
        averageAge: 6,
        numberOfQuestions: 5,
        instructions: 'Simple questions for beginners',
        storyWordCount: 100,
        toObject: () => ({
          _id: new mongoose.Types.ObjectId(),
          grade: 1,
          levelName: 'Beginner',
          averageAge: 6,
          numberOfQuestions: 5,
          instructions: 'Simple questions for beginners',
          storyWordCount: 100,
        }),
      },
      {
        _id: new mongoose.Types.ObjectId(),
        grade: 2,
        levelName: 'Elementary',
        averageAge: 7,
        numberOfQuestions: 8,
        instructions: 'Basic comprehension questions',
        storyWordCount: 150,
        toObject: () => ({
          _id: new mongoose.Types.ObjectId(),
          grade: 2,
          levelName: 'Elementary',
          averageAge: 7,
          numberOfQuestions: 8,
          instructions: 'Basic comprehension questions',
          storyWordCount: 150,
        }),
      },
    ];

    // Mock the find method
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    vi.spyOn(GradeLevel, 'find').mockResolvedValueOnce(mockGradeLevels as any);

    mockReq = {
      method: 'GET',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(200);
    const data = jsonMock.mock.calls[0][0] as GradeLevelsResponse;
    expect(data.gradeLevels).toHaveLength(2);
    expect(data.gradeLevels[0]).toEqual({
      id: mockGradeLevels[0]._id.toString(),
      grade: mockGradeLevels[0].grade,
      levelName: mockGradeLevels[0].levelName,
      averageAge: mockGradeLevels[0].averageAge,
      numberOfQuestions: mockGradeLevels[0].numberOfQuestions,
      instructions: mockGradeLevels[0].instructions,
      storyWordCount: mockGradeLevels[0].storyWordCount,
    });
  });

  it('handles errors appropriately', async () => {
    // Mock the find method to throw an error
    vi.spyOn(GradeLevel, 'find').mockRejectedValueOnce(new Error('Database error'));

    mockReq = {
      method: 'GET',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: 'Failed to fetch grade levels',
    });
  });
});
</file>

<file path="src/pages/api/__tests__/stories/getStoryAnswers.test.ts">
import { vi, describe, it, expect, beforeEach } from 'vitest';
import type { NextApiRequest, NextApiResponse } from 'next';
import handler from '../../stories/getStoryAnswers';
import { answerService } from '../../../../services/answerService';
import { Answer } from '../../../../types/answer';

vi.mock('../../../../services/answerService', () => ({
  answerService: {
    getUserAnswersForStory: vi.fn(),
  },
}));

describe('getStoryAnswers API', () => {
  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  const mockAnswers: Answer[] = [
    {
      id: '1',
      userEmail: 'test@example.com',
      storyId: 'story123',
      question: 'Test question?',
      answer: 'Test answer',
      score: 80,
      correction: 'Good answer',
      createdAt: '2025-01-30T00:00:00.000Z',
      updatedAt: '2025-01-30T00:00:00.000Z',
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
  });

  it('returns 405 for non-GET requests', async () => {
    mockReq = {
      method: 'POST',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({
      message: 'Method not allowed',
    });
  });

  it('returns 400 if storyId is missing', async () => {
    mockReq = {
      method: 'GET',
      query: {
        email: 'test@example.com',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      message: 'Story ID is required',
    });
  });

  it('returns 400 if email is missing', async () => {
    mockReq = {
      method: 'GET',
      query: {
        storyId: 'story123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      message: 'Email is required',
    });
  });

  it('returns 404 if no answers are found', async () => {
    mockReq = {
      method: 'GET',
      query: {
        storyId: 'story123',
        email: 'test@example.com',
      },
    };

    (answerService.getUserAnswersForStory as ReturnType<typeof vi.fn>).mockResolvedValue([]);

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(404);
    expect(jsonMock).toHaveBeenCalledWith({
      message: 'No answers found for this story',
    });
  });

  it('returns 200 with answers when found', async () => {
    mockReq = {
      method: 'GET',
      query: {
        storyId: 'story123',
        email: 'test@example.com',
      },
    };

    (answerService.getUserAnswersForStory as ReturnType<typeof vi.fn>).mockResolvedValue(
      mockAnswers
    );

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(200);
    expect(jsonMock).toHaveBeenCalledWith({
      answers: [
        {
          id: '1',
          question: 'Test question?',
          answer: 'Test answer',
          score: 80,
          correction: 'Good answer',
        },
      ],
    });
  });

  it('returns 500 when service throws error', async () => {
    mockReq = {
      method: 'GET',
      query: {
        storyId: 'story123',
        email: 'test@example.com',
      },
    };

    (answerService.getUserAnswersForStory as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Database error')
    );

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      message: 'Error fetching story answers',
    });
  });
});
</file>

<file path="src/pages/api/__tests__/stories/list.test.ts">
import { vi } from 'vitest';
import type { NextApiRequest, NextApiResponse } from 'next';
import { describe, it, expect, beforeEach } from 'vitest';
import handler from '../../stories/list';
import { ListStoriesResponse } from '../../../../types/api/listStories';
import { Story } from '../../../../types/story';

// Mock the story service
vi.mock('../../../../services/storyService', () => ({
  storyService: {
    getUserStories: vi.fn(),
  },
}));

import { storyService } from '../../../../services/storyService';

describe('Stories List API', () => {
  const mockStories: Story[] = [
    {
      id: '1',
      userEmail: 'test@example.com',
      sourceText: 'source',
      title: 'Test Story',
      article: 'content',
      read: false,
      createdAt: '2024-01-29T00:00:00.000Z',
      updatedAt: '2024-01-29T00:00:00.000Z',
    },
  ];

  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse<ListStoriesResponse | { error: string }>>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
  });

  it('should return stories for valid email and read status', async () => {
    mockReq = {
      method: 'GET',
      query: {
        email: 'test@example.com',
        read: 'false',
      },
    };

    vi.mocked(storyService.getUserStories).mockResolvedValueOnce(mockStories);

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(200);
    expect(jsonMock).toHaveBeenCalledWith({ stories: mockStories });
    expect(storyService.getUserStories).toHaveBeenCalledWith('test@example.com', false);
  });

  it('should default to unread stories when read status is not provided', async () => {
    mockReq = {
      method: 'GET',
      query: {
        email: 'test@example.com',
      },
    };

    vi.mocked(storyService.getUserStories).mockResolvedValueOnce(mockStories);

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(200);
    expect(storyService.getUserStories).toHaveBeenCalledWith('test@example.com', false);
  });

  it('should return 400 when email is missing', async () => {
    mockReq = {
      method: 'GET',
      query: {
        read: 'false',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({ error: 'Email is required' });
  });

  it('should return 400 for invalid read status', async () => {
    mockReq = {
      method: 'GET',
      query: {
        email: 'test@example.com',
        read: 'invalid',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({ error: 'Invalid read status value' });
  });

  it('should return 405 for non-GET requests', async () => {
    mockReq = {
      method: 'POST',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({ error: 'Method not allowed' });
  });

  it('should return 500 when service throws error', async () => {
    mockReq = {
      method: 'GET',
      query: {
        email: 'test@example.com',
        read: 'false',
      },
    };

    vi.mocked(storyService.getUserStories).mockRejectedValueOnce(new Error('Database error'));

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({ error: 'Internal server error' });
  });
});
</file>

<file path="src/pages/api/__tests__/generateQuestions.test.ts">
import { vi } from 'vitest';

// Mock modules before imports
vi.mock('openai', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate,
        },
      },
    })),
  };
});

// Mock process.env
const processEnv = process.env;
vi.spyOn(process, 'env', 'get').mockReturnValue({
  ...processEnv,
  OPENAI_API_KEY: 'test-key',
});

import type { NextApiRequest, NextApiResponse } from 'next';
import { describe, it, expect, beforeEach } from 'vitest';
import { GenerateQuestionsApiResponse } from '../../../types/api/generateQuestions';
import { mockCreate } from '../../../test/mocks/openai';
import handler from '../generateQuestions';

describe('generateQuestions API', () => {
  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse<GenerateQuestionsApiResponse>>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
  });

  it('returns 405 for non-POST requests', async () => {
    mockReq = {
      method: 'GET',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  });

  it('returns 400 if story is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {},
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if story is not a string', async () => {
    mockReq = {
      method: 'POST',
      body: { story: 123 },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('successfully generates questions', async () => {
    const mockQuestions = {
      questions: ['Question 1 en français?', 'Question 2 en français?', 'Question 3 en français?'],
    };

    mockCreate.mockResolvedValueOnce({
      choices: [
        {
          message: {
            content: JSON.stringify(mockQuestions),
          },
        },
      ],
    });

    mockReq = {
      method: 'POST',
      body: { story: 'Test story content' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(200);
    expect(jsonMock).toHaveBeenCalledWith(mockQuestions);
  });

  it('handles OpenAI API errors', async () => {
    mockCreate.mockRejectedValueOnce(new Error('API Error'));

    mockReq = {
      method: 'POST',
      body: { story: 'Test story content' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to generate questions',
        code: 'OPENAI_ERROR',
      },
    });
  });

  it('handles invalid JSON response from OpenAI', async () => {
    mockCreate.mockResolvedValueOnce({
      choices: [
        {
          message: {
            content: 'Invalid JSON response',
          },
        },
      ],
    });

    mockReq = {
      method: 'POST',
      body: { story: 'Test story content' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to parse generated questions',
        code: 'PARSE_ERROR',
      },
    });
  });
});
</file>

<file path="src/pages/api/__tests__/generateStory.test.ts">
import { vi } from 'vitest';

// Mock modules before imports
vi.mock('openai');
vi.mock('../../../services/storyService', () => ({
  storyService: {
    saveStory: vi.fn().mockImplementation((email, title, sourceText, article) => ({
      id: 'test-id',
      userEmail: email,
      title,
      sourceText,
      article,
      read: false,
      createdAt: '2025-01-29T00:00:00.000Z',
      updatedAt: '2025-01-29T00:00:00.000Z',
    })),
  },
}));

// Mock process.env
const processEnv = process.env;
vi.spyOn(process, 'env', 'get').mockReturnValue({
  ...processEnv,
  OPENAI_API_KEY: 'test-key',
});

import type { NextApiRequest, NextApiResponse } from 'next';
import { describe, it, expect, beforeEach } from 'vitest';
import { GenerateStoryApiResponse } from '../../../types/api/generateStory';
import { mockCreate } from '../__mocks__/openai';
import handler from '../generateStory';

describe('generateStory API', () => {
  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse<GenerateStoryApiResponse>>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
  });

  it('returns 405 for non-POST requests', async () => {
    mockReq = {
      method: 'GET',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  });

  it('returns 400 when text is missing', async () => {
    mockReq = {
      method: 'POST',
      body: { email: 'test@example.com' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Text field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 when text is not a string', async () => {
    mockReq = {
      method: 'POST',
      body: { text: 123, email: 'test@example.com' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Text field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 when email is missing', async () => {
    mockReq = {
      method: 'POST',
      body: { text: 'test story' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Email field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 when email is not a string', async () => {
    mockReq = {
      method: 'POST',
      body: { text: 'test story', email: 123 },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Email field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('handles OpenAI API errors', async () => {
    mockCreate.mockRejectedValueOnce(new Error('API Error'));

    mockReq = {
      method: 'POST',
      body: { text: 'Generate a story about a dragon', email: 'test@example.com' },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to generate story',
        code: 'OPENAI_ERROR',
      },
    });
  });
});
</file>

<file path="src/pages/api/__tests__/getByEmail.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { createMocks } from 'node-mocks-http';
import handler from '../users/getByEmail';
import { userService } from '../../../services/userService';
import { User } from '../../../types/user';

vi.mock('../../../services/userService', () => ({
  userService: {
    getUserByEmail: vi.fn(),
  },
}));

describe('GET /api/users/getByEmail', () => {
  const mockUser: User = {
    id: '507f1f77bcf86cd799439011',
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  it('should return 405 for non-GET requests', async () => {
    const { req, res } = createMocks({
      method: 'POST',
    });

    await handler(req, res);

    expect(res._getStatusCode()).toBe(405);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'Method not allowed',
    });
  });

  it('should return 400 if email is missing', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: {},
    });

    await handler(req, res);

    expect(res._getStatusCode()).toBe(400);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'Email parameter is required',
    });
  });

  it('should return 200 and user data when found', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { email: 'test@example.com' },
    });

    vi.mocked(userService.getUserByEmail).mockResolvedValueOnce(mockUser);

    await handler(req, res);

    expect(userService.getUserByEmail).toHaveBeenCalledWith('test@example.com');
    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({ user: mockUser });
  });

  it('should return 404 when user is not found', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { email: 'nonexistent@example.com' },
    });

    vi.mocked(userService.getUserByEmail).mockRejectedValueOnce(
      new Error('User not found with email: nonexistent@example.com')
    );

    await handler(req, res);

    expect(userService.getUserByEmail).toHaveBeenCalledWith('nonexistent@example.com');
    expect(res._getStatusCode()).toBe(404);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'User not found with email: nonexistent@example.com',
    });
  });
});
</file>

<file path="src/pages/api/__tests__/list.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { createMocks } from 'node-mocks-http';
import handler from '../users/list';
import { userService } from '../../../services/userService';
import { User } from '../../../types/user';

vi.mock('../../../services/userService', () => ({
  userService: {
    getAllUsers: vi.fn(),
  },
}));

describe('GET /api/users/list', () => {
  const mockUsers: User[] = [
    {
      id: '507f1f77bcf86cd799439011',
      email: 'test1@example.com',
      firstName: 'John',
      lastName: 'Doe',
      createdAt: '2024-01-29T12:00:00.000Z',
      updatedAt: '2024-01-29T12:00:00.000Z',
    },
    {
      id: '507f1f77bcf86cd799439012',
      email: 'test2@example.com',
      firstName: 'Jane',
      lastName: 'Smith',
      createdAt: '2024-01-29T12:00:00.000Z',
      updatedAt: '2024-01-29T12:00:00.000Z',
    },
  ];

  it('should return 405 for non-GET requests', async () => {
    const { req, res } = createMocks({
      method: 'POST',
    });

    await handler(req, res);

    expect(res._getStatusCode()).toBe(405);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'Method not allowed',
    });
  });

  it('should return 200 and users list when successful', async () => {
    const { req, res } = createMocks({
      method: 'GET',
    });

    vi.mocked(userService.getAllUsers).mockResolvedValueOnce(mockUsers);

    await handler(req, res);

    expect(userService.getAllUsers).toHaveBeenCalled();
    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({ users: mockUsers });
  });

  it('should return 500 when service throws error', async () => {
    const { req, res } = createMocks({
      method: 'GET',
    });

    const error = new Error('Database connection failed');
    vi.mocked(userService.getAllUsers).mockRejectedValueOnce(error);

    await handler(req, res);

    expect(userService.getAllUsers).toHaveBeenCalled();
    expect(res._getStatusCode()).toBe(500);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'Database connection failed',
    });
  });

  it('should return empty array when no users exist', async () => {
    const { req, res } = createMocks({
      method: 'GET',
    });

    vi.mocked(userService.getAllUsers).mockResolvedValueOnce([]);

    await handler(req, res);

    expect(userService.getAllUsers).toHaveBeenCalled();
    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({ users: [] });
  });
});
</file>

<file path="src/pages/api/__tests__/validateResponse.test.ts">
import { vi } from 'vitest';

// Mock modules before imports
vi.mock('openai', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate,
        },
      },
    })),
  };
});

vi.mock('../../../services/answerService', () => ({
  answerService: {
    saveAnswer: vi.fn(),
  },
}));

// Mock process.env
const processEnv = process.env;
vi.spyOn(process, 'env', 'get').mockReturnValue({
  ...processEnv,
  OPENAI_API_KEY: 'test-key',
});

import type { NextApiRequest, NextApiResponse } from 'next';
import { describe, it, expect, beforeEach } from 'vitest';
import { ValidateResponseApiResponse } from '../../../types/api/validateResponse';
import { mockCreate } from '../../../test/mocks/openai';
import { answerService } from '../../../services/answerService';
import handler from '../validateResponse';

describe('validateResponse API', () => {
  let mockReq: Partial<NextApiRequest>;
  let mockRes: Partial<NextApiResponse<ValidateResponseApiResponse>>;
  let jsonMock: ReturnType<typeof vi.fn>;
  let statusMock: ReturnType<typeof vi.fn>;

  const mockAnswer = {
    id: 'test-id',
    userEmail: 'test@example.com',
    storyId: 'story-123',
    question: 'test question',
    answer: 'test response',
    score: 4.5,
    correction: 'Excellent travail!',
    suggestedAnswer: 'La réponse modèle ici.',
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  beforeEach(() => {
    vi.clearAllMocks();
    jsonMock = vi.fn();
    statusMock = vi.fn().mockReturnValue({ json: jsonMock });
    mockRes = {
      status: statusMock,
      json: jsonMock,
    };
    (answerService.saveAnswer as ReturnType<typeof vi.fn>).mockResolvedValue(mockAnswer);

    // Setup default successful OpenAI responses
    mockCreate
      // First call - student evaluation
      .mockResolvedValueOnce({
        choices: [
          {
            message: {
              content: JSON.stringify({
                score: 4.5,
                correction: 'Excellent travail!',
                suggestedAnswer: 'La réponse modèle ici.',
              }),
            },
          },
        ],
      })
      // Second call - teacher review
      .mockResolvedValueOnce({
        choices: [
          {
            message: {
              content: JSON.stringify({
                isScoreAccurate: true,
                finalScore: 4.5,
                finalCorrection: 'Excellent travail!',
                reviewComments: 'Score is accurate.',
              }),
            },
          },
        ],
      });
  });

  it('returns 405 for non-POST requests', async () => {
    mockReq = {
      method: 'GET',
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(405);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  });

  it('returns 400 if story is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if story is not a string', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 123,
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if question is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Question field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if response is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Response field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if userEmail is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'User email is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('returns 400 if storyId is missing', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(400);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Story ID is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  });

  it('successfully validates response and saves answer', async () => {
    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(answerService.saveAnswer).toHaveBeenCalledWith(
      'test@example.com',
      'story-123',
      'test question',
      'test response',
      4.5,
      'Excellent travail!',
      'La réponse modèle ici.'
    );

    expect(statusMock).toHaveBeenCalledWith(200);
    expect(jsonMock).toHaveBeenCalledWith({
      score: 4.5,
      correction: 'Excellent travail!',
      suggestedAnswer: 'La réponse modèle ici.',
      reviewComments: 'Score is accurate.',
      savedAnswer: mockAnswer,
    });
  });

  it('handles database error when saving answer', async () => {
    (answerService.saveAnswer as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
      new Error('Database error')
    );

    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to save answer to database',
        code: 'DATABASE_ERROR',
      },
    });
  });

  it('handles invalid response format from OpenAI', async () => {
    mockCreate.mockReset().mockResolvedValueOnce({
      choices: [
        {
          message: {
            content: 'invalid json',
          },
        },
      ],
    });

    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to parse validation response',
        code: 'PARSE_ERROR',
      },
    });
  });

  it('handles OpenAI API errors', async () => {
    mockCreate.mockReset().mockRejectedValueOnce(new Error('API Error'));

    mockReq = {
      method: 'POST',
      body: {
        story: 'test story',
        question: 'test question',
        response: 'test response',
        userEmail: 'test@example.com',
        storyId: 'story-123',
      },
    };

    await handler(mockReq as NextApiRequest, mockRes as NextApiResponse);

    expect(statusMock).toHaveBeenCalledWith(500);
    expect(jsonMock).toHaveBeenCalledWith({
      error: {
        message: 'Failed to validate response',
        code: 'OPENAI_ERROR',
      },
    });
  });
});
</file>

<file path="src/pages/api/grade-levels/index.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import connectDB from '../../../lib/mongodb';
import { GradeLevel, mapGradeLevelToDTO } from '../../../models/GradeLevel';
import { GradeLevelsResponse } from '../../../types/gradeLevel';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GradeLevelsResponse | { error: string }>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    await connectDB();

    const gradeLevels = await GradeLevel.find({});

    return res.status(200).json({
      gradeLevels: gradeLevels.map(mapGradeLevelToDTO),
    });
  } catch (error) {
    console.error('Error fetching grade levels:', error);
    return res.status(500).json({ error: 'Failed to fetch grade levels' });
  }
}
</file>

<file path="src/pages/api/stories/getReadStories.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { Story } from '../../../models/Story';
import connectDB from '../../../lib/mongodb';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { email } = req.query;

    if (!email || typeof email !== 'string') {
      return res.status(400).json({ message: 'Email is required' });
    }

    await connectDB();

    const stories = await Story.find({
      userEmail: email.toLowerCase(),
      read: true,
    });

    res.status(200).json({
      stories: stories.map(story => ({
        id: story._id.toString(),
        userEmail: story.userEmail,
        sourceText: story.sourceText,
        title: story.title,
        article: story.article,
        read: story.read,
        quizScore: story.quizScore,
        totalQuestions: story.totalQuestions,
        questions: story.questions,
        questionResponses: story.questionResponses,
        questionCorrections: story.questionCorrections,
        createdAt: story.createdAt,
        updatedAt: story.updatedAt,
      })),
    });
  } catch (error) {
    console.error('Error fetching read stories:', error);
    res.status(500).json({ message: 'Error fetching read stories' });
  }
}
</file>

<file path="src/pages/api/stories/getStoryAnswers.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { answerService } from '../../../services/answerService';
import { GetStoryAnswersResponse, GetStoryAnswersError } from '../../../types/api/getStoryAnswers';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GetStoryAnswersResponse | GetStoryAnswersError>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { storyId, email } = req.query;

    if (!storyId || typeof storyId !== 'string') {
      return res.status(400).json({ message: 'Story ID is required' });
    }

    if (!email || typeof email !== 'string') {
      return res.status(400).json({ message: 'Email is required' });
    }

    const answers = await answerService.getUserAnswersForStory(email, storyId);

    if (answers.length === 0) {
      return res.status(404).json({ message: 'No answers found for this story' });
    }

    res.status(200).json({
      answers: answers.map(answer => ({
        id: answer.id,
        question: answer.question,
        answer: answer.answer,
        score: answer.score,
        correction: answer.correction,
      })),
    });
  } catch (error) {
    console.error('Error fetching story answers:', error);
    res.status(500).json({ message: 'Error fetching story answers' });
  }
}
</file>

<file path="src/pages/api/stories/list.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { storyService } from '../../../services/storyService';
import { ListStoriesResponse } from '../../../types/api/listStories';

/**
 * API endpoint to list stories for a user filtered by read status
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ListStoriesResponse | { error: string }>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { email, read } = req.query;

    if (!email || typeof email !== 'string') {
      return res.status(400).json({ error: 'Email is required' });
    }

    // Validate and convert read query param to boolean if provided
    let readStatus: boolean | undefined;
    if (read !== undefined) {
      if (read !== 'true' && read !== 'false') {
        return res.status(400).json({ error: 'Invalid read status value' });
      }
      readStatus = read === 'true';
    }

    const stories = await storyService.getUserStories(email, readStatus ?? false);

    return res.status(200).json({ stories });
  } catch (error) {
    console.error('Error fetching stories:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}
</file>

<file path="src/pages/api/stories/markRead.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { storyService } from '../../../services/storyService';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const {
      email,
      storyId,
      quizScore,
      totalQuestions,
      questions,
      questionResponses,
      questionCorrections,
    } = req.body;

    if (!email || !storyId || typeof quizScore !== 'number' || typeof totalQuestions !== 'number') {
      return res.status(400).json({ message: 'Missing required fields' });
    }

    const updatedStory = await storyService.markStoryRead(
      email,
      storyId,
      quizScore,
      totalQuestions,
      questions,
      questionResponses,
      questionCorrections
    );
    res.status(200).json(updatedStory);
  } catch (error) {
    console.error('Error marking story as read:', error);
    res.status(500).json({ message: 'Error marking story as read' });
  }
}
</file>

<file path="src/pages/api/users/getByEmail.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { userService } from '../../../services/userService';
import { GetUserResponse } from '../../../types/user';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GetUserResponse | { error: string }>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const email = req.query.email;

  if (!email || typeof email !== 'string') {
    return res.status(400).json({ error: 'Email parameter is required' });
  }

  try {
    const user = await userService.getUserByEmail(email);
    return res.status(200).json({ user });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Internal server error';
    return res.status(404).json({ error: message });
  }
}
</file>

<file path="src/pages/api/users/list.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { userService } from '../../../services/userService';
import { User } from '../../../types/user';

/**
 * GET /api/users/list
 * Returns a list of all users in the system
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<{ users: User[] } | { error: string }>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const users = await userService.getAllUsers();
    return res.status(200).json({ users });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Internal server error';
    return res.status(500).json({ error: message });
  }
}
</file>

<file path="src/pages/api/users/updateProfile.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { userService } from '../../../services/userService';
import { UpdateUserResponse } from '../../../types/user';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<UpdateUserResponse | { error: string }>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { email, firstName, lastName } = req.body;

  if (!email || typeof email !== 'string') {
    return res.status(400).json({ error: 'Email is required' });
  }

  if (!firstName || typeof firstName !== 'string') {
    return res.status(400).json({ error: 'First name is required' });
  }

  if (!lastName || typeof lastName !== 'string') {
    return res.status(400).json({ error: 'Last name is required' });
  }

  try {
    const user = await userService.updateUser(email, { firstName, lastName });
    return res.status(200).json({ user });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Internal server error';
    return res.status(404).json({ error: message });
  }
}
</file>

<file path="src/pages/api/generateQuestions.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import OpenAI from 'openai';
import { GenerateQuestionsApiResponse } from '../../types/api/generateQuestions';

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || 'test-key';

const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

const GENERATE_QUESTIONS_SYSTEM_PROMPT = `You are a French language teacher creating quiz questions for 10-year-old students. Your task is to generate 3-5 questions based on the provided story.

IMPORTANT:
1. Questions must be in French
2. Questions must be based on information present in the story
3. Questions should be appropriate for a 10-year-old's comprehension level
4. Questions should test understanding of the story content
5. Questions should vary in difficulty

Output format:
{
  "questions": [
    "Question 1 in French",
    "Question 2 in French",
    "Question 3 in French"
  ]
}`;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GenerateQuestionsApiResponse>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  }

  const { story } = req.body;

  if (!story || typeof story !== 'string') {
    return res.status(400).json({
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  }

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: GENERATE_QUESTIONS_SYSTEM_PROMPT,
        },
        {
          role: 'user',
          content: story,
        },
      ],
      temperature: 0.7,
      max_tokens: 1000,
    });

    const response = completion.choices[0]?.message?.content;

    if (!response) {
      return res.status(500).json({
        error: {
          message: 'Failed to generate questions',
          code: 'GENERATION_FAILED',
        },
      });
    }

    try {
      const parsedResponse = JSON.parse(response);
      if (!Array.isArray(parsedResponse.questions)) {
        throw new Error('Invalid response format');
      }

      return res.status(200).json({ questions: parsedResponse.questions });
    } catch (parseError) {
      return res.status(500).json({
        error: {
          message: 'Failed to parse generated questions',
          code: 'PARSE_ERROR',
        },
      });
    }
  } catch (error) {
    console.error('Error generating questions:', error);
    return res.status(500).json({
      error: {
        message: 'Failed to generate questions',
        code: 'OPENAI_ERROR',
      },
    });
  }
}
</file>

<file path="src/pages/api/generateStory.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import OpenAI from 'openai';
import { GenerateStoryApiResponse } from '../../types/api/generateStory';
import promptExamples from './generateStoryPrompt.json';
import { storyService } from '../../services/storyService';

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || 'test-key';

const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
});

const buildSystemPrompt = () => {
  const basePrompt = `You are a french children news author. Your task is to generate short articles base on given text.
The following are examples of text that are appropriate for children.
Examples:
`;

  const examples = promptExamples.articles
    .map(
      article => `Title: ${article.title}
Content: ${article.content}
`
    )
    .join('\n');

  return `${basePrompt}${examples}

  Output:
  {
    "title":"Article title.  Should be less than 10 words",
    "article":"Article content.  Should be less than 300 words"
  }
IMPORTANT:
1. The articles must be written in french
2. The articles must be appropriate for children aged 10 years old
3. The articles should not have any inappropriate content or language for children
4. Even if the text is provided in English, the articles must be written in French and must be appropriate for children aged 10 years old
5. Article content should be less than 300 words
`;
};

const GENERATE_STORY_SYSTEM_PROMPT = buildSystemPrompt();

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GenerateStoryApiResponse>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  }

  const { text, email } = req.body;

  if (!text || typeof text !== 'string') {
    return res.status(400).json({
      error: {
        message: 'Text field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  }

  if (!email || typeof email !== 'string') {
    return res.status(400).json({
      error: {
        message: 'Email field is required and must be a string',
        code: 'INVALID_INPUT',
      },
    });
  }

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: GENERATE_STORY_SYSTEM_PROMPT,
        },
        {
          role: 'user',
          content: text,
        },
      ],
      temperature: 0.7,
      max_tokens: 1000,
    });

    const storyContent = completion.choices[0]?.message?.content;

    console.log('Generated story:', storyContent);

    if (!storyContent) {
      return res.status(500).json({
        error: {
          message: 'Failed to generate story',
          code: 'GENERATION_FAILED',
        },
      });
    }

    try {
      const parsedStory = JSON.parse(storyContent);
      const savedStory = await storyService.saveStory(
        email,
        parsedStory.title,
        text,
        parsedStory.article
      );
      return res.status(200).json({ story: savedStory });
    } catch (parseError) {
      console.error('Error parsing story:', parseError);
      return res.status(500).json({
        error: {
          message: 'Failed to parse generated story',
          code: 'PARSE_ERROR',
        },
      });
    }
  } catch (error) {
    console.error('Error generating story:', error);
    return res.status(500).json({
      error: {
        message: 'Failed to generate story',
        code: 'OPENAI_ERROR',
      },
    });
  }
}
</file>

<file path="src/pages/api/generateStoryPrompt.json">
{
  "articles": [
    {
      "title": "C'est quoi un décret présidentiel et pourquoi Donald Trump en a-t-il signé autant?",
      "content": "Choisis l'émoji « J'adore »Tu seras la première personne.\nLe 20 janvier dernier, c'était l'assermentation de Donald Trump : c'est à ce moment-là qu'il est officiellement (re)devenu le président des États-Unis. Depuis qu'il est arrivé au pouvoir, il a signé une trentaine de décrets﻿Nouvelle fenêtre﻿, qui touchent particulièrement les migrants, les personnes issues de la diversité et les personnes LGBTQ+.\nUn décret présidentiel, c'est une décision que le président des États-Unis prend seul, sans qu'elle soit soumise au vote des élus américains. Elle doit toutefois respecter la Constitution des États-Unis (la loi la plus importante du pays).\nUn décret peut être annulé par un juge. D'ailleurs, il y a déjà un des décrets de Donald Trump qui a été suspendu : celui qui empêche les enfants nés aux États-Unis de parents immigrants sans papiers d'être reconnus comme des citoyens américains. La Constitution dit que toute personne née sur le territoire des États-Unis (peu importe le statut de ses parents) obtient automatiquement la citoyenneté américaine.\nC'est normal pour un président de signer des décrets. Ce qu'il y a de particulier avec Donald Trump, c'est qu'il en a signé 26 dès sa première journée au pouvoir, ce qui est beaucoup. La plupart d'entre eux servent à annuler des décisions qui avaient été prises par Joe Biden, son prédécesseur. Donald Trump avait d'ailleurs annoncé après son élection qu'il allait signer une série de décrets historiques  pour commencer la restauration complète de l'Amérique et la révolution du bon sens . Ces décrets ont donc un côté très symbolique."
    },
    {
      "title": "TikTok banni aux États-Unis… pendant 12 heures",
      "content": "«MAIS OÙ EST PASSÉ TIKTOK?!?!», a probablement crié un Américain, dimanche. Pourquoi? Parce que le gouvernement des États-Unis a banni l'application sur son territoire. Résultats: des influenceurs en larmes qui font leurs adieux et des milliers d'internautes qui «déménagent» d'appli. Mais tu sais quoi? Après 12 heures, TikTok était de retour. Je t'explique ce qui s'est passé.\n\nInterdire TikTok\nImportant à savoir: l'entreprise propriétaire de TikTok est chinoise. Et les États-Unis craignent que la Chine se serve de l'application pour espionner les 170 millions d'Américains qui utilisent TikTok. Pour eux, l'application est même une menace à leur sécurité.\nAlors, en avril, l'ancien président américain Joe Biden a décidé que TikTok devait être vendue à un propriétaire américain avant le 19 janvier et couper ses liens avec la Chine. Sinon: bye-bye TikTok. L'application sera INTERDITE aux États-Unis.\nMais est-ce que TikTok a obéi? Non! Ce qui devait arriver arriva!\nDes influenceurs disent au revoir\nDans les jours précédant le 19 janvier, de nombreux Américains pensaient qu'ils ne pourraient plus jamais utiliser TikTok. Des influenceurs ont publié des messages d'adieux pour remercier leurs abonnés… et dénoncer l'interdiction. Tu en as peut-être vu.\nPar exemple, c'est en pleurant que la chanteuse et actrice Emily Senn a dit au revoir à ses 350 000 abonnés.\nFâchés par cette décision, plus de 3 millions d'usagers de TikTok se sont ouvert un compte sur RedNote la semaine dernière. Il s'agit d'une application chinoise qui ressemble beaucoup à TikTok.\nMalgré tout, le 19 janvier, le gouvernement américain a tenu sa promesse. Dimanche, les internautes aux États-Unis ne pouvaient plus regarder ou publier de vidéos sur TikTok.\nDonald Trump s'en mêle\nCependant, les Américains pouvaient voir un message, qui disait: «Nous sommes chanceux que le président Trump ait indiqué qu'il travaillera avec nous pour rétablir TiKTok lorsqu'il sera en poste».\nC'est parce que dès le lendemain de l'interdiction, un nouveau président prenait le pouvoir aux États-Unis! Et ce président, Donald Trump, a dit plusieurs fois qu'il voulait «sauver TikTok». Il s'est engagé à suspendre la loi de Joe Biden.\nAlors, 12 heures plus tard, TikTok est redevenue disponible!\nFaut-il remercier Donald Trump? La réponse est un peu compliquée. Oui, il a fait en sorte que TikTok ne soit plus bannie aux États-Unis… Mais à la base, la loi pour interdire l'application, c'était son idée à lui! Il l'a proposée en 2020!\nUne nouvelle entente?\nAlors, qu'est-ce qui va se passer? Donald Trump aimerait convaincre TikTok de vendre la moitié de la compagnie à un acheteur aux États-Unis. L'appli serait donc 50 % chinoise, 50 % américaine. Dossier à suivre!"
    },
    {
      "title": "La Terre s'est réchauffée de 1,5°C en 150 ans. C'est beaucoup ça?",
      "content": "Récemment, des scientifiques qui mesurent les températures sur Terre ont annoncé leurs résultats: en 2024, la température moyenne sur la planète était plus chaude de 1,5°C par rapport à il y a 150 ans. Bizarrement, ce chiffre donne un peu froid dans le dos. Je t'explique pourquoi.\nUn chiffre qui alerte\nDepuis plusieurs années, les scientifiques disent que la température sur Terre augmente trop vite à cause des gaz à effet de serre produits par les humains. Pour limiter ce réchauffement, presque tous les pays du monde ont signé l'Accord de Paris en 2016.\nCes 193 pays se sont engagés à tout essayer pour que l'augmentation de température ne dépasse pas 2°C par rapport à il y a 150 ans. Mieux! Ils visaient un réchauffement maximum de 1,5°C.\nMais en 2024, ce 1,5°C de plus a été atteint pour la première fois. Si la température reste aussi élevée dans les prochaines années, alors on pourra dire qu'on aura raté le premier objectif de l'Accord de Paris.\nMême si plusieurs pays ont fait de gros efforts pour réduire leurs émissions de gaz à effet de serre, des secteurs comme le transport, l'industrie et l'agriculture en produisent encore beaucoup trop.\nÇa chauffe au Canada\nLe chiffre de 1,5°C est une moyenne sur toute l'année 2024, sur toute la planète. Le réchauffement est plus important à certains endroits qu'à d'autres. C'est le cas, par exemple, dans les régions plus au nord.\nPourquoi? C'est parce que l'augmentation de température fait fondre la neige et la glace. Cela fait en sorte que les rayons du soleil sont absorbés par le sol et la mer, qui sont plus sombres, au lieu de rebondir sur la couleur blanche et de repartir vers l'atmosphère. Résultat: près des pôles, plus il fait chaud, plus ça se réchauffe! D'ailleurs, ce phénomène se ressent ici. Dans le sud du Canada, la température augmente deux fois plus que sur la Terre dans son ensemble.\nEt dans les grandes villes, c'est pire. C'est parce que les routes et les bâtiments absorbent beaucoup la chaleur du soleil. En 2024, il a fait en moyenne 4 °C de plus à Montréal qu'au temps de tes arrières-arrières-grands-parents! 🥵\nPetit chiffre, gros changements\nUn ou deux degrés en plus, ça ne te parait peut-être pas beaucoup, mais c'est assez pour provoquer des chamboulements sur la planète. C'est comme quand tu fais de la fièvre. Mal de tête, fatigue, il suffit que la température de ton corps augmente un tout petit peu pour qu'il soit perturbé.\nPour la Terre, 1,5°C de plus, ça entraîne des événements météo extrêmes, comme les feux de forêt en Californie ou les inondations au Québec, qui sont en partie causés par ce dérèglement. C'est pour ça qu'il faut limiter le réchauffement au maximum!\nOn fait quoi? On baisse les bras?\nJe sais, ce n'est pas très rassurant. Si ça te stresse, c'est normal. Mais tu sais quoi? Il n'est jamais trop tard pour agir. Il faut continuer de se battre pour ralentir le réchauffement. Et dans ce combat-là, tout le monde peut faire sa part, même toi! Limiter ses déplacements en auto ou en avion, manger moins de viande et moins gaspiller sont des petits gestes qui peuvent faire une grande différence.\nPartout dans le monde, des organismes et des gouvernements luttent contre les changements climatiques. Les émissions de gaz à effet de serre du Canada ont diminué d'environ 7% entre 2005 et 2022. Cela représente des tonnes et des tonnes de gaz en moins dans l'atmosphère. Ce n'est pas encore suffisant, mais c'est encourageant!"
    },
    {
      "title": "Le Nouveau-Brunswick enquête sur une mystérieuse maladie",
      "content": "Depuis 10 ans, des citoyens de la péninsule acadienne et de la région de Moncton au Nouveau-Brunswick sont frappés d'un mal inexplicable. La province a décidé de rouvrir une enquête sur ce qu'elle appelle la «maladie mystérieuse du cerveau». Je t'explique.\nProblèmes de mémoire, pertes d'équilibre, douleurs dans les bras et les jambes, vision floue: ce sont certains des symptômes rapportés par des patients néo-brunswickois depuis 2015. Du jour au lendemain, des personnes en pleine forme éprouvent des malaises qui vont en s'empirant.\nEn 2022, des médecins ont enquêté sur la quarantaine de cas signalés. Leur conclusion: il n'existe pas de maladie mystérieuse. Les symptômes de chaque patient pouvaient être expliqués par une maladie connue.\nMais des patients continuent d'éprouver les mêmes symptômes. Depuis 2019, neuf personnes seraient mortes. Et selon le ministre de la Santé du Nouveau-Brunswick, John Dornan, il y aurait plus de 400 cas aujourd'hui. C'est pourquoi le gouvernement vient de rouvrir l'enquête.\nQue sait-on de la maladie?\nPour l'instant, très peu de choses. Les médecins s'entendent pour dire que les symptômes seraient causés par une maladie qui affecte le cerveau.\nOn sait aussi que la majorité des patients viennent de la péninsule acadienne et de la région de Moncton. Rassure-toi: aucun enfant ni adolescent n'a été touché.\nL'enquête va servir à amasser le plus d'informations sur chaque cas afin de voir s'il y a quelque chose de commun à tous les malades.\nDes patients ont déjà demandé aux experts de se pencher sur l'environnement, et particulièrement sur les produits chimiques utilisés en agriculture. Ce sera fait dans une deuxième étape.\nCertains patients qui ont déménagé disent que leurs symptômes ont diminué. C'est peut-être une piste, mais c'est surtout une lueur d'espoir pour ceux qui sont aux prises avec ce mal mystérieux.\nEt toi, y a-t-il un mystère que tu aimerais résoudre? Lequel?"
    }
  ]
}
</file>

<file path="src/pages/api/validateResponse.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import OpenAI from 'openai';
import {
  ValidateResponseApiResponse,
  ValidationInput,
  StudentEvaluation,
  TeacherReview,
} from '../../types/api/validateResponse';
import { answerService } from '../../services/answerService';
import {
  VALIDATE_RESPONSE_SYSTEM_PROMPT,
  REVIEW_RESPONSE_SYSTEM_PROMPT,
} from '../../constants/prompts';

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || 'test-key';
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

interface ValidationResult {
  isValid: boolean;
  error?: {
    message: string;
    code: string;
    status: number;
  };
  data?: ValidationInput;
}

// const ERROR_CODES = {
//   VALIDATION_FAILED: {
//     status: 500,
//     code: 'VALIDATION_FAILED',
//   },
//   PARSE_ERROR: {
//     status: 500,
//     code: 'PARSE_ERROR',
//   },
//   DATABASE_ERROR: {
//     status: 500,
//     code: 'DATABASE_ERROR',
//   },
//   OPENAI_ERROR: {
//     status: 500,
//     code: 'OPENAI_ERROR',
//   },
//   INVALID_RESPONSE_FORMAT: {
//     status: 500,
//     code: 'INVALID_RESPONSE_FORMAT',
//   },
// } as const;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const validateInputs = (body: any): ValidationResult => {
  const { story, question, response, userEmail, storyId } = body;

  if (!story || typeof story !== 'string') {
    return {
      isValid: false,
      error: {
        message: 'Story field is required and must be a string',
        code: 'INVALID_INPUT',
        status: 400,
      },
    };
  }

  if (!question || typeof question !== 'string') {
    return {
      isValid: false,
      error: {
        message: 'Question field is required and must be a string',
        code: 'INVALID_INPUT',
        status: 400,
      },
    };
  }

  if (!response || typeof response !== 'string') {
    return {
      isValid: false,
      error: {
        message: 'Response field is required and must be a string',
        code: 'INVALID_INPUT',
        status: 400,
      },
    };
  }

  if (!userEmail || typeof userEmail !== 'string') {
    return {
      isValid: false,
      error: {
        message: 'User email is required and must be a string',
        code: 'INVALID_INPUT',
        status: 400,
      },
    };
  }

  if (!storyId || typeof storyId !== 'string') {
    return {
      isValid: false,
      error: {
        message: 'Story ID is required and must be a string',
        code: 'INVALID_INPUT',
        status: 400,
      },
    };
  }

  return {
    isValid: true,
    data: { story, question, response, userEmail, storyId },
  };
};

const evaluateStudentResponse = async (input: ValidationInput): Promise<StudentEvaluation> => {
  const prompt = VALIDATE_RESPONSE_SYSTEM_PROMPT.replace('{article}', input.story)
    .replace('{question}', input.question)
    .replace('{response}', input.response);

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: prompt,
        },
      ],
      temperature: 0.3,
      max_tokens: 250,
    });

    const aiResponse = completion.choices[0]?.message?.content;

    if (!aiResponse) {
      throw new Error('Failed to validate response');
    }

    const parsedResponse = JSON.parse(aiResponse);

    if (
      typeof parsedResponse.score !== 'number' ||
      typeof parsedResponse.correction !== 'string' ||
      typeof parsedResponse.suggestedAnswer !== 'string' ||
      parsedResponse.score < 0 ||
      parsedResponse.score > 5
    ) {
      throw new Error('Invalid response format from validation');
    }

    return {
      score: parsedResponse.score,
      correction: parsedResponse.correction,
      suggestedAnswer: parsedResponse.suggestedAnswer,
    };
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error('Failed to parse validation response');
    }
    throw error;
  }
};

const evaluateTeacherResponse = async (
  input: ValidationInput,
  studentEvaluation: StudentEvaluation
): Promise<TeacherReview> => {
  const prompt = REVIEW_RESPONSE_SYSTEM_PROMPT.replace('{story}', input.story)
    .replace('{question}', input.question)
    .replace('{response}', input.response)
    .replace('{score}', studentEvaluation.score.toString())
    .replace('{correction}', studentEvaluation.correction)
    .replace('{suggestedAnswer}', studentEvaluation.suggestedAnswer);

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: prompt,
        },
      ],
      temperature: 0.3,
      max_tokens: 250,
    });

    const aiResponse = completion.choices[0]?.message?.content;

    if (!aiResponse) {
      throw new Error('Failed to review evaluation');
    }

    const parsedResponse = JSON.parse(aiResponse);

    if (
      typeof parsedResponse.isScoreAccurate !== 'boolean' ||
      typeof parsedResponse.finalScore !== 'number' ||
      typeof parsedResponse.finalCorrection !== 'string' ||
      typeof parsedResponse.reviewComments !== 'string' ||
      parsedResponse.finalScore < 0 ||
      parsedResponse.finalScore > 5
    ) {
      throw new Error('Invalid response format from review');
    }

    return {
      isScoreAccurate: parsedResponse.isScoreAccurate,
      finalScore: parsedResponse.finalScore,
      finalCorrection: parsedResponse.finalCorrection,
      reviewComments: parsedResponse.reviewComments,
    };
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error('Failed to parse review response');
    }
    throw error;
  }
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ValidateResponseApiResponse>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({
      error: {
        message: 'Method not allowed',
        code: 'METHOD_NOT_ALLOWED',
      },
    });
  }

  // Validate inputs first
  const validationResult = validateInputs(req.body);
  if (!validationResult.isValid) {
    const { status, message, code } = validationResult.error!;
    return res.status(status).json({
      error: { message, code },
    });
  }

  try {
    // Get initial evaluation
    const studentEvaluation = await evaluateStudentResponse(validationResult.data!);

    // Get teacher review
    const teacherReview = await evaluateTeacherResponse(validationResult.data!, studentEvaluation);

    // Save final results
    try {
      const savedAnswer = await answerService.saveAnswer(
        validationResult.data!.userEmail,
        validationResult.data!.storyId,
        validationResult.data!.question,
        validationResult.data!.response,
        teacherReview.finalScore,
        teacherReview.finalCorrection,
        studentEvaluation.suggestedAnswer
      );

      return res.status(200).json({
        score: teacherReview.finalScore,
        correction: teacherReview.finalCorrection,
        suggestedAnswer: studentEvaluation.suggestedAnswer,
        reviewComments: teacherReview.reviewComments,
        savedAnswer,
      });
    } catch (dbError) {
      return res.status(500).json({
        error: {
          message: 'Failed to save answer to database',
          code: 'DATABASE_ERROR',
        },
      });
    }
  } catch (error) {
    console.error('Error in validate response:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    if (errorMessage.includes('Failed to parse')) {
      return res.status(500).json({
        error: {
          message: 'Failed to parse validation response',
          code: 'PARSE_ERROR',
        },
      });
    }

    if (errorMessage.includes('Invalid response format')) {
      return res.status(500).json({
        error: {
          message: 'Invalid response format from validation',
          code: 'INVALID_RESPONSE_FORMAT',
        },
      });
    }

    return res.status(500).json({
      error: {
        message: 'Failed to validate response',
        code: 'OPENAI_ERROR',
      },
    });
  }
}
</file>

<file path="src/pages/french-idol/create.tsx">
import { FrenchIdolProvider } from '../../components/french-idol/FrenchIdolContext';
import { CreateStoryView } from '../../components/french-idol/CreateStoryView';

export default function CreateFrenchStory() {
  return (
    <FrenchIdolProvider>
      <div className="min-h-screen bg-gray-50">
        <CreateStoryView />
      </div>
    </FrenchIdolProvider>
  );
}
</file>

<file path="src/pages/french-idol/index.tsx">
import { FrenchIdolProvider } from '../../components/french-idol/FrenchIdolContext';
import { FrenchIdolView } from '../../components/french-idol/FrenchIdolView';

export default function FrenchIdol() {
  return (
    <FrenchIdolProvider>
      <div className="min-h-screen bg-gray-50">
        <FrenchIdolView />
      </div>
    </FrenchIdolProvider>
  );
}
</file>

<file path="src/pages/grade-levels/index.tsx">
import React, { useEffect, useState } from 'react';
import { Layout } from '../../components/layout/Layout';
import { GradeLevelsTable } from '../../components/grade-levels/GradeLevelsTable';
import { GradeLevel } from '../../types/gradeLevel';

const GradeLevelsPage: React.FC = () => {
  const [gradeLevels, setGradeLevels] = useState<GradeLevel[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchGradeLevels = async () => {
      try {
        const response = await fetch('/api/grade-levels');
        if (!response.ok) {
          throw new Error('Failed to fetch grade levels');
        }
        const data = await response.json();
        setGradeLevels(data.gradeLevels);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setIsLoading(false);
      }
    };

    fetchGradeLevels();
  }, []);

  return (
    <Layout>
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">Grade Levels</h1>

        {isLoading && (
          <div className="flex justify-center items-center min-h-[200px]">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
          </div>
        )}

        {error && (
          <div
            className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded relative"
            role="alert"
          >
            <p>{error}</p>
          </div>
        )}

        {!isLoading && !error && gradeLevels.length === 0 && (
          <div className="text-center text-gray-500 py-8">No grade levels found.</div>
        )}

        {!isLoading && !error && gradeLevels.length > 0 && (
          <GradeLevelsTable gradeLevels={gradeLevels} />
        )}
      </div>
    </Layout>
  );
};

export default GradeLevelsPage;
</file>

<file path="src/pages/_app.tsx">
import type { AppProps } from 'next/app';
import '../styles/global.css';
import { Layout } from '../components/layout/Layout';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  );
}

export default MyApp;
</file>

<file path="src/pages/icons.tsx">
import React from 'react';
import { IconAdd } from '../ui-kit/icons/IconAdd';
import { IconArrowDown } from '../ui-kit/icons/IconArrowDown';
import { IconArrowDownUp } from '../ui-kit/icons/IconArrowDownUp';
import { IconArrowLeft } from '../ui-kit/icons/IconArrowLeft';
import { IconButton } from '../ui-kit/icons/IconButton';
import { IconCopy } from '../ui-kit/icons/IconCopy';
import { IconCreate } from '../ui-kit/icons/IconCreate';
import { IconDelete } from '../ui-kit/icons/IconDelete';
import { IconDownload } from '../ui-kit/icons/IconDownload';
import { IconEdit } from '../ui-kit/icons/IconEdit';
import { IconError } from '../ui-kit/icons/IconError';
import { IconHelp } from '../ui-kit/icons/IconHelp';
import { IconLike } from '../ui-kit/icons/IconLike';
import { IconLogo } from '../ui-kit/icons/IconLogo';
import { IconMenu } from '../ui-kit/icons/IconMenu';
import { IconMinus } from '../ui-kit/icons/IconMinus';
import { IconPlus } from '../ui-kit/icons/IconPlus';
import { IconRedo } from '../ui-kit/icons/IconRedo';
import { IconReload } from '../ui-kit/icons/IconReload';
import { IconSave } from '../ui-kit/icons/IconSave';
import { IconSearch } from '../ui-kit/icons/IconSearch';
import { IconSend } from '../ui-kit/icons/IconSend';
import { IconSettings } from '../ui-kit/icons/IconSettings';
import { IconUser } from '../ui-kit/icons/IconUser';

const icons = [
  { name: 'Add', component: IconAdd },
  { name: 'ArrowDown', component: IconArrowDown },
  { name: 'ArrowDownUp', component: IconArrowDownUp },
  { name: 'ArrowLeft', component: IconArrowLeft },
  { name: 'Button', component: IconButton },
  { name: 'Copy', component: IconCopy },
  { name: 'Create', component: IconCreate },
  { name: 'Delete', component: IconDelete },
  { name: 'Download', component: IconDownload },
  { name: 'Edit', component: IconEdit },
  { name: 'Error', component: IconError },
  { name: 'Help', component: IconHelp },
  { name: 'Like', component: IconLike },
  { name: 'Logo', component: IconLogo },
  { name: 'Menu', component: IconMenu },
  { name: 'Minus', component: IconMinus },
  { name: 'Plus', component: IconPlus },
  { name: 'Redo', component: IconRedo },
  { name: 'Reload', component: IconReload },
  { name: 'Save', component: IconSave },
  { name: 'Search', component: IconSearch },
  { name: 'Send', component: IconSend },
  { name: 'Settings', component: IconSettings },
  { name: 'User', component: IconUser },
].sort((a, b) => a.name.localeCompare(b.name));

// Helper function to chunk array into groups of n
const chunkArray = <T,>(arr: T[], size: number): T[][] => {
  return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
    arr.slice(i * size, i * size + size)
  );
};

const IconsPage = () => {
  const iconRows = chunkArray(icons, 5);

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-8">Icons</h1>
      <div className="overflow-hidden border rounded-lg">
        <table className="min-w-full divide-y divide-gray-200">
          <tbody className="bg-white divide-y divide-gray-200">
            {iconRows.map((row, rowIndex) => (
              <tr key={rowIndex} className="hover:bg-gray-50">
                {row.map(({ name, component: Icon }) => (
                  <td key={name} className="px-6 py-4 whitespace-nowrap">
                    <div className="flex flex-col items-center">
                      <Icon size={24} className="text-gray-500 mb-2" />
                      <div className="text-sm text-gray-900">{name}</div>
                    </div>
                  </td>
                ))}
                {/* Add empty cells to maintain 5 columns if row is not complete */}
                {Array.from({ length: 5 - row.length }).map((_, i) => (
                  <td key={`empty-${i}`} className="px-6 py-4 whitespace-nowrap" />
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default IconsPage;
</file>

<file path="src/pages/index.tsx">
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import type { NextPage } from 'next';

const Home: NextPage = () => {
  const router = useRouter();

  useEffect(() => {
    router.push('/french-idol');
  }, [router]);

  return null;
};

export default Home;
</file>

<file path="src/pages/profile.tsx">
import { NextPage } from 'next';
import { Layout } from '../components/layout/Layout';
import { ProfileComponent } from '../components/profile/ProfileComponent';

const ProfilePage: NextPage = () => {
  // TODO: In a real application, this would come from an auth context or session
  const testEmail = 'vincent@gmail.com';

  return (
    <Layout>
      <div className="container mx-auto px-4 py-8">
        <ProfileComponent email={testEmail} />
      </div>
    </Layout>
  );
};

export default ProfilePage;
</file>

<file path="src/pages/results.tsx">
import { NextPage } from 'next';
import { Layout } from '../components/layout/Layout';
import { ResultsComponent } from '../components/results/ResultsComponent';

const ResultsPage: NextPage = () => {
  // TODO: In a real application, this would come from an auth context or session
  const testEmail = 'vincent@gmail.com';

  return (
    <Layout>
      <ResultsComponent email={testEmail} />
    </Layout>
  );
};

export default ResultsPage;
</file>

<file path="src/services/__tests__/answerService.test.ts">
import { describe, expect, it, beforeEach, vi } from 'vitest';
import mongoose from 'mongoose';
import { Answer, IAnswerDocument } from '../../models/Answer';
import { answerService } from '../answerService';

// Mock MongoDB connection
vi.mock('../../lib/mongodb', () => ({
  default: vi.fn().mockResolvedValue(mongoose),
}));

describe('AnswerService', () => {
  const mockEmail = 'test@example.com';
  const mockStoryId = new mongoose.Types.ObjectId().toString();
  const mockQuestion = 'What is the main idea of the story?';
  const mockAnswer = 'The main idea is about friendship.';
  const mockScore = 85;
  const mockCorrection = 'Good answer, but could be more specific.';

  const mockAnswerDoc: Partial<IAnswerDocument> = {
    _id: new mongoose.Types.ObjectId(),
    userEmail: mockEmail.toLowerCase(),
    storyId: new mongoose.Types.ObjectId(mockStoryId),
    question: mockQuestion,
    answer: mockAnswer,
    score: mockScore,
    correction: mockCorrection,
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('saveAnswer', () => {
    it('should save a new answer', async () => {
      // Mock the Answer constructor and save method
      const saveMock = vi.fn().mockResolvedValueOnce(mockAnswerDoc);
      vi.spyOn(Answer.prototype, 'save').mockImplementationOnce(saveMock);

      const result = await answerService.saveAnswer(
        mockEmail,
        mockStoryId,
        mockQuestion,
        mockAnswer,
        mockScore,
        mockCorrection
      );

      expect(result).toEqual({
        id: mockAnswerDoc._id!.toString(),
        userEmail: mockEmail.toLowerCase(),
        storyId: mockStoryId,
        question: mockQuestion,
        answer: mockAnswer,
        score: mockScore,
        correction: mockCorrection,
        createdAt: mockAnswerDoc.createdAt,
        updatedAt: mockAnswerDoc.updatedAt,
      });
    });
  });

  describe('getUserAnswers', () => {
    it('should retrieve all answers for a user', async () => {
      const mockAnswers = [
        mockAnswerDoc,
        {
          ...mockAnswerDoc,
          _id: new mongoose.Types.ObjectId(),
          question: 'Another question?',
          answer: 'Another answer',
          score: 90,
          correction: 'Well done!',
        },
      ];

      // Mock the Answer.find method
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce(mockAnswers),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getUserAnswers(mockEmail);

      expect(results).toHaveLength(2);
      expect(results[0]).toEqual({
        id: mockAnswerDoc._id!.toString(),
        userEmail: mockEmail.toLowerCase(),
        storyId: mockStoryId,
        question: mockQuestion,
        answer: mockAnswer,
        score: mockScore,
        correction: mockCorrection,
        createdAt: mockAnswerDoc.createdAt,
        updatedAt: mockAnswerDoc.updatedAt,
      });
    });

    it('should return empty array when user has no answers', async () => {
      // Mock the Answer.find method to return empty array
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce([]),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getUserAnswers('nonexistent@example.com');
      expect(results).toEqual([]);
    });
  });

  describe('getAnswersByStory', () => {
    it('should retrieve all answers for a story', async () => {
      const mockAnswers = [
        mockAnswerDoc,
        {
          ...mockAnswerDoc,
          _id: new mongoose.Types.ObjectId(),
          userEmail: 'another@example.com',
          answer: 'Different answer',
          score: 75,
          correction: 'Good try',
        },
      ];

      // Mock the Answer.find method
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce(mockAnswers),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getAnswersByStory(mockStoryId);

      expect(results).toHaveLength(2);
      expect(results[0].storyId).toBe(mockStoryId);
      expect(results[1].storyId).toBe(mockStoryId);
    });

    it('should return empty array when story has no answers', async () => {
      // Mock the Answer.find method to return empty array
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce([]),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getAnswersByStory(
        new mongoose.Types.ObjectId().toString()
      );
      expect(results).toEqual([]);
    });
  });

  describe('getUserAnswersForStory', () => {
    it('should retrieve all answers for a user and story', async () => {
      const mockAnswers = [
        mockAnswerDoc,
        {
          ...mockAnswerDoc,
          _id: new mongoose.Types.ObjectId(),
          question: 'Another question?',
          answer: 'Another answer',
          score: 90,
          correction: 'Well done!',
        },
      ];

      // Mock the Answer.find method
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce(mockAnswers),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getUserAnswersForStory(mockEmail, mockStoryId);

      expect(results).toHaveLength(2);
      results.forEach(result => {
        expect(result.userEmail).toBe(mockEmail.toLowerCase());
        expect(result.storyId).toBe(mockStoryId);
      });
    });

    it('should return empty array when user has no answers for story', async () => {
      // Mock the Answer.find method to return empty array
      vi.spyOn(Answer, 'find').mockReturnValueOnce({
        sort: vi.fn().mockResolvedValueOnce([]),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      const results = await answerService.getUserAnswersForStory(
        'nonexistent@example.com',
        mockStoryId
      );
      expect(results).toEqual([]);
    });
  });
});
</file>

<file path="src/services/__tests__/storyService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import mongoose from 'mongoose';
import { storyService } from '../storyService';
import { Story, IStoryDocument } from '../../models/Story';
import connectDB from '../../lib/mongodb';

// Mock the MongoDB connection
vi.mock('../../lib/mongodb', () => ({
  default: vi.fn().mockResolvedValue(mongoose),
}));

describe('StoryService', () => {
  const mockStory: Partial<IStoryDocument> = {
    _id: new mongoose.Types.ObjectId(),
    userEmail: 'test@example.com',
    title: 'Test Story',
    sourceText: 'Original text',
    article: 'Generated article',
    read: false,
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('saveStory', () => {
    it('should save a new story successfully', async () => {
      // Mock the Story.prototype.save method
      const saveSpy = vi
        .spyOn(Story.prototype, 'save')
        .mockResolvedValueOnce(mockStory as IStoryDocument);

      const result = await storyService.saveStory(
        'test@example.com',
        'Test Story',
        'Original text',
        'Generated article'
      );

      expect(connectDB).toHaveBeenCalled();
      expect(saveSpy).toHaveBeenCalled();
      expect(result).toEqual({
        id: mockStory._id!.toString(),
        userEmail: mockStory.userEmail,
        title: mockStory.title,
        sourceText: mockStory.sourceText,
        article: mockStory.article,
        read: mockStory.read,
        createdAt: mockStory.createdAt,
        updatedAt: mockStory.updatedAt,
      });
      expect(result.read).toBe(false); // Verify read flag is set to false
    });

    it('should handle save failure', async () => {
      // Mock save to throw an error
      vi.spyOn(Story.prototype, 'save').mockRejectedValueOnce(new Error('Save failed'));

      await expect(
        storyService.saveStory(
          'test@example.com',
          'Test Story',
          'Original text',
          'Generated article'
        )
      ).rejects.toThrow('Save failed');

      expect(connectDB).toHaveBeenCalled();
    });
  });

  describe('getUserStories', () => {
    it('should return stories filtered by read status', async () => {
      const mockStories = [
        mockStory,
        {
          ...mockStory,
          _id: new mongoose.Types.ObjectId(),
          title: 'Another Story',
          read: true,
        },
      ];

      // Mock the Story.find method
      vi.spyOn(Story, 'find').mockResolvedValueOnce([mockStories[0]] as IStoryDocument[]);

      const result = await storyService.getUserStories('test@example.com', false);

      expect(connectDB).toHaveBeenCalled();
      expect(Story.find).toHaveBeenCalledWith({
        userEmail: 'test@example.com',
        read: false,
      });
      expect(result).toHaveLength(1);
      expect(result[0]).toEqual({
        id: mockStories[0]._id!.toString(),
        userEmail: mockStories[0].userEmail,
        title: mockStories[0].title,
        sourceText: mockStories[0].sourceText,
        article: mockStories[0].article,
        read: mockStories[0].read,
        createdAt: mockStories[0].createdAt,
        updatedAt: mockStories[0].updatedAt,
      });
    });

    it('should return empty array when no stories exist', async () => {
      // Mock the Story.find method to return empty array
      vi.spyOn(Story, 'find').mockResolvedValueOnce([]);

      const result = await storyService.getUserStories('test@example.com', true);

      expect(connectDB).toHaveBeenCalled();
      expect(Story.find).toHaveBeenCalledWith({
        userEmail: 'test@example.com',
        read: true,
      });
      expect(result).toEqual([]);
    });
  });

  describe('markStoryRead', () => {
    it('should mark a story as read successfully', async () => {
      const updatedMockStory = {
        ...mockStory,
        read: true,
        updatedAt: '2024-01-29T13:00:00.000Z',
      };

      // Create a mock document with save method
      const mockDocument = {
        ...mockStory,
        save: vi.fn().mockResolvedValueOnce(updatedMockStory),
      } as unknown as IStoryDocument;

      // Mock findOne to return the document
      vi.spyOn(Story, 'findOne').mockResolvedValueOnce(mockDocument);

      const result = await storyService.markStoryRead(
        'test@example.com',
        mockStory._id!.toString()
      );

      expect(connectDB).toHaveBeenCalled();
      expect(Story.findOne).toHaveBeenCalledWith({
        _id: mockStory._id!.toString(),
        userEmail: 'test@example.com',
      });
      expect(result).toEqual({
        id: updatedMockStory._id!.toString(),
        userEmail: updatedMockStory.userEmail,
        title: updatedMockStory.title,
        sourceText: updatedMockStory.sourceText,
        article: updatedMockStory.article,
        read: true,
        createdAt: updatedMockStory.createdAt,
        updatedAt: updatedMockStory.updatedAt,
      });
    });

    it('should throw error when story not found', async () => {
      // Mock findOne to return null
      vi.spyOn(Story, 'findOne').mockResolvedValueOnce(null);

      const storyId = new mongoose.Types.ObjectId().toString();
      await expect(storyService.markStoryRead('test@example.com', storyId)).rejects.toThrow(
        `Story not found with id: ${storyId} for user: test@example.com`
      );

      expect(connectDB).toHaveBeenCalled();
      expect(Story.findOne).toHaveBeenCalledWith({
        _id: storyId,
        userEmail: 'test@example.com',
      });
    });

    it('should handle save failure when marking as read', async () => {
      // Create a mock document with save method that throws
      const mockDocument = {
        ...mockStory,
        save: vi.fn().mockRejectedValueOnce(new Error('Save failed')),
      } as unknown as IStoryDocument;

      // Mock findOne to return the document
      vi.spyOn(Story, 'findOne').mockResolvedValueOnce(mockDocument);

      await expect(
        storyService.markStoryRead('test@example.com', mockStory._id!.toString())
      ).rejects.toThrow('Save failed');

      expect(connectDB).toHaveBeenCalled();
    });
  });
});
</file>

<file path="src/services/__tests__/userService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import mongoose from 'mongoose';
import { userService } from '../userService';
import { User, IUserDocument } from '../../models/User';
import connectDB from '../../lib/mongodb';

// Mock the MongoDB connection
vi.mock('../../lib/mongodb', () => ({
  default: vi.fn().mockResolvedValue(mongoose),
}));

describe('UserService', () => {
  const mockUser: Partial<IUserDocument> = {
    _id: new mongoose.Types.ObjectId(),
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
    createdAt: '2024-01-29T12:00:00.000Z',
    updatedAt: '2024-01-29T12:00:00.000Z',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('getUserByEmail', () => {
    it('should return user when found', async () => {
      // Mock the User.findOne method
      vi.spyOn(User, 'findOne').mockResolvedValueOnce(mockUser as IUserDocument);

      const result = await userService.getUserByEmail('test@example.com');

      expect(connectDB).toHaveBeenCalled();
      expect(User.findOne).toHaveBeenCalledWith({
        email: 'test@example.com',
      });
      expect(result).toEqual({
        id: mockUser._id!.toString(),
        email: mockUser.email,
        firstName: mockUser.firstName,
        lastName: mockUser.lastName,
        createdAt: mockUser.createdAt,
        updatedAt: mockUser.updatedAt,
      });
    });

    it('should throw error when user not found', async () => {
      // Mock the User.findOne method to return null
      vi.spyOn(User, 'findOne').mockResolvedValueOnce(null);

      await expect(userService.getUserByEmail('nonexistent@example.com')).rejects.toThrow(
        'User not found with email: nonexistent@example.com'
      );

      expect(connectDB).toHaveBeenCalled();
      expect(User.findOne).toHaveBeenCalledWith({
        email: 'nonexistent@example.com',
      });
    });
  });

  describe('getAllUsers', () => {
    it('should return all users', async () => {
      const mockUsers = [
        mockUser,
        {
          ...mockUser,
          _id: new mongoose.Types.ObjectId(),
          email: 'test2@example.com',
        },
      ];

      // Mock the User.find method
      vi.spyOn(User, 'find').mockResolvedValueOnce(mockUsers as IUserDocument[]);

      const result = await userService.getAllUsers();

      expect(connectDB).toHaveBeenCalled();
      expect(User.find).toHaveBeenCalledWith({});
      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: mockUsers[0]._id!.toString(),
        email: mockUsers[0].email,
        firstName: mockUsers[0].firstName,
        lastName: mockUsers[0].lastName,
        createdAt: mockUsers[0].createdAt,
        updatedAt: mockUsers[0].updatedAt,
      });
    });

    it('should return empty array when no users exist', async () => {
      // Mock the User.find method to return empty array
      vi.spyOn(User, 'find').mockResolvedValueOnce([]);

      const result = await userService.getAllUsers();

      expect(connectDB).toHaveBeenCalled();
      expect(User.find).toHaveBeenCalledWith({});
      expect(result).toEqual([]);
    });
  });

  describe('exists', () => {
    it('should return true when user exists', async () => {
      vi.spyOn(User, 'findOne').mockResolvedValueOnce(mockUser as IUserDocument);

      const result = await userService.exists('test@example.com');

      expect(result).toBe(true);
      expect(connectDB).toHaveBeenCalled();
      expect(User.findOne).toHaveBeenCalledWith({
        email: 'test@example.com',
      });
    });

    it('should return false when user does not exist', async () => {
      vi.spyOn(User, 'findOne').mockResolvedValueOnce(null);

      const result = await userService.exists('nonexistent@example.com');

      expect(result).toBe(false);
      expect(connectDB).toHaveBeenCalled();
      expect(User.findOne).toHaveBeenCalledWith({
        email: 'nonexistent@example.com',
      });
    });
  });
});
</file>

<file path="src/services/answerService.ts">
import { Answer, mapAnswerToDTO } from '../models/Answer';
import connectDB from '../lib/mongodb';
import { Answer as AnswerType } from '../types/answer';

/**
 * Service class for handling answer-related operations
 */
export class AnswerService {
  /**
   * Saves a new answer for a user
   * @param email - The user's email address
   * @param storyId - The ID of the story being answered
   * @param question - The question being answered
   * @param answer - The user's answer
   * @param score - The score for the answer (0-100)
   * @param correction - The correction/feedback for the answer
   * @returns The saved answer data transformed to frontend type
   */
  async saveAnswer(
    email: string,
    storyId: string,
    question: string,
    answer: string,
    score: number,
    correction: string,
    suggestedAnswer: string
  ): Promise<AnswerType> {
    await connectDB();
    console.log('Creating new answer for user:', email);

    const now = new Date().toISOString();
    const answerDoc = new Answer({
      userEmail: email.toLowerCase(),
      storyId,
      question,
      answer,
      score,
      correction,
      suggestedAnswer,
      createdAt: now,
      updatedAt: now,
    });

    const savedAnswer = await answerDoc.save();
    console.log('Saved answer:', savedAnswer);

    return mapAnswerToDTO(savedAnswer);
  }

  /**
   * Retrieves all answers for a user
   * @param email - The user's email address
   * @returns Array of answers transformed to frontend type
   */
  async getUserAnswers(email: string): Promise<AnswerType[]> {
    await connectDB();
    console.log('Fetching answers for user:', email);

    const answers = await Answer.find({
      userEmail: email.toLowerCase(),
    }).sort({ createdAt: -1 }); // Most recent first

    console.log(`Found ${answers.length} answers`);

    return answers.map(mapAnswerToDTO);
  }

  /**
   * Retrieves all answers for a specific story
   * @param storyId - The story ID
   * @returns Array of answers transformed to frontend type
   */
  async getAnswersByStory(storyId: string): Promise<AnswerType[]> {
    await connectDB();
    console.log('Fetching answers for story:', storyId);

    const answers = await Answer.find({ storyId }).sort({ createdAt: -1 }); // Most recent first
    console.log(`Found ${answers.length} answers for story`);

    return answers.map(mapAnswerToDTO);
  }

  /**
   * Retrieves all answers for a user for a specific story
   * @param email - The user's email address
   * @param storyId - The story ID
   * @returns Array of answers transformed to frontend type
   */
  async getUserAnswersForStory(email: string, storyId: string): Promise<AnswerType[]> {
    await connectDB();
    console.log('Fetching answers for user:', email, 'and story:', storyId);

    const answers = await Answer.find({
      userEmail: email.toLowerCase(),
      storyId,
    }).sort({ createdAt: -1 }); // Most recent first

    console.log(`Found ${answers.length} answers`);

    return answers.map(mapAnswerToDTO);
  }
}

// Export a singleton instance
export const answerService = new AnswerService();
</file>

<file path="src/services/storyService.ts">
import { Story, mapStoryToDTO } from '../models/Story';
import connectDB from '../lib/mongodb';
import { Story as StoryType } from '../types/story';

/**
 * Service class for handling story-related operations
 */
export class StoryService {
  /**
   * Saves a new story for a user
   * @param email - The user's email address
   * @param title - The story title
   * @param sourceText - The original source text
   * @param article - The generated article
   * @returns The saved story data transformed to frontend type
   */
  async saveStory(
    email: string,
    title: string,
    sourceText: string,
    article: string
  ): Promise<StoryType> {
    await connectDB();
    console.log('Creating new story for user:', email);

    const now = new Date().toISOString();
    const story = new Story({
      userEmail: email.toLowerCase(),
      title,
      sourceText,
      article,
      read: false,
      createdAt: now,
      updatedAt: now,
    });

    const savedStory = await story.save();
    console.log('Saved story:', savedStory);

    return mapStoryToDTO(savedStory);
  }

  /**
   * Retrieves stories for a user filtered by read status
   * @param email - The user's email address
   * @param read - The read status to filter by
   * @returns Array of stories transformed to frontend type
   */
  async getUserStories(email: string, read: boolean): Promise<StoryType[]> {
    await connectDB();
    console.log('Fetching stories for user:', email, 'with read status:', read);

    const stories = await Story.find({
      userEmail: email.toLowerCase(),
      read,
    });
    console.log(`Found ${stories.length} stories`);

    return stories.map(mapStoryToDTO);
  }

  /**
   * Marks a story as read and saves the quiz score
   * @param email - The user's email address
   * @param id - The story ID
   * @param quizScore - The score achieved in the quiz
   * @param totalQuestions - The total number of questions in the quiz
   * @returns The updated story data transformed to frontend type
   * @throws Error if story is not found or doesn't belong to the user
   */
  async markStoryRead(
    email: string,
    id: string,
    quizScore: number,
    totalQuestions: number,
    questions: string[],
    questionResponses: string[],
    questionCorrections: string[]
  ): Promise<StoryType> {
    await connectDB();
    console.log('Marking story as read with score:', id, 'for user:', email);

    const story = await Story.findOne({
      _id: id,
      userEmail: email.toLowerCase(),
    });

    if (!story) {
      throw new Error(`Story not found with id: ${id} for user: ${email}`);
    }

    story.read = true;
    story.quizScore = quizScore;
    story.totalQuestions = totalQuestions;
    story.questions = questions;
    story.questionResponses = questionResponses;
    story.questionCorrections = questionCorrections;
    story.updatedAt = new Date().toISOString();

    const updatedStory = await story.save();
    console.log('Updated story:', updatedStory);

    return mapStoryToDTO(updatedStory);
  }
}

// Export a singleton instance
export const storyService = new StoryService();
</file>

<file path="src/services/userService.ts">
import { User, mapUserToDTO } from '../models/User';
import connectDB from '../lib/mongodb';
import { User as UserType } from '../types/user';

/**
 * Service class for handling user-related operations
 */
export class UserService {
  /**
   * Retrieves a user by their email address
   * @param email - The email address to search for
   * @returns The user data transformed to frontend type
   * @throws Error if user is not found
   */
  async getUserByEmail(email: string): Promise<UserType> {
    await connectDB();
    const query = { email: email.toLowerCase() };
    console.log('Searching for user with query:', query);

    const user = await User.findOne(query);
    console.log('Raw user search result:', user);

    if (!user) {
      throw new Error(`User not found with email: ${email}`);
    }

    return mapUserToDTO(user);
  }

  /**
   * Retrieves all users from the database
   * @returns Array of users transformed to frontend type
   */
  async getAllUsers(): Promise<UserType[]> {
    await connectDB();
    console.log('Fetching all users...');

    const users = await User.find({});
    console.log('Raw query result:', JSON.stringify(users, null, 2));
    console.log(`Found ${users.length} users`);

    return users.map(mapUserToDTO);
  }

  /**
   * Checks if a user exists with the given email
   * @param email - The email address to check
   * @returns True if user exists, false otherwise
   */
  async exists(email: string): Promise<boolean> {
    await connectDB();
    const query = { email: email.toLowerCase() };
    console.log('Checking user existence with query:', query);

    const user = await User.findOne(query);
    console.log('Raw existence check result:', user);

    return !!user;
  }

  /**
   * Updates a user's profile information
   * @param email - The email of the user to update
   * @param updates - The fields to update (firstName and lastName)
   * @returns The updated user data transformed to frontend type
   * @throws Error if user is not found
   */
  async updateUser(
    email: string,
    updates: { firstName: string; lastName: string }
  ): Promise<UserType> {
    await connectDB();
    const query = { email: email.toLowerCase() };
    console.log('Updating user with query:', query);
    console.log('Updates:', updates);

    const user = await User.findOneAndUpdate(
      query,
      {
        ...updates,
        updatedAt: new Date().toISOString(),
      },
      { new: true }
    );

    if (!user) {
      throw new Error(`User not found with email: ${email}`);
    }

    return mapUserToDTO(user);
  }
}

// Export a singleton instance
export const userService = new UserService();
</file>

<file path="src/styles/global.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  /* Button Styles */
  .btn {
    @apply inline-flex items-center justify-center px-6 py-2.5 rounded-full font-medium transition-colors duration-200;
  }
  .btn-primary {
    @apply btn bg-primary text-white hover:bg-primary-hover shadow-sm;
  }
  .btn-secondary {
    @apply btn bg-secondary text-white hover:bg-secondary-hover;
  }

  /* Dropdown Styles */
  .dropdown {
    @apply relative inline-block;
  }
  .dropdown-content {
    @apply absolute z-50 mt-2 w-56 rounded-dropdown bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none;
  }
  .dropdown-item {
    @apply block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer;
  }

  /* Input Styles */
  .input {
    @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm;
  }

  /* Card Styles */
  .card {
    @apply bg-white rounded-lg shadow-md p-6;
  }
}
</file>

<file path="src/styles/Home.module.css">
.container {
  min-height: 100vh;
  padding: 0 0.5rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.title a {
  color: #0070f3;
  text-decoration: none;
}

.title a:hover,
.title a:focus,
.title a:active {
  text-decoration: underline;
}

.title {
  margin: 0 0 1rem;
  line-height: 1.15;
  font-size: 3.6rem;
}

.title {
  text-align: center;
}

.title,
.description {
  text-align: center;
}

.description {
  line-height: 1.5;
  font-size: 1.5rem;
}

.grid {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;

  max-width: 800px;
  margin-top: 3rem;
}

.card {
  margin: 1rem;
  flex-basis: 45%;
  padding: 1.5rem;
  text-align: left;
  color: inherit;
  text-decoration: none;
  border: 1px solid #eaeaea;
  border-radius: 10px;
  transition:
    color 0.15s ease,
    border-color 0.15s ease;
}

.card:hover,
.card:focus,
.card:active {
  color: #0070f3;
  border-color: #0070f3;
}

.card h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.card p {
  margin: 0;
  font-size: 1.25rem;
  line-height: 1.5;
}

.logo {
  height: 1em;
}

@media (max-width: 600px) {
  .grid {
    width: 100%;
    flex-direction: column;
  }
}
</file>

<file path="src/test/__mocks__/openai.ts">
import { vi } from 'vitest';

const mockOpenAI = vi.fn().mockImplementation(() => ({
  chat: {
    completions: {
      create: vi.fn(),
    },
  },
}));

export default mockOpenAI;
</file>

<file path="src/test/mocks/openai.ts">
import { vi } from 'vitest';

export const mockCreate = vi.fn();

export const mockOpenAI = {
  chat: {
    completions: {
      create: mockCreate,
    },
  },
};
</file>

<file path="src/test/mocks/validateResponseSetup.ts">
import { vi, beforeEach, afterEach } from 'vitest';
import { mockCreate } from './openai';

// Mock OpenAI module
vi.mock('openai', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate,
        },
      },
    })),
  };
});

// Mock process.env
const processEnv = process.env;
vi.spyOn(process, 'env', 'get').mockReturnValue({
  ...processEnv,
  OPENAI_API_KEY: 'test-key',
});

export const setupValidateResponseMocks = () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllTimers();
  });
};
</file>

<file path="src/test/setup.ts">
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend vitest's expect with testing-library matchers
// eslint-disable-next-line @typescript-eslint/no-explicit-any
expect.extend(matchers as any);

// Automatically clean up after each test
afterEach(() => {
  cleanup();
});
</file>

<file path="src/test/vitest.d.ts">
/// <reference types="vitest" />
/// <reference types="@testing-library/jest-dom" />

import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';

declare module 'vitest' {
  interface Assertion<T> extends TestingLibraryMatchers<T, void> {}
}
</file>

<file path="src/types/api/generateQuestions.ts">
export interface GenerateQuestionsRequest {
  story: string;
}

export interface GenerateQuestionsResponse {
  questions: string[];
  error?: never;
}

export interface GenerateQuestionsError {
  questions?: never;
  error: {
    message: string;
    code: string;
  };
}

export type GenerateQuestionsApiResponse = GenerateQuestionsResponse | GenerateQuestionsError;
</file>

<file path="src/types/api/generateStory.ts">
import { Story } from '../story';

export interface GenerateStoryRequest {
  text: string;
  email: string;
}

export interface GenerateStoryResponse {
  story: Story;
  error?: never;
}

export interface GenerateStoryError {
  story?: never;
  error: {
    message: string;
    code: string;
  };
}

export type GenerateStoryApiResponse = GenerateStoryResponse | GenerateStoryError;
</file>

<file path="src/types/api/getStoryAnswers.ts">
export interface GetStoryAnswersResponse {
  answers: {
    id: string;
    question: string;
    answer: string;
    score: number;
    correction: string;
  }[];
}

export interface GetStoryAnswersError {
  message: string;
}
</file>

<file path="src/types/api/listStories.ts">
import { Story } from '../story';

/**
 * Query parameters for listing stories
 */
export interface ListStoriesQuery {
  email: string;
  read?: string; // boolean as string since query params are strings
}

/**
 * Response type for listing stories
 */
export interface ListStoriesResponse {
  stories: Story[];
}
</file>

<file path="src/types/api/validateResponse.ts">
export interface ValidationInput {
  story: string;
  question: string;
  response: string;
  userEmail: string;
  storyId: string;
}

export interface StudentEvaluation {
  score: number;
  correction: string;
  suggestedAnswer: string;
}

export interface TeacherReview {
  isScoreAccurate: boolean;
  finalScore: number;
  finalCorrection: string;
  reviewComments: string;
}

export interface ValidateResponseApiResponse {
  score?: number;
  correction?: string;
  suggestedAnswer?: string;
  reviewComments?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  savedAnswer?: any;
  error?: {
    message: string;
    code: string;
  };
}
</file>

<file path="src/types/answer.ts">
/**
 * Interface representing an Answer in the frontend
 */
export interface Answer {
  id: string;
  userEmail: string;
  storyId: string;
  question: string;
  answer: string;
  score: number;
  correction: string;
  suggestedAnswer: string;
  createdAt: string;
  updatedAt: string;
}
</file>

<file path="src/types/express.d.ts">
import { IUserDocument } from '../models/User';

declare global {
  namespace Express {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface User extends IUserDocument {}
  }
}
</file>

<file path="src/types/global.d.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
declare global {
  // eslint-disable-next-line no-var
  var mongoose:
    | {
        conn: any;
        promise: Promise<any> | null;
      }
    | undefined;
}

export {};
</file>

<file path="src/types/gradeLevel.ts">
export interface GradeLevel {
  id: string;
  grade: number;
  levelName: string;
  averageAge: number;
  numberOfQuestions: number;
  instructions: string;
  storyWordCount: number;
}

export interface GradeLevelsResponse {
  gradeLevels: GradeLevel[];
}
</file>

<file path="src/types/story.ts">
/**
 * Interface representing a Story in the frontend
 */
export interface QuizResultData {
  question: string;
  score: number;
  response: string;
  correction: string;
  suggestedAnswer: string;
}

export interface Story {
  id: string;
  userEmail: string;
  sourceText: string;
  title: string;
  article: string;
  read: boolean;
  quizScore?: number | null;
  totalQuestions?: number | null;
  questionResponses?: string[] | null;
  questionCorrections?: string[] | null;
  questions?: string[] | null;
  suggestedAnswers?: string[] | null;
  createdAt: string;
  updatedAt: string;
}
</file>

<file path="src/types/user.ts">
/**
 * Shared type representing a user in the frontend
 */
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * Type for creating a new user
 */
export interface CreateUserInput {
  email: string;
  firstName: string;
  lastName: string;
}

/**
 * API response type for getting a user
 */
export interface GetUserResponse {
  user: User;
}

/**
 * Type for updating a user's profile
 */
export interface UpdateUserInput {
  email: string;
  firstName: string;
  lastName: string;
}

/**
 * API response type for updating a user
 */
export interface UpdateUserResponse {
  user: User;
}
</file>

<file path="src/ui-kit/__mocks__/gsap.ts">
import { vi } from 'vitest';

// eslint-disable-next-line import/no-anonymous-default-export
export default {
  to: vi.fn(),
};
</file>

<file path="src/ui-kit/icons/IconAdd.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconAdd } from './IconAdd';

describe('IconAdd Component', () => {
  it('renders with default props', () => {
    render(<IconAdd data-testid="icon" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toBeInTheDocument();
    expect(icon.tagName.toLowerCase()).toBe('svg');
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon.querySelector('path')).toHaveAttribute('fill', 'currentColor');
  });

  it('renders with custom size', () => {
    const customSize = 32;
    render(<IconAdd data-testid="icon" size={customSize} />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('width', customSize.toString());
    expect(icon).toHaveAttribute('height', customSize.toString());
  });

  it('renders with custom color', () => {
    const customColor = '#FF0000';
    render(<IconAdd data-testid="icon" color={customColor} />);
    const icon = screen.getByTestId('icon');
    expect(icon.querySelector('path')).toHaveAttribute('fill', customColor);
  });

  it('spreads additional SVG props', () => {
    render(<IconAdd data-testid="icon" className="custom-class" aria-label="Add icon" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('class', 'custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Add icon');
  });
});
</file>

<file path="src/ui-kit/icons/IconAdd.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconAdd: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M13.1397 6.11362C13.1036 5.47798 13.031 4.84497 12.9222 4.21771C12.8776 4.0349 12.7796 3.86953 12.6407 3.7426C12.5018 3.61568 12.3283 3.53293 12.1423 3.50488C12.0232 3.48441 11.9013 3.48775 11.7835 3.51473C11.6657 3.5417 11.5544 3.59176 11.4561 3.66201C11.3578 3.73227 11.2743 3.82132 11.2106 3.92401C11.1469 4.0267 11.1042 4.141 11.0849 4.26028C10.9764 4.89078 10.9006 5.52645 10.8578 6.16474C10.8267 6.55668 10.821 6.94861 10.8153 7.3386C10.8117 7.58304 10.8082 7.82671 10.7984 8.06914C10.8206 8.68435 10.8427 9.31633 10.8649 9.9651C10.8871 10.2994 10.9183 10.6329 10.9586 10.9653C10.6283 10.9298 10.2956 10.9037 9.96287 10.8777L9.96285 10.8777C9.32425 10.8277 8.68563 10.8114 8.04699 10.8118C7.4243 10.8122 6.80958 10.8366 6.17948 10.8616L6.13106 10.8635C5.49104 10.8991 4.85387 10.9753 4.22341 11.0917C4.01476 11.1352 3.82737 11.2493 3.69279 11.4146C3.55821 11.58 3.48465 11.7867 3.48451 11.9997C3.48436 12.2128 3.55763 12.4193 3.69199 12.5845C3.82634 12.7497 4.01358 12.8635 4.22217 12.9068C4.85359 13.0148 5.49022 13.0901 6.12951 13.1323C6.26794 13.1395 6.40598 13.1479 6.54379 13.1563C7.04173 13.1865 7.53675 13.2165 8.03697 13.1899C8.29981 13.1758 8.56408 13.1718 8.82801 13.1677C9.20536 13.162 9.58204 13.1562 9.95291 13.1213C10.037 13.1134 10.1212 13.1057 10.2055 13.0979C10.4516 13.0752 10.6986 13.0525 10.9456 13.0257C10.8991 13.3711 10.8638 13.718 10.8398 14.0659C10.8337 14.2191 10.8261 14.3737 10.8186 14.5292L10.8186 14.5293C10.795 15.0118 10.7711 15.5016 10.7903 15.9772C10.7988 16.1875 10.8036 16.3997 10.8083 16.6125L10.8083 16.6126C10.8178 17.0359 10.8274 17.4617 10.8666 17.8801C10.9032 18.5152 10.9762 19.1478 11.0854 19.7747C11.1261 19.9581 11.2203 20.1254 11.3562 20.2553C11.4921 20.3853 11.6634 20.4719 11.8486 20.5043C11.9675 20.5249 12.0894 20.5216 12.207 20.4948C12.3247 20.4679 12.4359 20.418 12.5341 20.3478C12.6323 20.2777 12.7156 20.1888 12.7791 20.0862C12.8427 19.9837 12.8853 19.8695 12.9044 19.7503C13.0124 19.1204 13.0876 18.4853 13.1299 17.8475C13.1607 17.456 13.1661 17.0644 13.1715 16.6747L13.1715 16.6746C13.1748 16.4304 13.1782 16.1869 13.1878 15.9447C13.1875 15.3076 13.1704 14.6705 13.1366 14.0334C13.1141 13.6982 13.0825 13.3638 13.0418 13.0304C13.3706 13.0659 13.7019 13.0921 14.0331 13.1182C14.6722 13.1687 15.3112 13.1855 15.9503 13.1855C16.5735 13.1855 17.1886 13.1616 17.8191 13.137L17.8191 13.137L17.8676 13.1351C18.508 13.1 19.1456 13.0242 19.7764 12.9081C19.9852 12.8647 20.1726 12.7507 20.3072 12.5853C20.4418 12.4199 20.5152 12.2132 20.5152 12C20.5152 11.7867 20.4417 11.58 20.3072 11.4146C20.1726 11.2492 19.9851 11.1352 19.7764 11.0918C19.1444 10.9832 18.5073 10.9074 17.8675 10.8647C17.6835 10.855 17.5023 10.8383 17.3217 10.8217C16.8749 10.7807 16.4317 10.7399 15.9587 10.8058C15.5876 10.8574 15.2297 10.8593 14.876 10.861C14.5966 10.8625 14.3198 10.8639 14.0414 10.8898C13.9573 10.8977 13.8731 10.9054 13.7887 10.9131C13.5448 10.9354 13.3 10.9577 13.0552 10.984C13.1028 10.6343 13.139 10.283 13.1636 9.93076C13.1698 9.77745 13.1774 9.62264 13.1851 9.46707L13.1851 9.46705L13.1851 9.46702C13.2091 8.98412 13.2334 8.49384 13.2146 8.01798C13.2062 7.80748 13.2016 7.59511 13.197 7.38212C13.1878 6.95845 13.1786 6.53232 13.1397 6.11362Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconArrowDown.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconArrowDown } from './IconArrowDown';

describe('IconArrowDown Component', () => {
  it('renders with default props', () => {
    render(<IconArrowDown data-testid="icon" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toBeInTheDocument();
    expect(icon.tagName.toLowerCase()).toBe('svg');
    expect(icon).toHaveAttribute('width', '16');
    expect(icon).toHaveAttribute('height', '16');
    expect(icon).toHaveClass('rotate-180');
    expect(icon.querySelector('path')).toHaveAttribute('fill', 'currentColor');
  });

  it('renders with custom size', () => {
    const customSize = 32;
    render(<IconArrowDown data-testid="icon" size={customSize} />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('width', customSize.toString());
    expect(icon).toHaveAttribute('height', customSize.toString());
  });

  it('renders with custom color', () => {
    const customColor = '#FF0000';
    render(<IconArrowDown data-testid="icon" color={customColor} />);
    const icon = screen.getByTestId('icon');
    expect(icon.querySelector('path')).toHaveAttribute('fill', customColor);
  });

  it('spreads additional SVG props while maintaining default class', () => {
    render(
      <IconArrowDown data-testid="icon" className="custom-class" aria-label="Arrow down icon" />
    );
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveClass('rotate-180', 'custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Arrow down icon');
  });
});
</file>

<file path="src/ui-kit/icons/IconArrowDown.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconArrowDown: React.FC<IconProps> = ({
  size = 16,
  color = 'currentColor',
  ...nativeProps
}) => (
  <svg
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...nativeProps}
    className={`rotate-180 ${nativeProps.className || ''}`}
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M9.54105 5.09686C10.1015 4.59372 10.6887 4.12134 11.3003 3.6818C11.4453 3.58807 11.6116 3.5347 11.7824 3.52583C11.8001 3.52168 11.818 3.51801 11.836 3.51485C11.9641 3.49231 12.0954 3.49546 12.2223 3.52411C12.3492 3.55276 12.4691 3.60633 12.5751 3.68173C13.1998 4.06418 13.7352 4.52312 14.2961 5.03305L14.2961 5.03306C14.857 5.54299 15.418 6.05292 15.9406 6.58834C16.0283 6.67816 16.1164 6.76798 16.2045 6.85793L16.2045 6.85793C16.6419 7.30413 17.0822 7.7533 17.4959 8.22012C17.9931 8.78104 18.4903 9.34197 18.9492 9.95389C19.0455 10.136 19.0828 10.3435 19.056 10.5478C19.0292 10.752 18.9396 10.9429 18.7997 11.094C18.6597 11.2452 18.4763 11.3491 18.2747 11.3915C18.0731 11.4339 17.8634 11.4127 17.6744 11.3307C17.0115 10.8973 16.3741 10.4256 15.8004 9.92839C15.2267 9.43121 14.6786 8.90853 14.1431 8.38585C13.8113 8.06194 13.4844 7.72825 13.1624 7.39083C13.1931 7.80637 13.2126 8.22127 13.2126 8.64067C13.2126 9.04908 13.2211 9.45608 13.2296 9.86261C13.2466 10.6742 13.2635 11.484 13.2126 12.2994C13.1701 12.9794 13.1669 13.6554 13.1638 14.3318C13.1613 14.8729 13.1588 15.4143 13.1361 15.9582C13.0851 17.182 13.0341 18.3421 12.9194 19.6169C12.8964 19.8446 12.7947 20.0571 12.6318 20.2177C12.4688 20.3783 12.2549 20.4769 12.027 20.4966C11.7691 20.5181 11.513 20.4383 11.3131 20.274C11.1131 20.1098 10.9851 19.8741 10.9561 19.6169C10.8833 18.8396 10.8464 18.057 10.8096 17.2759C10.7884 16.8273 10.7673 16.3791 10.7394 15.9327C10.6629 14.7088 10.5992 13.4978 10.6629 12.2739C10.6967 11.6261 10.6983 10.9783 10.6998 10.3324C10.7013 9.75802 10.7027 9.18518 10.7267 8.61517C10.7461 8.15296 10.7656 7.69633 10.7893 7.23746C10.4253 7.62919 10.0501 8.00432 9.66854 8.38592C9.13311 8.92135 8.58493 9.43128 8.02401 9.92846C7.4424 10.4288 6.83382 10.897 6.201 11.3308C6.03722 11.4352 5.84704 11.4906 5.65282 11.4906C5.45861 11.4906 5.26843 11.4352 5.10465 11.3308C4.90724 11.1787 4.77411 10.9581 4.73161 10.7126C4.68912 10.467 4.74035 10.2145 4.87518 10.005C5.32137 9.39303 5.8058 8.80661 6.31574 8.25844C6.37767 8.19186 6.43961 8.12509 6.50161 8.05825C6.9501 7.57476 7.40218 7.0874 7.88377 6.6394C8.06747 6.46852 8.24973 6.29478 8.43248 6.12058C8.79509 5.77492 9.15962 5.42744 9.54105 5.09686Z"
      fill={color}
    />
  </svg>
);
</file>

<file path="src/ui-kit/icons/IconArrowDownUp.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconArrowDownUp } from './IconArrowDownUp';

describe('IconArrowDownUp Component', () => {
  it('renders with default props', () => {
    render(<IconArrowDownUp data-testid="icon" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toBeInTheDocument();
    expect(icon.tagName.toLowerCase()).toBe('svg');
    expect(icon).toHaveAttribute('width', '16');
    expect(icon).toHaveAttribute('height', '16');
    expect(icon).toHaveAttribute('viewBox', '0 0 16 16');
    const path = icon.querySelector('path');
    expect(path).toHaveAttribute('stroke', 'currentColor');
    expect(path).toHaveAttribute('stroke-width', '1.5');
    expect(path).toHaveAttribute('stroke-linecap', 'round');
    expect(path).toHaveAttribute('stroke-linejoin', 'round');
  });

  it('renders with custom size', () => {
    const customSize = 32;
    render(<IconArrowDownUp data-testid="icon" size={customSize} />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('width', customSize.toString());
    expect(icon).toHaveAttribute('height', customSize.toString());
  });

  it('renders with custom color', () => {
    const customColor = '#FF0000';
    render(<IconArrowDownUp data-testid="icon" color={customColor} />);
    const icon = screen.getByTestId('icon');
    expect(icon.querySelector('path')).toHaveAttribute('stroke', customColor);
  });

  it('spreads additional SVG props', () => {
    render(
      <IconArrowDownUp data-testid="icon" className="custom-class" aria-label="Arrow up and down" />
    );
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Arrow up and down');
  });
});
</file>

<file path="src/ui-kit/icons/IconArrowDownUp.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconArrowDownUp: React.FC<IconProps> = ({
  size = 16,
  color = 'currentColor',
  ...nativeProps
}) => (
  <svg
    width={size}
    height={size}
    viewBox="0 0 16 16"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...nativeProps}
  >
    <path
      d="M8.0003 6.78065L8.0003 0.847656M8.0003 0.847656L5.17188 3.67608M8.0003 0.847656L10.8287 3.67608M8.0003 9.21855L8.0003 15.1516M8.0003 15.1516L10.8287 12.3231M8.0003 15.1516L5.17188 12.3231"
      stroke={color}
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  </svg>
);
</file>

<file path="src/ui-kit/icons/IconArrowLeft.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconArrowLeft } from './IconArrowLeft';

describe('IconArrowLeft Component', () => {
  it('renders with default props', () => {
    render(<IconArrowLeft data-testid="icon" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toBeInTheDocument();
    expect(icon.tagName.toLowerCase()).toBe('svg');
    expect(icon).toHaveAttribute('width', '16');
    expect(icon).toHaveAttribute('height', '16');
    expect(icon).toHaveAttribute('viewBox', '0 0 16 12');
    expect(icon).toHaveClass('stroke-current');
    const path = icon.querySelector('path');
    expect(path).toHaveAttribute('stroke', 'currentColor');
    expect(path).toHaveAttribute('stroke-width', '2');
    expect(path).toHaveAttribute('stroke-linecap', 'round');
    expect(path).toHaveAttribute('stroke-linejoin', 'round');
  });

  it('renders with custom size', () => {
    const customSize = 32;
    render(<IconArrowLeft data-testid="icon" size={customSize} />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('width', customSize.toString());
    expect(icon).toHaveAttribute('height', customSize.toString());
  });

  it('renders with custom color', () => {
    const customColor = '#FF0000';
    render(<IconArrowLeft data-testid="icon" color={customColor} />);
    const icon = screen.getByTestId('icon');
    expect(icon.querySelector('path')).toHaveAttribute('stroke', customColor);
  });

  it('merges className with default class', () => {
    render(<IconArrowLeft data-testid="icon" className="custom-class" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveClass('stroke-current', 'custom-class');
  });

  it('spreads additional SVG props', () => {
    render(<IconArrowLeft data-testid="icon" aria-label="Left arrow" />);
    const icon = screen.getByTestId('icon');
    expect(icon).toHaveAttribute('aria-label', 'Left arrow');
  });
});
</file>

<file path="src/ui-kit/icons/IconArrowLeft.tsx">
import React from 'react';
import { IconProps } from './types';
import { cn } from '../utils/cn';

export const IconArrowLeft: React.FC<IconProps> = ({
  size = 16,
  color = 'currentColor',
  className,
  ...nativeProps
}) => (
  <svg
    width={size}
    height={size}
    viewBox="0 0 16 12"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    className={cn('stroke-current', className)}
    {...nativeProps}
  >
    <path
      d="M14.6667 6H1.33337M1.33337 6L6.33337 11M1.33337 6L6.33337 1"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  </svg>
);
</file>

<file path="src/ui-kit/icons/IconButton.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { IconButton } from './IconButton';

describe('IconButton Component', () => {
  it('renders with default props', () => {
    render(<IconButton data-testid="icon-button" />);
    const svg = screen.getByTestId('icon-button');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
    expect(svg).toHaveAttribute('fill', 'none');
  });

  it('renders with custom size and color', () => {
    render(<IconButton size={32} color="#FF0000" data-testid="icon-button" />);
    const svg = screen.getByTestId('icon-button');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');

    const strokes = svg.querySelectorAll('[stroke="#FF0000"]');
    const fills = svg.querySelectorAll('[fill="#FF0000"]');
    expect(strokes.length).toBeGreaterThan(0);
    expect(fills.length).toBeGreaterThan(0);
  });

  it('passes additional SVG props', () => {
    render(
      <IconButton data-testid="icon-button" className="custom-icon" aria-label="Button Icon" />
    );
    const svg = screen.getByTestId('icon-button');

    expect(svg).toHaveAttribute('data-testid', 'icon-button');
    expect(svg).toHaveClass('custom-icon');
    expect(svg).toHaveAttribute('aria-label', 'Button Icon');
  });

  it('has correct SVG structure', () => {
    render(<IconButton data-testid="icon-button" />);
    const svg = screen.getByTestId('icon-button');

    const rects = svg.querySelectorAll('rect');
    expect(rects.length).toBe(3);

    // Check the main background rect
    const backgroundRect = rects[0];
    expect(backgroundRect).toHaveAttribute('x', '2');
    expect(backgroundRect).toHaveAttribute('y', '8');
    expect(backgroundRect).toHaveAttribute('width', '20');
    expect(backgroundRect).toHaveAttribute('height', '8');
    expect(backgroundRect).toHaveAttribute('rx', '4');
  });
});
</file>

<file path="src/ui-kit/icons/IconButton.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconButton: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <rect x="2" y="8" width="20" height="8" rx="4" stroke={color} strokeWidth="2" />
      <rect x="10" y="11" width="9" height="2" rx="1" fill={color} />
      <rect x="5" y="11" width="3" height="2" rx="1" fill={color} />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconCheck.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconCheck } from './IconCheck';

describe('IconCheck Component', () => {
  it('renders with default props', () => {
    render(<IconCheck data-testid="check-icon" />);
    const svg = screen.getByTestId('check-icon');
    const path = svg.querySelector('path');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 20 20');
    expect(path).toHaveAttribute('stroke', 'currentColor');
  });

  it('renders with custom size', () => {
    render(<IconCheck size={32} data-testid="check-icon" />);
    const svg = screen.getByTestId('check-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconCheck color="red" data-testid="check-icon" />);
    const path = screen.getByTestId('check-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('applies custom className', () => {
    render(<IconCheck data-testid="check-icon" className="custom-class" />);
    const svg = screen.getByTestId('check-icon');

    expect(svg).toHaveClass('custom-class');
  });

  it('passes through additional native props', () => {
    render(<IconCheck data-testid="check-icon" className="custom-class" aria-label="Check" />);
    const svg = screen.getByTestId('check-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Check');
  });
});
</file>

<file path="src/ui-kit/icons/IconCheck.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconCheck: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  className = '',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      className={className}
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M16.6666 5L7.49992 14.1667L3.33325 10"
        stroke={color}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconCopy.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { IconCopy } from './IconCopy';

describe('IconCopy Component', () => {
  it('renders with default props', () => {
    render(<IconCopy data-testid="icon-copy" />);
    const svg = screen.getByTestId('icon-copy');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 20 21');
    expect(svg).toHaveAttribute('fill', 'none');
  });

  it('renders with custom size and color', () => {
    render(<IconCopy size={32} color="#FF0000" data-testid="icon-copy" />);
    const svg = screen.getByTestId('icon-copy');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');

    const strokes = svg.querySelectorAll('[stroke="#FF0000"]');
    expect(strokes.length).toBeGreaterThan(0);
  });

  it('passes additional SVG props', () => {
    render(<IconCopy data-testid="icon-copy" className="custom-icon" aria-label="Copy Icon" />);
    const svg = screen.getByTestId('icon-copy');

    expect(svg).toHaveAttribute('data-testid', 'icon-copy');
    expect(svg).toHaveClass('custom-icon');
    expect(svg).toHaveAttribute('aria-label', 'Copy Icon');
  });

  it('has correct SVG structure', () => {
    render(<IconCopy data-testid="icon-copy" />);
    const svg = screen.getByTestId('icon-copy');

    const paths = svg.querySelectorAll('path');
    expect(paths.length).toBe(1);

    const path = paths[0];
    expect(path.getAttribute('stroke')).toBe('currentColor');
    expect(path.getAttribute('stroke-width')).toBe('2');
    expect(path.getAttribute('stroke-linecap')).toBe('round');
    expect(path.getAttribute('stroke-linejoin')).toBe('round');
  });
});
</file>

<file path="src/ui-kit/icons/IconCopy.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconCopy: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 20 21"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M6.66666 7.16675V4.83341C6.66666 3.89999 6.66666 3.43328 6.84831 3.07676C7.0081 2.76316 7.26307 2.50819 7.57667 2.3484C7.93319 2.16675 8.3999 2.16675 9.33332 2.16675H15.6667C16.6001 2.16675 17.0668 2.16675 17.4233 2.3484C17.7369 2.50819 17.9919 2.76316 18.1517 3.07676C18.3333 3.43328 18.3333 3.89999 18.3333 4.83341V11.1667C18.3333 12.1002 18.3333 12.5669 18.1517 12.9234C17.9919 13.237 17.7369 13.492 17.4233 13.6518C17.0668 13.8334 16.6001 13.8334 15.6667 13.8334H13.3333M4.33332 18.8334H10.6667C11.6001 18.8334 12.0668 18.8334 12.4233 18.6518C12.7369 18.492 12.9919 18.237 13.1517 17.9234C13.3333 17.5669 13.3333 17.1002 13.3333 16.1667V9.83341C13.3333 8.89999 13.3333 8.43328 13.1517 8.07676C12.9919 7.76316 12.7369 7.50819 12.4233 7.3484C12.0668 7.16675 11.6001 7.16675 10.6667 7.16675H4.33332C3.3999 7.16675 2.93319 7.16675 2.57667 7.3484C2.26307 7.50819 2.0081 7.76316 1.84831 8.07676C1.66666 8.43328 1.66666 8.89999 1.66666 9.83341V16.1667C1.66666 17.1002 1.66666 17.5669 1.84831 17.9234C2.0081 18.237 2.26307 18.492 2.57667 18.6518C2.93319 18.8334 3.3999 18.8334 4.33332 18.8334Z"
        stroke={color}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconCreate.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { IconCreate } from './IconCreate';

describe('IconCreate Component', () => {
  it('renders with default props', () => {
    render(<IconCreate data-testid="icon-create" />);
    const svg = screen.getByTestId('icon-create');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
    expect(svg).toHaveAttribute('fill', 'none');
  });

  it('renders with custom size and color', () => {
    render(<IconCreate size={32} color="#FF0000" data-testid="icon-create" />);
    const svg = screen.getByTestId('icon-create');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');

    const strokes = svg.querySelectorAll('[stroke="#FF0000"]');
    expect(strokes.length).toBeGreaterThan(0);
  });

  it('passes additional SVG props', () => {
    render(
      <IconCreate data-testid="icon-create" className="custom-icon" aria-label="Create Icon" />
    );
    const svg = screen.getByTestId('icon-create');

    expect(svg).toHaveAttribute('data-testid', 'icon-create');
    expect(svg).toHaveClass('custom-icon');
    expect(svg).toHaveAttribute('aria-label', 'Create Icon');
  });

  it('has correct SVG structure', () => {
    render(<IconCreate data-testid="icon-create" />);
    const svg = screen.getByTestId('icon-create');

    const paths = svg.querySelectorAll('path');
    expect(paths.length).toBe(1);

    const path = paths[0];
    expect(path.getAttribute('stroke')).toBe('currentColor');
    expect(path.getAttribute('stroke-width')).toBe('2');
    expect(path.getAttribute('stroke-linecap')).toBe('round');
    expect(path.getAttribute('stroke-linejoin')).toBe('round');
  });
});
</file>

<file path="src/ui-kit/icons/IconCreate.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconCreate: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="M4.5 22v-5m0-10V2M2 4.5h5m-5 15h5M13 3l-1.734 4.509c-.282.733-.423 1.1-.643 1.408a3 3 0 0 1-.706.707c-.308.219-.675.36-1.408.642L4 12l4.509 1.734c.733.282 1.1.423 1.408.643.273.194.512.433.707.706.219.308.36.675.642 1.408L13 21l1.734-4.509c.282-.733.423-1.1.643-1.408.194-.273.433-.512.706-.707.308-.219.675-.36 1.408-.642L22 12l-4.509-1.734c-.733-.282-1.1-.423-1.408-.642a3 3 0 0 1-.706-.707c-.22-.308-.36-.675-.643-1.408L13 3Z"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconDelete.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconDelete } from './IconDelete';

describe('IconDelete Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconDelete data-testid="delete-icon" />);
    const svg = getByTestId('delete-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    const { getByTestId } = render(<IconDelete size={32} data-testid="delete-icon" />);
    const svg = getByTestId('delete-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    const { container } = render(<IconDelete color="red" data-testid="delete-icon" />);
    const path = container.querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    const { getByTestId } = render(
      <IconDelete data-testid="delete-icon" className="custom-class" aria-label="Delete" />
    );
    const svg = getByTestId('delete-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Delete');
  });
});
</file>

<file path="src/ui-kit/icons/IconDelete.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconDelete: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="M16 6v-.8c0-1.12 0-1.68-.218-2.108a2 2 0 0 0-.874-.874C14.48 2 13.92 2 12.8 2h-1.6c-1.12 0-1.68 0-2.108.218a2 2 0 0 0-.874.874C8 3.52 8 4.08 8 5.2V6m2 5.5v5m4-5v5M3 6h18m-2 0v11.2c0 1.68 0 2.52-.327 3.162a3 3 0 0 1-1.311 1.311C16.72 22 15.88 22 14.2 22H9.8c-1.68 0-2.52 0-3.162-.327a3 3 0 0 1-1.311-1.311C5 19.72 5 18.88 5 17.2V6"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconDownload.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconDownload } from './IconDownload';

describe('IconDownload Component', () => {
  it('renders with default props', () => {
    render(<IconDownload data-testid="download-icon" />);
    const svg = screen.getByTestId('download-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    render(<IconDownload size={32} data-testid="download-icon" />);
    const svg = screen.getByTestId('download-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconDownload color="red" data-testid="download-icon" />);
    const path = screen.getByTestId('download-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    render(
      <IconDownload data-testid="download-icon" className="custom-class" aria-label="Download" />
    );
    const svg = screen.getByTestId('download-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Download');
  });
});
</file>

<file path="src/ui-kit/icons/IconDownload.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconDownload: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="M21 15v1.2c0 1.68 0 2.52-.327 3.162a3 3 0 0 1-1.311 1.311C18.72 21 17.88 21 16.2 21H7.8c-1.68 0-2.52 0-3.162-.327a3 3 0 0 1-1.311-1.311C3 18.72 3 17.88 3 16.2V15m14-5-5 5m0 0-5-5m5 5V3"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconEdit.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconEdit } from './IconEdit';

describe('IconEdit Component', () => {
  it('renders with default props', () => {
    render(<IconEdit data-testid="edit-icon" />);
    const svg = screen.getByTestId('edit-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 20 20');
  });

  it('renders with custom size', () => {
    render(<IconEdit size={32} data-testid="edit-icon" />);
    const svg = screen.getByTestId('edit-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconEdit color="red" data-testid="edit-icon" />);
    const path = screen.getByTestId('edit-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    render(<IconEdit data-testid="edit-icon" className="custom-class" aria-label="Edit" />);
    const svg = screen.getByTestId('edit-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Edit');
  });
});
</file>

<file path="src/ui-kit/icons/IconEdit.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconEdit: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <g clipPath="url(#clip0_16548_40098)">
        <path
          d="M15.0003 1.66602L18.3337 4.99935M1.66699 18.3327L2.73066 14.4326C2.80005 14.1781 2.83475 14.0509 2.88802 13.9323C2.93531 13.8269 2.99343 13.7268 3.06142 13.6334C3.138 13.5283 3.23125 13.4351 3.41775 13.2486L12.0289 4.63742C12.1939 4.47241 12.2764 4.38991 12.3716 4.359C12.4553 4.33181 12.5454 4.33181 12.6291 4.359C12.7242 4.38991 12.8067 4.47241 12.9717 4.63742L15.3623 7.02794C15.5273 7.19295 15.6098 7.27545 15.6407 7.37059C15.6679 7.45428 15.6679 7.54442 15.6407 7.62811C15.6098 7.72324 15.5273 7.80575 15.3623 7.97075L6.75108 16.5819C6.56458 16.7684 6.47134 16.8617 6.36623 16.9382C6.2729 17.0062 6.17276 17.0644 6.06742 17.1117C5.94878 17.1649 5.82156 17.1996 5.56711 17.269L1.66699 18.3327Z"
          stroke={color}
          strokeWidth="1.67643"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </g>
      <defs>
        <clipPath id="clip0_16548_40098">
          <rect width="20" height="20" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconError.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconError } from './IconError';

describe('IconError Component', () => {
  it('renders with default props', () => {
    render(<IconError data-testid="error-icon" />);
    const svg = screen.getByTestId('error-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '80');
    expect(svg).toHaveAttribute('height', '80');
    expect(svg).toHaveAttribute('viewBox', '0 0 80 80');
  });

  it('renders with custom size', () => {
    render(<IconError size={100} data-testid="error-icon" />);
    const svg = screen.getByTestId('error-icon');

    expect(svg).toHaveAttribute('width', '100');
    expect(svg).toHaveAttribute('height', '100');
  });

  it('renders with correct colors and shapes', () => {
    render(<IconError data-testid="error-icon" />);
    const svg = screen.getByTestId('error-icon');
    const [outerRect, innerRect] = svg.querySelectorAll('rect');
    const path = svg.querySelector('path');

    expect(outerRect).toHaveAttribute('fill', '#FFF2E8');
    expect(innerRect).toHaveAttribute('fill', '#FF4A32');
    expect(path).toHaveAttribute('stroke', 'white');
  });

  it('passes through additional native props', () => {
    render(<IconError data-testid="error-icon" className="custom-class" aria-label="Error" />);
    const svg = screen.getByTestId('error-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Error');
  });
});
</file>

<file path="src/ui-kit/icons/IconError.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconError: React.FC<IconProps> = ({ size = 80, ...nativeProps }) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 80 80"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <rect width="80" height="80" rx="40" fill="#FFF2E8" />
      <rect x="14" y="14" width="52" height="52" rx="26" fill="#FF4A32" />
      <path
        d="M47 33L33 47M33 33L47 47"
        stroke="white"
        strokeWidth="2.5"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconHelp.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconHelp } from './IconHelp';

describe('IconHelp Component', () => {
  it('renders with default props', () => {
    render(<IconHelp data-testid="help-icon" />);
    const svg = screen.getByTestId('help-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    render(<IconHelp size={32} data-testid="help-icon" />);
    const svg = screen.getByTestId('help-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconHelp color="red" data-testid="help-icon" />);
    const paths = screen.getByTestId('help-icon').querySelectorAll('path');
    paths.forEach(path => {
      const hasStroke = path.hasAttribute('stroke');
      const hasFill = path.hasAttribute('fill');
      if (hasStroke) expect(path).toHaveAttribute('stroke', 'red');
      if (hasFill) expect(path).toHaveAttribute('fill', 'red');
    });
  });

  it('passes through additional native props', () => {
    render(<IconHelp data-testid="help-icon" className="custom-class" aria-label="Help" />);
    const svg = screen.getByTestId('help-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Help');
  });
});
</file>

<file path="src/ui-kit/icons/IconHelp.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconHelp: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeWidth="2"
        d="m6.346 20.234-.022-.01-.022-.008c-1.167-.464-1.952-1.209-2.477-2.443-.55-1.293-.825-3.15-.825-5.83 0-3.98.711-6.089 1.985-7.265C6.278 3.483 8.41 3 11.955 3c3.592 0 5.747.484 7.052 1.68C20.289 5.856 21 7.963 21 11.944c0 3.82-.706 5.977-2.009 7.225C17.678 20.426 15.513 21 11.955 21c-2.553 0-4.384-.21-5.61-.766Z"
      />
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeMiterlimit="10"
        strokeWidth="2"
        d="M8.66 10.155c-.336-2.916 2.917-3.702 5.273-2.804 1.57.673 1.907 3.029.56 4.038-.672.561-1.794.561-1.906 1.57v1.347"
      />
      <path
        fill={color}
        d="M11.919 17.853c-.308-.293-.308-1.366 0-1.56.308-.294 1.23-.294 1.538 0 .308.292.308 1.267 0 1.56-.205.293-1.23.293-1.538 0Z"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconLike.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconLike } from './IconLike';

describe('IconLike Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconLike data-testid="like-icon" />);
    const icon = getByTestId('like-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 24 24');

    // Check stroke color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('stroke', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(<IconLike data-testid="like-icon" size={32} color="#FF0000" />);
    const icon = getByTestId('like-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('stroke', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconLike data-testid="like-icon" className="custom-class" aria-label="Like Icon" />
    );
    const icon = getByTestId('like-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Like Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconLike data-testid="like-icon" />);
    const icon = getByTestId('like-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(2);
  });
});
</file>

<file path="src/ui-kit/icons/IconLike.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconLike: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M7.48047 18.35L10.5805 20.75C10.9805 21.15 11.8805 21.35 12.4805 21.35L16.2805 21.35C17.4805 21.35 18.7805 20.45 19.0805 19.25L21.4805 11.95C21.9805 10.55 21.0805 9.34997 19.5805 9.34997L15.5805 9.34997C14.9805 9.34997 14.4805 8.84997 14.5805 8.14997L15.0805 4.94997C15.2805 4.04997 14.6805 3.04997 13.7805 2.74997C12.9805 2.44997 11.9805 2.84997 11.5805 3.44997L7.48047 9.54997"
        stroke={color}
        strokeWidth="1.8"
        strokeMiterlimit="10"
      />
      <path
        d="M2.37988 18.3499L2.37988 8.5499C2.37988 7.1499 2.97988 6.6499 4.37988 6.6499L5.37988 6.6499C6.77988 6.6499 7.37988 7.1499 7.37988 8.5499L7.37988 18.3499C7.37988 19.7499 6.77988 20.2499 5.37988 20.2499L4.37988 20.2499C2.97988 20.2499 2.37988 19.7499 2.37988 18.3499Z"
        stroke={color}
        strokeWidth="1.8"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconLogo.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconLogo } from './IconLogo';

describe('IconLogo Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconLogo data-testid="logo-icon" />);
    const icon = getByTestId('logo-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 24 24');

    // Check fill color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(<IconLogo data-testid="logo-icon" size={32} color="#FF0000" />);
    const icon = getByTestId('logo-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconLogo data-testid="logo-icon" className="custom-class" aria-label="Logo Icon" />
    );
    const icon = getByTestId('logo-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Logo Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconLogo data-testid="logo-icon" />);
    const icon = getByTestId('logo-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(1);
  });

  it('has correct path attributes', () => {
    const { getByTestId } = render(<IconLogo data-testid="logo-icon" />);
    const icon = getByTestId('logo-icon');
    const path = icon.querySelector('path');

    // Check if the attributes are present in the path's attributes
    expect(path).toHaveAttribute('fill-rule', 'evenodd');
    expect(path).toHaveAttribute('clip-rule', 'evenodd');
  });
});
</file>

<file path="src/ui-kit/icons/IconLogo.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconLogo: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M13.7757 1.99902H10.2314V7.7235L6.18208 3.67414L3.67588 6.18034L7.72246 10.2269H2V13.7712H7.7253L3.67915 17.8174L6.18535 20.3236L10.2314 16.2775V21.999H13.7757V16.2802L17.818 20.3225L20.3242 17.8163L16.2792 13.7712H22V10.2269H16.282L20.3275 6.18143L17.8213 3.67523L13.7757 7.72077V1.99902Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconMenu.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconMenu } from './IconMenu';

describe('IconMenu Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconMenu data-testid="menu-icon" />);
    const icon = getByTestId('menu-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 24 24');

    // Check fill color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(<IconMenu data-testid="menu-icon" size={32} color="#FF0000" />);
    const icon = getByTestId('menu-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconMenu data-testid="menu-icon" className="custom-class" aria-label="Menu Icon" />
    );
    const icon = getByTestId('menu-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Menu Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconMenu data-testid="menu-icon" />);
    const icon = getByTestId('menu-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(3);
  });

  it('has correct path fill attributes', () => {
    const { getByTestId } = render(<IconMenu data-testid="menu-icon" />);
    const icon = getByTestId('menu-icon');
    const paths = icon.querySelectorAll('path');

    paths.forEach(path => {
      expect(path).toHaveAttribute('fill');
    });
  });
});
</file>

<file path="src/ui-kit/icons/IconMenu.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconMenu: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M3.59986 4.22402C4.40386 4.11602 5.20786 4.06802 5.99986 4.02002C6.79186 3.97202 11.2079 4.02002 11.9999 3.94802C12.7919 3.87602 17.1959 3.94802 17.9999 3.94802C18.8039 3.94802 19.6079 4.04402 20.3999 4.16402C20.6252 4.18983 20.8333 4.29765 20.9843 4.46694C21.1353 4.63623 21.2187 4.85516 21.2187 5.08202C21.2187 5.30887 21.1353 5.5278 20.9843 5.69709C20.8333 5.86638 20.6252 5.97421 20.3999 6.00002C19.6043 6.11718 18.8032 6.19328 17.9999 6.22802C17.1959 6.22802 12.7919 6.22802 11.9999 6.22802C11.2079 6.22802 6.79186 6.22802 5.99986 6.15602C5.20786 6.08402 4.39186 6.06002 3.59986 5.94002C3.47849 5.92535 3.36132 5.88644 3.2553 5.82559C3.14927 5.76474 3.05656 5.68319 2.98268 5.5858C2.9088 5.48841 2.85525 5.37716 2.82522 5.25866C2.79518 5.14017 2.78928 5.01684 2.80786 4.89602C2.85876 4.71832 2.96114 4.55967 3.10209 4.44008C3.24304 4.32049 3.41624 4.24531 3.59986 4.22402V4.22402Z"
        fill={color}
      />
      <path
        d="M3.60028 11.076C4.40428 10.968 5.20828 10.92 6.00028 10.872C6.79228 10.824 11.2083 10.8 12.0003 10.8C12.7923 10.8 17.1963 10.8 18.0003 10.86C18.8043 10.92 19.6083 10.956 20.4003 11.076C20.6438 11.1174 20.8616 11.2521 21.0073 11.4516C21.1529 11.651 21.215 11.8995 21.1803 12.144C21.1446 12.3378 21.0509 12.5161 20.9116 12.6554C20.7723 12.7947 20.594 12.8884 20.4003 12.924C19.5963 13.044 18.7923 13.092 18.0003 13.14C17.2083 13.188 12.7923 13.14 12.0003 13.2C11.2083 13.26 6.79228 13.2 6.00028 13.128C5.20828 13.056 4.39228 13.032 3.60028 12.924C3.38078 12.8886 3.18109 12.7761 3.03696 12.6068C2.89283 12.4375 2.81367 12.2224 2.81367 12C2.81367 11.7777 2.89283 11.5626 3.03696 11.3933C3.18109 11.224 3.38078 11.1115 3.60028 11.076Z"
        fill={color}
      />
      <path
        d="M3.60025 18.0001C4.40425 17.8801 5.20825 17.8321 6.00025 17.7841C6.79225 17.7361 11.2083 17.7841 12.0003 17.7121C12.7923 17.6401 17.1963 17.7121 18.0003 17.7121C18.8047 17.7667 19.6057 17.8628 20.4003 18.0001C20.5211 18.0176 20.6372 18.059 20.7419 18.1217C20.8466 18.1844 20.9379 18.2673 21.0104 18.3654C21.0829 18.4636 21.1353 18.5752 21.1644 18.6938C21.1936 18.8123 21.199 18.9354 21.1803 19.0561C21.1462 19.2505 21.053 19.4297 20.9135 19.5693C20.7739 19.7088 20.5947 19.802 20.4003 19.8361C19.5963 19.9561 18.7923 20.0041 18.0003 20.0521C17.2083 20.1001 12.7923 20.0521 12.0003 20.1121C11.2083 20.1721 6.79225 20.1121 6.00025 20.0401C5.20825 19.9681 4.39225 19.9441 3.60025 19.8361C3.35787 19.8003 3.13916 19.671 2.99108 19.4758C2.843 19.2806 2.77736 19.0351 2.80825 18.7921C2.83338 18.5908 2.92491 18.4036 3.06835 18.2601C3.21179 18.1167 3.39896 18.0252 3.60025 18.0001V18.0001Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconMinus.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconMinus } from './IconMinus';

describe('IconMinus Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconMinus data-testid="minus-icon" />);
    const icon = getByTestId('minus-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 24 24');

    // Check fill color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(
      <IconMinus data-testid="minus-icon" size={32} color="#FF0000" />
    );
    const icon = getByTestId('minus-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconMinus data-testid="minus-icon" className="custom-class" aria-label="Minus Icon" />
    );
    const icon = getByTestId('minus-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Minus Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconMinus data-testid="minus-icon" />);
    const icon = getByTestId('minus-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(1);
  });

  it('has correct path fill attributes', () => {
    const { getByTestId } = render(<IconMinus data-testid="minus-icon" />);
    const icon = getByTestId('minus-icon');
    const paths = icon.querySelectorAll('path');

    paths.forEach(path => {
      expect(path).toHaveAttribute('fill');
    });
  });
});
</file>

<file path="src/ui-kit/icons/IconMinus.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconMinus: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M19.8019 12.9015C19.1716 13.0112 18.5329 13.0621 17.9026 13.1213C17.2723 13.1806 12.6253 13.1558 11.9867 13.1899C11.348 13.2239 6.71783 13.1655 6.07922 13.1323C5.43993 13.0901 4.80329 13.0148 4.17188 12.9068C3.96328 12.8635 3.77605 12.7497 3.6417 12.5845C3.50734 12.4193 3.43407 12.2128 3.43421 11.9997C3.43436 11.7867 3.50791 11.58 3.64249 11.4146C3.77707 11.2493 3.96446 11.1352 4.17312 11.0917C4.80357 10.9753 5.44074 10.8991 6.08077 10.8635C6.72782 10.8379 11.3581 10.8122 11.9967 10.8118C12.6353 10.8113 17.274 10.8277 17.9126 10.8777C18.5512 10.9277 19.1898 10.9777 19.8115 11.0949C20.0515 11.1384 20.2645 11.2748 20.4044 11.4745C20.5442 11.6742 20.5997 11.921 20.5586 12.1616C20.5245 12.348 20.4334 12.5193 20.2978 12.6518C20.1623 12.7844 19.989 12.8716 19.8019 12.9015Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconPlus.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconPlus } from './IconPlus';

describe('IconPlus Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconPlus data-testid="plus-icon" />);
    const icon = getByTestId('plus-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 24 24');

    // Check fill color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(<IconPlus data-testid="plus-icon" size={32} color="#FF0000" />);
    const icon = getByTestId('plus-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('fill', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconPlus data-testid="plus-icon" className="custom-class" aria-label="Plus Icon" />
    );
    const icon = getByTestId('plus-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveAttribute('aria-label', 'Plus Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconPlus data-testid="plus-icon" />);
    const icon = getByTestId('plus-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(1);
  });

  it('has correct path attributes', () => {
    const { getByTestId } = render(<IconPlus data-testid="plus-icon" />);
    const icon = getByTestId('plus-icon');
    const path = icon.querySelector('path');

    expect(path).toHaveAttribute('fill-rule', 'evenodd');
    expect(path).toHaveAttribute('clip-rule', 'evenodd');
  });
});
</file>

<file path="src/ui-kit/icons/IconPlus.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconPlus: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M13.1397 6.11362C13.1036 5.47798 13.031 4.84497 12.9222 4.21771C12.8776 4.0349 12.7796 3.86953 12.6407 3.7426C12.5018 3.61568 12.3283 3.53293 12.1423 3.50488C12.0232 3.48441 11.9013 3.48775 11.7835 3.51473C11.6657 3.5417 11.5544 3.59176 11.4561 3.66201C11.3578 3.73227 11.2743 3.82132 11.2106 3.92401C11.1469 4.0267 11.1042 4.141 11.0849 4.26028C10.9764 4.89078 10.9006 5.52645 10.8578 6.16474C10.8267 6.55668 10.821 6.94861 10.8153 7.3386C10.8117 7.58304 10.8082 7.82671 10.7984 8.06914C10.8206 8.68435 10.8427 9.31633 10.8649 9.9651C10.8871 10.2994 10.9183 10.6329 10.9586 10.9653C10.6283 10.9298 10.2956 10.9037 9.96287 10.8777L9.96285 10.8777C9.32425 10.8277 8.68563 10.8114 8.04699 10.8118C7.4243 10.8122 6.80958 10.8366 6.17948 10.8616L6.13106 10.8635C5.49104 10.8991 4.85387 10.9753 4.22341 11.0917C4.01476 11.1352 3.82737 11.2493 3.69279 11.4146C3.55821 11.58 3.48465 11.7867 3.48451 11.9997C3.48436 12.2128 3.55763 12.4193 3.69199 12.5845C3.82634 12.7497 4.01358 12.8635 4.22217 12.9068C4.85359 13.0148 5.49022 13.0901 6.12951 13.1323C6.26794 13.1395 6.40598 13.1479 6.54379 13.1563C7.04173 13.1865 7.53675 13.2165 8.03697 13.1899C8.29981 13.1758 8.56408 13.1718 8.82801 13.1677C9.20536 13.162 9.58204 13.1562 9.95291 13.1213C10.037 13.1134 10.1212 13.1057 10.2055 13.0979C10.4516 13.0752 10.6986 13.0525 10.9456 13.0257C10.8991 13.3711 10.8638 13.718 10.8398 14.0659C10.8337 14.2191 10.8261 14.3737 10.8186 14.5292L10.8186 14.5293C10.795 15.0118 10.7711 15.5016 10.7903 15.9772C10.7988 16.1875 10.8036 16.3997 10.8083 16.6125L10.8083 16.6126C10.8178 17.0359 10.8274 17.4617 10.8666 17.8801C10.9032 18.5152 10.9762 19.1478 11.0854 19.7747C11.1261 19.9581 11.2203 20.1254 11.3562 20.2553C11.4921 20.3853 11.6634 20.4719 11.8486 20.5043C11.9675 20.5249 12.0894 20.5216 12.207 20.4948C12.3247 20.4679 12.4359 20.418 12.5341 20.3478C12.6323 20.2777 12.7156 20.1888 12.7791 20.0862C12.8427 19.9837 12.8853 19.8695 12.9044 19.7503C13.0124 19.1204 13.0876 18.4853 13.1299 17.8475C13.1607 17.456 13.1661 17.0644 13.1715 16.6747L13.1715 16.6746C13.1748 16.4304 13.1782 16.1869 13.1878 15.9447C13.1875 15.3076 13.1704 14.6705 13.1366 14.0334C13.1141 13.6982 13.0825 13.3638 13.0418 13.0304C13.3706 13.0659 13.7019 13.0921 14.0331 13.1182C14.6722 13.1687 15.3112 13.1855 15.9503 13.1855C16.5735 13.1855 17.1886 13.1616 17.8191 13.137L17.8191 13.137L17.8676 13.1351C18.508 13.1 19.1456 13.0242 19.7764 12.9081C19.9852 12.8647 20.1726 12.7507 20.3072 12.5853C20.4418 12.4199 20.5152 12.2132 20.5152 12C20.5152 11.7867 20.4417 11.58 20.3072 11.4146C20.1726 11.2492 19.9851 11.1352 19.7764 11.0918C19.1444 10.9832 18.5073 10.9074 17.8675 10.8647C17.6835 10.855 17.5023 10.8383 17.3217 10.8217C16.8749 10.7807 16.4317 10.7399 15.9587 10.8058C15.5876 10.8574 15.2297 10.8593 14.876 10.861C14.5966 10.8625 14.3198 10.8639 14.0414 10.8898C13.9573 10.8977 13.8731 10.9054 13.7887 10.9131C13.5448 10.9354 13.3 10.9577 13.0552 10.984C13.1028 10.6343 13.139 10.283 13.1636 9.93076C13.1698 9.77745 13.1774 9.62264 13.1851 9.46707L13.1851 9.46705L13.1851 9.46702C13.2091 8.98412 13.2334 8.49384 13.2146 8.01798C13.2062 7.80748 13.2016 7.59511 13.197 7.38212C13.1878 6.95845 13.1786 6.53232 13.1397 6.11362Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconRedo.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { IconRedo } from './IconRedo';

describe('IconRedo Component', () => {
  it('renders with default props', () => {
    const { getByTestId } = render(<IconRedo data-testid="redo-icon" />);
    const icon = getByTestId('redo-icon');

    // Check SVG attributes
    expect(icon).toHaveAttribute('width', '24');
    expect(icon).toHaveAttribute('height', '24');
    expect(icon).toHaveAttribute('viewBox', '0 0 16 16');

    // Check default class
    expect(icon).toHaveClass('stroke-current');

    // Check stroke color is currentColor by default
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('stroke', 'currentColor');
    });
  });

  it('renders with custom size and color', () => {
    const { getByTestId } = render(<IconRedo data-testid="redo-icon" size={32} color="#FF0000" />);
    const icon = getByTestId('redo-icon');

    // Check custom size
    expect(icon).toHaveAttribute('width', '32');
    expect(icon).toHaveAttribute('height', '32');

    // Check custom color
    const paths = icon.querySelectorAll('path');
    paths.forEach(path => {
      expect(path).toHaveAttribute('stroke', '#FF0000');
    });
  });

  it('passes through additional SVG props', () => {
    const { getByTestId } = render(
      <IconRedo data-testid="redo-icon" className="custom-class" aria-label="Redo Icon" />
    );
    const icon = getByTestId('redo-icon');

    expect(icon).toHaveClass('custom-class');
    expect(icon).toHaveClass('stroke-current');
    expect(icon).toHaveAttribute('aria-label', 'Redo Icon');
  });

  it('has correct number of paths', () => {
    const { getByTestId } = render(<IconRedo data-testid="redo-icon" />);
    const icon = getByTestId('redo-icon');
    const paths = icon.querySelectorAll('path');

    expect(paths.length).toBe(1);
  });

  it('has correct path attributes', () => {
    const { getByTestId } = render(<IconRedo data-testid="redo-icon" />);
    const icon = getByTestId('redo-icon');
    const path = icon.querySelector('path');

    expect(path).toHaveAttribute('stroke-width', '2');
    expect(path).toHaveAttribute('stroke-linecap', 'round');
    expect(path).toHaveAttribute('stroke-linejoin', 'round');
  });

  it('combines className with default stroke class', () => {
    const { getByTestId } = render(<IconRedo data-testid="redo-icon" className="test-class" />);
    const icon = getByTestId('redo-icon');

    expect(icon).toHaveClass('stroke-current');
    expect(icon).toHaveClass('test-class');
  });
});
</file>

<file path="src/ui-kit/icons/IconRedo.tsx">
import React from 'react';
import { IconProps } from './types';
import { cn } from '../utils/cn';

export const IconRedo: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  className,
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn('stroke-current', className)}
      {...nativeProps}
    >
      <path
        d="M14.6667 4.83333H6.33337C3.57195 4.83333 1.33337 7.07191 1.33337 9.83333C1.33337 12.5948 3.57195 14.8333 6.33337 14.8333H14.6667M14.6667 4.83333L11.3334 1.5M14.6667 4.83333L11.3334 8.16667"
        stroke={color}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconReload.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconReload } from './IconReload';

describe('IconReload Component', () => {
  it('renders with default props', () => {
    render(<IconReload data-testid="reload-icon" />);
    const svg = screen.getByTestId('reload-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 16 16');
  });

  it('renders with custom size', () => {
    render(<IconReload size={32} data-testid="reload-icon" />);
    const svg = screen.getByTestId('reload-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconReload color="red" data-testid="reload-icon" />);
    const paths = screen.getByTestId('reload-icon').querySelectorAll('path');

    paths.forEach(path => {
      const fillOrStroke = path.hasAttribute('stroke') ? 'stroke' : 'fill';
      expect(path).toHaveAttribute(fillOrStroke, 'red');
    });
  });

  it('passes through additional native props', () => {
    render(<IconReload data-testid="reload-icon" className="custom-class" aria-label="Reload" />);
    const svg = screen.getByTestId('reload-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Reload');
  });
});
</file>

<file path="src/ui-kit/icons/IconReload.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconReload: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        d="M14.7508 2.59177C14.8428 2.94671 14.8954 3.30166 14.9348 3.66975C14.9742 4.02469 14.9874 4.37964 14.9874 4.74773C14.9874 5.10267 14.9742 5.45762 14.9348 5.82571C14.8954 6.18065 14.8428 6.5356 14.7376 6.89054C14.6062 7.31122 14.1592 7.56099 13.7385 7.44268C13.4624 7.3638 13.2653 7.14032 13.1864 6.89054C13.0812 6.5356 13.0286 6.18065 13.0023 5.81256C12.9629 5.45762 12.9629 5.10267 12.9629 4.73458C12.9629 4.37964 12.9892 4.02469 13.0155 3.6566C13.0549 3.30166 13.1075 2.94671 13.1995 2.59177C13.3178 2.17109 13.7517 1.90817 14.1855 2.02648C14.4747 2.09221 14.685 2.3157 14.7508 2.59177Z"
        fill={color}
      />
      <path
        d="M14.0024 7.61404C13.6474 7.70606 13.2925 7.75865 12.9375 7.79809C12.5826 7.83753 12.2276 7.85067 11.8595 7.85067C11.5046 7.85067 11.1497 7.85067 10.7816 7.81123C10.4266 7.7718 10.0717 7.71921 9.70358 7.62719C9.26976 7.50887 9.03313 7.06191 9.15145 6.62808C9.23032 6.35202 9.44066 6.15482 9.70358 6.07595C10.0585 5.97078 10.4135 5.91819 10.7684 5.87876C11.1234 5.83932 11.4783 5.82617 11.8464 5.82617C12.2013 5.82617 12.5563 5.83932 12.9244 5.87876C13.2793 5.91819 13.6343 5.95763 14.0024 6.0628C14.4362 6.16797 14.686 6.61494 14.5808 7.03561C14.4888 7.32483 14.2653 7.53517 14.0024 7.61404Z"
        fill={color}
      />
      <path
        d="M2 6.1154C3.06483 4.11719 5.18136 2.75 7.61339 2.75C9.9271 2.75 11.9647 3.98573 13.069 5.83933"
        stroke={color}
        strokeWidth="1.7"
        strokeMiterlimit="10"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
      <path
        d="M1.23663 14.5815C1.14461 14.2265 1.09202 13.8716 1.05258 13.5035C1.01315 13.1486 1 12.7936 1 12.4255C1 12.0706 1.01315 11.7156 1.05258 11.3475C1.09202 10.9926 1.14461 10.6377 1.24978 10.2827C1.38124 9.86203 1.8282 9.61226 2.24888 9.73057C2.52495 9.80945 2.72214 10.0329 2.80102 10.2827C2.90619 10.6377 2.95877 10.9926 2.98506 11.3607C3.0245 11.7156 3.0245 12.0706 3.0245 12.4387C3.0245 12.7936 2.99821 13.1486 2.97192 13.5166C2.93248 13.8716 2.87989 14.2265 2.78787 14.5815C2.66956 15.0022 2.23573 15.2651 1.80191 15.1468C1.52584 15.0679 1.31551 14.8444 1.23663 14.5815Z"
        fill={color}
      />
      <path
        d="M1.99835 9.5462C2.35329 9.45418 2.70824 9.40159 3.06318 9.36215C3.41812 9.32272 3.77307 9.30957 4.14116 9.30957C4.49611 9.30957 4.85105 9.30957 5.21914 9.34901C5.57409 9.38845 5.92903 9.44103 6.29712 9.53305C6.73094 9.65137 6.96757 10.0983 6.84926 10.5322C6.77038 10.8082 6.56004 11.0054 6.29712 11.0843C5.94218 11.1895 5.58723 11.242 5.23229 11.2815C4.8642 11.3209 4.50925 11.3341 4.14116 11.3341C3.78622 11.3341 3.43127 11.3209 3.06318 11.2815C2.70824 11.242 2.35329 11.2026 1.9852 11.0974C1.55138 10.9923 1.3016 10.5453 1.40677 10.1246C1.49879 9.83541 1.72228 9.62508 1.99835 9.5462Z"
        fill={color}
      />
      <path
        d="M13.9889 11.0449C12.9241 13.0431 10.8076 14.4103 8.37556 14.4103C6.06184 14.4103 4.02419 13.1746 2.91992 11.321"
        stroke={color}
        strokeWidth="1.7"
        strokeMiterlimit="10"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconSave.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconSave } from './IconSave';

describe('IconSave Component', () => {
  it('renders with default props', () => {
    render(<IconSave data-testid="save-icon" />);
    const svg = screen.getByTestId('save-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    render(<IconSave size={32} data-testid="save-icon" />);
    const svg = screen.getByTestId('save-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconSave color="red" data-testid="save-icon" />);
    const path = screen.getByTestId('save-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    render(<IconSave data-testid="save-icon" className="custom-class" aria-label="Save" />);
    const svg = screen.getByTestId('save-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Save');
  });
});
</file>

<file path="src/ui-kit/icons/IconSave.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconSave: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="M5 7.8c0-1.68 0-2.52.327-3.162a3 3 0 0 1 1.311-1.311C7.28 3 8.12 3 9.8 3h4.4c1.68 0 2.52 0 3.162.327a3 3 0 0 1 1.311 1.311C19 5.28 19 6.12 19 7.8V21l-7-4-7 4V7.8Z"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconSearch.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconSearch } from './IconSearch';

describe('IconSearch Component', () => {
  it('renders with default props', () => {
    render(<IconSearch data-testid="search-icon" />);
    const svg = screen.getByTestId('search-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 20 18');
  });

  it('renders with custom size', () => {
    render(<IconSearch size={32} data-testid="search-icon" />);
    const svg = screen.getByTestId('search-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconSearch color="red" data-testid="search-icon" />);
    const path = screen.getByTestId('search-icon').querySelector('path');

    expect(path).toHaveAttribute('fill', 'red');
  });

  it('passes through additional native props', () => {
    render(<IconSearch data-testid="search-icon" className="custom-class" aria-label="Search" />);
    const svg = screen.getByTestId('search-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Search');
  });
});
</file>

<file path="src/ui-kit/icons/IconSearch.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconSearch: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 20 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M8.89828 2.48433C8.34623 2.26913 7.75715 2.16496 7.16477 2.17778C6.5724 2.19061 5.98838 2.32018 5.44616 2.55907C4.90394 2.79796 4.41417 3.14148 4.00493 3.56995L4.00443 3.57047L3.30923 4.29727L3.3089 4.29762C2.48038 5.1659 2.02972 6.32713 2.05563 7.52701C2.08153 8.72667 2.58172 9.86718 3.44666 10.6988L3.44747 10.6996L4.17336 11.394L3.50715 12.0904L4.17337 11.394C4.60225 11.8042 5.1078 12.1259 5.66111 12.3405C6.21442 12.5552 6.80462 12.6587 7.39796 12.6451C7.9913 12.6314 8.57613 12.501 9.11899 12.2611C9.66098 12.0216 10.1505 11.6778 10.5597 11.2493L11.2414 10.5257L7.16477 2.17778L11.2429 10.524L11.2463 10.5204L11.249 10.5175L11.2491 10.5175L11.2536 10.5128C11.6622 10.0855 11.983 9.58209 12.1976 9.03113C12.413 8.47813 12.5173 7.88808 12.5044 7.29475C12.4916 6.70142 12.3619 6.11644 12.1228 5.57327C11.8837 5.03009 11.5399 4.53939 11.111 4.12923L11.1109 4.12914L10.3833 3.43317L10.3819 3.43188C9.9545 3.02153 9.45033 2.69953 8.89828 2.48433ZM14.0612 9.75705C13.8864 10.2058 13.6628 10.6327 13.3951 11.0304L14.8095 12.0954C15.1073 11.8904 15.4287 11.775 15.7353 11.8003C16.5799 11.9873 17.3758 12.3496 18.0715 12.8636C18.7672 13.3777 19.3472 14.0321 19.774 14.7845C19.9816 15.1371 20.0493 15.5548 19.9638 15.955C19.898 16.2926 19.7614 16.6124 19.5631 16.8935C17.7163 19.5693 14.6581 16.0007 14.1919 15.4566L14.1852 15.4488C13.9743 15.2567 13.8132 15.0162 13.7159 14.748C13.6185 14.4798 13.5878 14.192 13.6263 13.9093C13.6366 13.8519 13.6494 13.7944 13.6645 13.7368L12.0847 12.5472L12.0133 12.623L12.0091 12.6275C11.418 13.2472 10.7106 13.7444 9.92729 14.0905C9.14395 14.4366 8.30006 14.6249 7.44389 14.6445C6.58772 14.6642 5.73608 14.5149 4.93767 14.2051C4.13927 13.8953 3.40978 13.4312 2.79092 12.8392L2.79091 12.8392L2.06332 12.1433L2.06161 12.1416C0.814597 10.9432 0.0934314 9.29933 0.0560949 7.57018C0.0187584 5.84104 0.668296 4.16759 1.86242 2.91642L1.86318 2.91563L2.55864 2.18855L2.55888 2.1883C3.14979 1.5697 3.85693 1.07375 4.63979 0.728831C5.42276 0.383871 6.26609 0.196772 7.12148 0.178252C7.97687 0.159732 8.82751 0.310155 9.62468 0.620904C10.4216 0.931547 11.1494 1.3963 11.7664 1.98857L11.767 1.98918L12.4932 2.68376L12.4933 2.68385C13.1122 3.27569 13.6083 3.98373 13.9533 4.76747C14.2983 5.55125 14.4855 6.39536 14.504 7.25152C14.5225 8.10768 14.372 8.95909 14.0612 9.75705Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconSend.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconSend } from './IconSend';

describe('IconSend Component', () => {
  it('renders with default props', () => {
    render(<IconSend data-testid="send-icon" />);
    const svg = screen.getByTestId('send-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    render(<IconSend size={32} data-testid="send-icon" />);
    const svg = screen.getByTestId('send-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color', () => {
    render(<IconSend color="red" data-testid="send-icon" />);
    const path = screen.getByTestId('send-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    render(<IconSend data-testid="send-icon" className="custom-class" aria-label="Send" />);
    const svg = screen.getByTestId('send-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Send');
  });
});
</file>

<file path="src/ui-kit/icons/IconSend.tsx">
import { IconProps } from './types';
import React from 'react';

export const IconSend: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="m5 12-.604-5.437C4.223 5.007 5.825 3.864 7.24 4.535l11.944 5.658c1.525.722 1.525 2.892 0 3.614L7.24 19.465c-1.415.67-3.017-.472-2.844-2.028L5 12Zm0 0h7"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconSettings.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconSettings } from './IconSettings';

describe('IconSettings Component', () => {
  it('renders with default props', () => {
    render(<IconSettings data-testid="settings-icon" />);
    const svg = screen.getByTestId('settings-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 24 24');
  });

  it('renders with custom size', () => {
    render(<IconSettings size={32} data-testid="settings-icon" />);
    const svg = screen.getByTestId('settings-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color for both fill and stroke paths', () => {
    render(<IconSettings color="red" data-testid="settings-icon" />);
    const paths = screen.getByTestId('settings-icon').querySelectorAll('path');
    // First path uses fill
    expect(paths[0]).toHaveAttribute('fill', 'red');
    // Second path uses stroke
    expect(paths[1]).toHaveAttribute('stroke', 'red');
  });

  it('passes through additional native props', () => {
    render(
      <IconSettings data-testid="settings-icon" className="custom-class" aria-label="Settings" />
    );
    const svg = screen.getByTestId('settings-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'Settings');
  });
});
</file>

<file path="src/ui-kit/icons/IconSettings.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconSettings: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        fill={color}
        d="M11.585 21.995a4.869 4.869 0 0 1-1.927-.3 2.646 2.646 0 0 1-1.39-1.869 2.491 2.491 0 0 1-.804.19 3.526 3.526 0 0 1-2.78-1.239 4.755 4.755 0 0 1-1.152-1.579 2.584 2.584 0 0 1 .16-1.998h-.11c-1.39-.55-1.569-1.999-1.569-3.238a3.578 3.578 0 0 1 1.122-2.918c.252-.215.541-.381.854-.49a2.264 2.264 0 0 1-.14-.26c-.615-1.418.279-2.587 1.143-3.446 1.201-1.21 2.264-1.59 3.376-1.13.575-1.469 1.906-1.708 3.217-1.708a3.504 3.504 0 0 1 2.82 1.099c.175.2.319.426.426.67.45-.3.98-.453 1.52-.44.926.12 1.773.587 2.373 1.309 1.35 1.369 1.658 2.568.913 3.857C21.255 8.825 22 9.934 22 11.932c0 1.829-.606 2.908-1.936 3.328.715 1.269.397 2.458-.924 3.797-1.32 1.339-2.74 1.689-4.13.72-.397 1.518-1.48 2.218-3.425 2.218Zm-2.493-5.067c.14.002.278.029.407.08a.995.995 0 0 1 .586 1c-.07.799.13 1.758.378 1.868.36.104.736.147 1.112.13 1.33 0 1.539-.2 1.539-1.549a3.434 3.434 0 0 0-.1-.91 1.005 1.005 0 0 1 .603-1.198.986.986 0 0 1 1.244.49c.177.298.398.567.655.799.944.95 1.222.95 2.175 0 .953-.95.933-1.21 0-2.169a2.653 2.653 0 0 0-.258-.23 1.001 1.001 0 0 1-.278-1.139.998.998 0 0 1 .993-.639h.347c1.33 0 1.53-.21 1.53-1.549s-.19-1.529-1.53-1.529c-.286 0-.572.023-.854.07a.988.988 0 0 1-1.151-.52 1.005 1.005 0 0 1 .327-1.218c.186-.13.359-.277.516-.44.993-1 .934-1.22 0-2.168-.466-.48-.824-.72-.992-.73-.17-.01-.447.08-1.093.73-.129.12-.228.24-.327.35a.992.992 0 0 1-1.593-.115 1.004 1.004 0 0 1-.155-.605.778.778 0 0 1 0-.14 1.52 1.52 0 0 0-.218-1.17 1.785 1.785 0 0 0-1.32-.409c-1.38-.01-1.55.14-1.55 1.41a1.004 1.004 0 0 1-.61.917.987.987 0 0 1-1.078-.208c-.774-.75-.993-.89-1.985.12-.993 1.009-.795 1.139-.745 1.249.3.418.631.813.993 1.179a1.001 1.001 0 0 1 .228 1.129.997.997 0 0 1-.993.6h-.178a1.55 1.55 0 0 0-1.34.18c-.296.379-.432.86-.378 1.338 0 1.26.238 1.35.357 1.4.348.117.716.164 1.083.139a.989.989 0 0 1 .913.64 1.005 1.005 0 0 1-.238 1.089c-.437.44-.785 1.109-.715 1.289.187.326.421.622.695.88.31.37.752.606 1.231.659a1.455 1.455 0 0 0 .993-.68l.1-.12a.99.99 0 0 1 .674-.3Z"
      />
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        d="M10.46 14.32c-.72-.28-1-1-1-2.33 0-2 .72-2.53 2.53-2.53 1.81 0 2.55.48 2.55 2.53s-.72 2.55-2.55 2.55a3.811 3.811 0 0 1-1.53-.22v0Z"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/IconUser.test.tsx">
import React from 'react';
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { IconUser } from './IconUser';

describe('IconUser Component', () => {
  it('renders with default props', () => {
    render(<IconUser data-testid="user-icon" />);
    const svg = screen.getByTestId('user-icon');

    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('width', '24');
    expect(svg).toHaveAttribute('height', '24');
    expect(svg).toHaveAttribute('viewBox', '0 0 20 20');
  });

  it('renders with custom size', () => {
    render(<IconUser size={32} data-testid="user-icon" />);
    const svg = screen.getByTestId('user-icon');

    expect(svg).toHaveAttribute('width', '32');
    expect(svg).toHaveAttribute('height', '32');
  });

  it('renders with custom color and correct stroke attributes', () => {
    render(<IconUser color="red" data-testid="user-icon" />);
    const path = screen.getByTestId('user-icon').querySelector('path');

    expect(path).toHaveAttribute('stroke', 'red');
    expect(path).toHaveAttribute('stroke-width', '1.66667');
    expect(path).toHaveAttribute('stroke-linecap', 'round');
    expect(path).toHaveAttribute('stroke-linejoin', 'round');
  });

  it('passes through additional native props', () => {
    render(<IconUser data-testid="user-icon" className="custom-class" aria-label="User" />);
    const svg = screen.getByTestId('user-icon');

    expect(svg).toHaveClass('custom-class');
    expect(svg).toHaveAttribute('aria-label', 'User');
  });
});
</file>

<file path="src/ui-kit/icons/IconUser.tsx">
import React from 'react';
import { IconProps } from './types';

export const IconUser: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  ...nativeProps
}) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...nativeProps}
    >
      <path
        stroke={color}
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="1.66667"
        d="M16.6667 17.5C16.6667 16.337 16.6667 15.7555 16.5232 15.2824C16.2 14.217 15.3663 13.3834 14.301 13.0602C13.8278 12.9167 13.2463 12.9167 12.0834 12.9167H7.91671C6.75374 12.9167 6.17225 12.9167 5.69909 13.0602C4.63375 13.3834 3.80007 14.217 3.47691 15.2824C3.33337 15.7555 3.33337 16.337 3.33337 17.5M13.75 6.25C13.75 8.32107 12.0711 10 10 10C7.92897 10 6.25004 8.32107 6.25004 6.25C6.25004 4.17893 7.92897 2.5 10 2.5C12.0711 2.5 13.75 4.17893 13.75 6.25Z"
      />
    </svg>
  );
};
</file>

<file path="src/ui-kit/icons/types.ts">
import type { SVGProps } from 'react';

export type IconProps = SVGProps<SVGSVGElement> & {
  color?: string;
  size?: number | string;
};
</file>

<file path="src/ui-kit/utils/cn.ts">
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/ui-kit/Button.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  it('renders with primary variant by default', () => {
    render(<Button>Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toHaveClass('btn-primary');
  });

  it('renders with secondary variant when specified', () => {
    render(<Button variant="secondary">Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toHaveClass('btn-secondary');
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('merges additional className with base classes', () => {
    render(<Button className="custom-class">Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toHaveClass('btn-primary', 'custom-class');
  });
});
</file>

<file path="src/ui-kit/Button.tsx">
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
  children: React.ReactNode;
  icon?: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  children,
  icon,
  className = '',
  ...props
}) => {
  const baseClass = variant === 'primary' ? 'btn-primary' : 'btn-secondary';

  return (
    <button className={`${baseClass} ${icon ? 'gap-2' : ''} ${className}`} {...props}>
      {icon && <span className="inline-flex items-center">{icon}</span>}
      {children}
    </button>
  );
};
</file>

<file path="src/ui-kit/Dropdown.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Dropdown } from './Dropdown';
import React from 'react';

describe('Dropdown Component', () => {
  const mockItems = [
    { code: '1', label: 'Option 1', onClick: vi.fn() },
    { code: '2', label: 'Option 2', onClick: vi.fn() },
  ];

  it('renders with default state', () => {
    render(<Dropdown items={mockItems} />);
    expect(screen.getByText('Select an option')).toBeInTheDocument();
  });

  it('opens dropdown when clicked', () => {
    render(<Dropdown items={mockItems} />);
    const button = screen.getByRole('button');
    fireEvent.click(button);
    // After clicking, dropdown items should be visible
    const dropdownItems = screen.getAllByText(/Option [12]/);
    expect(dropdownItems).toHaveLength(2);
  });

  it('selects an item when clicked', () => {
    render(<Dropdown items={mockItems} />);
    const button = screen.getByRole('button');
    fireEvent.click(button);
    // Click the first option
    const options = screen.getAllByText(/Option \d/);
    fireEvent.click(options[0]);
    // Check if callback was called
    expect(mockItems[0].onClick).toHaveBeenCalledTimes(1);
    // Check if selected item is displayed in button
    const buttonText = screen.getByRole('button').textContent;
    expect(buttonText).toContain('Option 1');
    expect(buttonText).toContain('(1)');
  });

  it('closes when clicking outside', () => {
    render(
      <div>
        <div data-testid="outside">Outside</div>
        <Dropdown items={mockItems} />
      </div>
    );

    const button = screen.getByRole('button');
    fireEvent.click(button);
    expect(screen.getByText('(1)')).toBeInTheDocument();

    fireEvent.mouseDown(screen.getByTestId('outside'));
    expect(screen.queryByText('(1)')).not.toBeInTheDocument();
  });

  it('applies custom className', () => {
    render(<Dropdown items={mockItems} className="custom-class" />);
    const container = screen.getByRole('button').parentElement;
    expect(container).toHaveClass('custom-class');
  });

  // it('shows check icon for selected item', async () => {
  //   render(<Dropdown items={mockItems} />);
  //   // Open dropdown and select first item
  //   const button = screen.getByRole('button');
  //   fireEvent.click(button);
  //   const options = screen.getAllByText(/Option \d/);
  //   fireEvent.click(options[0]);
  //   // Open dropdown again to see check icon
  //   fireEvent.click(button);
  //   // The check icon should be next to the selected item
  //   const selectedItem = screen.getByText('Option 1').closest('.flex.items-center.justify-between');
  //   const checkIcon = selectedItem?.querySelector('[data-testid="check-icon"]');
  //   expect(checkIcon).toBeInTheDocument();
  // });
});
</file>

<file path="src/ui-kit/Dropdown.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { IconCheck } from './icons/IconCheck';

interface DropdownItem {
  code: string;
  label: string;
  onClick: () => void;
}

interface DropdownProps {
  selectedItem?: DropdownItem;
  items: DropdownItem[];
  className?: string;
}

export const Dropdown: React.FC<DropdownProps> = ({ items, className = '' }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState<DropdownItem | null>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const renderItem = (item: DropdownItem) => (
    <div className="flex items-center text-base">
      <span className="text-gray-400 font-normal">({item.code})</span>
      <span className="ml-2 font-normal">{item.label}</span>
    </div>
  );

  const handleSelect = (item: DropdownItem) => {
    setSelected(item);
    item.onClick();
  };

  return (
    <div className={`relative ${className}`} ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full px-6 py-4 text-left bg-white border border-gray-200 rounded-2xl hover:border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-100 focus:border-blue-300 transition-all duration-200"
      >
        {selected ? renderItem(selected) : 'Select an option'}
      </button>

      {isOpen && (
        <div className="absolute z-10 w-full mt-2 bg-white border border-gray-200 rounded-2xl shadow-lg overflow-hidden">
          {items.map((item, index) => (
            <div
              key={index}
              className="flex items-center justify-between px-6 py-4 cursor-pointer hover:bg-gray-50 transition-colors duration-150"
              onClick={() => handleSelect(item)}
            >
              {renderItem(item)}
              {selected?.code === item.code && (
                <IconCheck data-testid="check-icon" className="w-5 h-5 text-blue-600 ml-4" />
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/ui-kit/Radio.test.tsx">
import { describe, it, expect, vi, afterEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Radio } from './Radio';
import React from 'react';
import gsap from 'gsap';

vi.mock('gsap');

describe('Radio Component', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it('renders correctly', () => {
    render(<Radio isChecked={false} handleClick={() => {}} id="test-radio" />);
    expect(screen.getByTestId('radio-input')).toBeInTheDocument();
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Radio isChecked={false} handleClick={handleClick} id="test-radio" />);
    fireEvent.click(screen.getByTestId('radio-input'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('reflects checked state', () => {
    render(<Radio isChecked={true} handleClick={() => {}} id="test-radio" />);
    expect(screen.getByTestId('radio-input')).toBeChecked();
    const label = screen.getByLabelText('');
    expect(label.parentElement?.querySelector('label')).toHaveClass('border-blue-600');
  });

  it('can be disabled', () => {
    render(<Radio isChecked={false} handleClick={() => {}} disabled id="test-radio" />);
    const input = screen.getByTestId('radio-input');
    expect(input).toBeDisabled();
    const label = screen.getByLabelText('');
    expect(label.parentElement?.querySelector('label')).toHaveClass('pointer-events-none');
  });

  it('applies custom className', () => {
    render(
      <Radio isChecked={false} handleClick={() => {}} className="custom-class" id="test-radio" />
    );
    const container = screen.getByTestId('radio-input').parentElement;
    expect(container).toHaveClass('custom-class');
  });

  it('applies correct border color when unchecked', () => {
    render(<Radio isChecked={false} handleClick={() => {}} id="test-radio" />);
    const label = screen.getByLabelText('');
    expect(label.parentElement?.querySelector('label')).toHaveClass('border-gray-200');
  });

  it('triggers animation when checked state changes', async () => {
    const { rerender } = render(<Radio isChecked={false} handleClick={() => {}} id="test-radio" />);
    // Clear initial animation call
    vi.clearAllMocks();

    // Change to checked state
    rerender(<Radio isChecked={true} handleClick={() => {}} id="test-radio" />);
    expect(gsap.to).toHaveBeenCalledWith(expect.any(HTMLDivElement), {
      scale: 1,
      ease: 'elastic.out(1.2,1)',
    });

    // Change back to unchecked state
    rerender(<Radio isChecked={false} handleClick={() => {}} id="test-radio" />);
    expect(gsap.to).toHaveBeenCalledWith(expect.any(HTMLDivElement), {
      scale: 0,
      ease: 'power2.inOut',
    });
  });
});
</file>

<file path="src/ui-kit/Radio.tsx">
import { cn } from './utils/cn';
import { InputHTMLAttributes, useEffect, useRef } from 'react';
import gsap from 'gsap';

interface RadioProps extends InputHTMLAttributes<HTMLInputElement> {
  isChecked: boolean;
  handleClick: () => void;
}

export const Radio = ({ isChecked, handleClick, className, ...nativeProps }: RadioProps) => {
  const circleRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Only run animations in browser environment
    if (typeof window !== 'undefined' && circleRef.current) {
      if (isChecked) {
        gsap.to(circleRef.current, {
          scale: 1,
          ease: 'elastic.out(1.2,1)',
        });
      } else {
        gsap.to(circleRef.current, {
          scale: 0,
          ease: 'power2.inOut',
        });
      }
    }
  }, [isChecked]);

  return (
    <div className={cn('inline-block', className)}>
      <input
        type="radio"
        hidden
        data-testid="radio-input"
        checked={isChecked}
        onClick={handleClick}
        onChange={() => null}
        disabled={nativeProps.disabled}
        {...nativeProps}
      />
      <label
        htmlFor={nativeProps.id}
        className={cn(
          'border-2 bg-white rounded-full w-6 h-6 flex items-center justify-center cursor-pointer',
          'transition-colors duration-200',
          isChecked ? 'border-blue-600' : 'border-gray-200',
          nativeProps.disabled && 'border-gray-100 pointer-events-none'
        )}
      >
        <div
          ref={circleRef}
          className={cn('w-3 h-3 rounded-full bg-blue-600')}
          style={{ transform: 'scale(0)' }}
        />
      </label>
    </div>
  );
};

Radio.displayName = 'Radio';
</file>

<file path="src/ui-kit/TextArea.test.tsx">
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { TextArea } from './TextArea';
import React from 'react';

describe('TextArea Component', () => {
  it('renders correctly', () => {
    render(<TextArea placeholder="Enter text" />);
    expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument();
  });

  it('applies error styles when error prop is true', () => {
    render(<TextArea error data-testid="textarea" />);
    const textarea = screen.getByTestId('textarea');
    expect(textarea).toHaveClass('border-red-500');
  });

  it('applies custom className', () => {
    render(<TextArea className="custom-class" data-testid="textarea" />);
    const textarea = screen.getByTestId('textarea');
    expect(textarea).toHaveClass('custom-class');
  });

  it('forwards ref correctly', () => {
    const ref = React.createRef<HTMLTextAreaElement>();
    render(<TextArea ref={ref} data-testid="textarea" />);
    expect(ref.current).toBe(screen.getByTestId('textarea'));
  });

  it('passes through native textarea props', () => {
    render(
      <TextArea
        data-testid="textarea"
        disabled
        maxLength={100}
        placeholder="Test"
        value="Hello"
        readOnly
        rows={4}
      />
    );
    const textarea = screen.getByTestId('textarea');
    expect(textarea).toBeDisabled();
    expect(textarea).toHaveAttribute('maxLength', '100');
    expect(textarea).toHaveAttribute('placeholder', 'Test');
    expect(textarea).toHaveValue('Hello');
    expect(textarea).toHaveAttribute('readonly');
    expect(textarea).toHaveAttribute('rows', '4');
  });
});
</file>

<file path="src/ui-kit/TextArea.tsx">
import { cn } from './utils/cn';
import { TextareaHTMLAttributes, forwardRef } from 'react';

interface TextAreaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {
  error?: boolean;
}

export const TextArea = forwardRef<HTMLTextAreaElement, TextAreaProps>(
  ({ error, className, ...nativeProps }, ref) => {
    return (
      <textarea
        className={cn(
          'w-full h-full px-6 py-4 text-base bg-white border border-gray-200',
          'rounded-2xl',
          'hover:border-gray-300',
          'focus:outline-none focus:ring-2 focus:ring-blue-100 focus:border-blue-300',
          'transition-all duration-200',
          'resize-none overflow-y-auto',
          error && 'border-red-500 focus:border-red-500 focus:ring-red-100',
          className
        )}
        ref={ref}
        {...nativeProps}
      />
    );
  }
);

TextArea.displayName = 'TextArea';
</file>

<file path="src/ui-kit/TextInput.test.tsx">
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { TextInput } from './TextInput';
import React from 'react';

describe('TextInput Component', () => {
  it('renders correctly', () => {
    render(<TextInput placeholder="Enter text" />);
    expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument();
  });

  it('applies error styles when error prop is true', () => {
    render(<TextInput error data-testid="input" />);
    const input = screen.getByTestId('input');
    expect(input).toHaveClass('border-red-500');
  });

  it('applies custom className', () => {
    render(<TextInput className="custom-class" data-testid="input" />);
    const input = screen.getByTestId('input');
    expect(input).toHaveClass('custom-class');
  });

  it('forwards ref correctly', () => {
    const ref = React.createRef<HTMLInputElement>();
    render(<TextInput ref={ref} data-testid="input" />);
    expect(ref.current).toBe(screen.getByTestId('input'));
  });

  it('passes through native input props', () => {
    render(
      <TextInput
        data-testid="input"
        disabled
        maxLength={10}
        placeholder="Test"
        value="Hello"
        readOnly
      />
    );
    const input = screen.getByTestId('input');
    expect(input).toBeDisabled();
    expect(input).toHaveAttribute('maxLength', '10');
    expect(input).toHaveAttribute('placeholder', 'Test');
    expect(input).toHaveValue('Hello');
    expect(input).toHaveAttribute('readonly');
  });
});
</file>

<file path="src/ui-kit/TextInput.tsx">
import { cn } from './utils/cn';
import { InputHTMLAttributes, forwardRef } from 'react';

interface TextInputProps extends InputHTMLAttributes<HTMLInputElement> {
  error?: boolean;
}

export const TextInput = forwardRef<HTMLInputElement, TextInputProps>(
  ({ error, className, ...nativeProps }, ref) => {
    return (
      <input
        className={cn(
          'w-full px-6 py-4 text-base bg-white border border-gray-200',
          'rounded-2xl',
          'hover:border-gray-300',
          'focus:outline-none focus:ring-2 focus:ring-blue-100 focus:border-blue-300',
          'transition-all duration-200',
          error && 'border-red-500 focus:border-red-500 focus:ring-red-100',
          className
        )}
        type="text"
        ref={ref}
        {...nativeProps}
      />
    );
  }
);

TextInput.displayName = 'TextInput';
</file>

<file path=".clinerules">
# Project Guidelines

## Configuration File Protection

### File Modification Restrictions

- **Scope:** `package.json`, `tsconfig.json`, `vitest.config.json`, `next.config.js`, `postcss.config.js`, `.env`
- **Rule:** DO NOT write to or modify these configuration files without explicit user approval.
- **Action:** Before attempting to modify any of these files, use `<ask_followup_question>` to confirm with the user if the modification is allowed.

## Git Branching for New Tasks

### Branch Creation Workflow

- **Trigger:** When a new task is initiated.
- **Action:** Use `<ask_followup_question>` to ask the user: "Should I create a new Git branch for this task?"
  - If user approves: Proceed to create a new branch using `<execute_command>` with `git checkout -b <branch_name>`. You should suggest a branch name based on the task.
  - If user denies: Continue in the current branch.

## Automated Git Commits for Major Features

### Commit Workflow

- **Trigger:** After completing a major feature or a significant set of changes.
- **Action:** Use `<ask_followup_question>` to ask the user: "Should I commit the current changes?"
  - If user approves:
    1.  Use `<execute_command>` with `git add .` to stage all changed files.
    2.  Use `<execute_command>` to generate a concise and informative commit message (e.g., using `git diff --cached | ai-commit-message-generator`). If you cannot generate a commit message, ask the user to provide one.
    3.  Use `<execute_command>` with `git commit -m "<generated_commit_message>"` to commit the changes.
    - After each step, confirm success with the user.
  - If user denies: Do not commit changes and proceed without committing.

## Active Development Feedback (Linting and Testing)

### Real-time Feedback during Development

- **Linting (Watch Mode):**
  - **Action:** When starting active code development in Code mode, use `<execute_command>` to open a new terminal and run `npm run lint:watch` (or the appropriate linting command for the project).
  - **Focus:** Ensure the terminal running `lint:watch` is focused so the user can immediately see linting errors.
- **Testing (Watch Mode):**
  - **Action:** In a separate terminal, use `<execute_command>` to open another new terminal and run `npm run test:watch` (or the appropriate test command for the project).
  - **Focus:** Keep focus on the linting errors terminal, but ensure the user is aware of the running tests in the background.
- **Error Detection and User Interaction:**
  - **Condition:** If new linting or test errors are introduced as a result of code changes.
  - **Action:** Use `<ask_followup_question>` to ask the user: "New linting/testing errors have been introduced. Should I attempt to fix them?"
    - If user approves: Proceed to attempt to fix the errors in Code mode.
    - If user denies: Continue without fixing the errors but inform the user about the errors and potential consequences.

**Important Considerations:**

- **User Approval:** For all actions involving file modifications, Git operations, or potentially disruptive actions, always use `<ask_followup_question>` to get explicit user approval before proceeding.
- **Error Handling:** Implement robust error handling for all tool executions, especially for terminal commands and Git operations. Inform the user clearly if any command fails.
- **Clarity in Communication:** When asking follow-up questions, clearly state the reason for the question and the implications of different responses.
- **Adapt Commands:** Ensure that the commands used (e.g., `npm run lint:watch`, `git add .`, `git commit`) are appropriate for the user's project and operating system. You may need to adjust these commands based on the project's `package.json` or other configuration files.

This `.clinerules` file provides a comprehensive set of guidelines for Roo Code to follow, balancing automation with user control and incorporating best practices for code quality, version control, and project management. Remember that this is a starting point and can be further refined based on specific project needs and user feedback.
</file>

<file path=".env-sample">
OPENAI_API_KEY=your-api-key-here
MONGO_URI=your-mongodb-connection-string
SESSION_SECRET=your-secure-session-secret
</file>

<file path=".eslintignore">
node_modules
.next
build
dist
coverage
public
*.config.js
next-env.d.ts
</file>

<file path=".eslintrc.json">
{
  "root": true,
  "extends": ["next/core-web-vitals", "plugin:@typescript-eslint/recommended", "prettier"],
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "caughtErrorsIgnorePattern": "^_"
      }
    ],
    "@typescript-eslint/no-explicit-any": "error",
    "prettier/prettier": "error"
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local
.env
</file>

<file path=".nvmrc">
18
</file>

<file path=".prettierignore">
node_modules
.next
build
dist
coverage
pnpm-lock.yaml
public
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "tabWidth": 2,
  "useTabs": false,
  "printWidth": 100,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // Configure TypeScript compiler options
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: false,
  },
  pageExtensions: ['ts', 'tsx', 'js', 'jsx'],
};

module.exports = nextConfig;
</file>

<file path="package.json">
{
  "private": true,
  "scripts": {
    "build": "next build",
    "dev": "next dev",
    "start": "next start",
    "test": "vitest --run",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint \"src/**/*.{ts,tsx}\"",
    "lint:fix": "eslint \"src/**/*.{ts,tsx}\" --fix",
    "format": "prettier --check .",
    "format:fix": "prettier --write .",
    "prepare": "husky install"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "dependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/express-session": "^1.18.1",
    "@types/mongoose": "^5.11.97",
    "@types/passport": "^1.0.17",
    "@types/passport-local": "^1.0.38",
    "bcryptjs": "^3.0.0",
    "clsx": "^2.1.1",
    "connect-mongo": "^5.1.0",
    "express-session": "^1.18.1",
    "gsap": "^3.12.7",
    "mongoose": "^8.9.5",
    "next": "latest",
    "next-auth": "^4.24.11",
    "next-connect": "^1.0.0",
    "openai": "4.80.1",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pdf-parse": "1.1.1",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-pdftotext": "1.3.4",
    "tailwind-merge": "^2.6.0"
  },
  "engines": {
    "node": ">=18"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.6.0",
    "@types/express": "^5.0.0",
    "@types/node": "^22.10.5",
    "@types/react": "^19.0.2",
    "@types/react-dom": "^19.0.2",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.1.3",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-vitest": "^0.5.4",
    "husky": "^8.0.0",
    "jsdom": "^25.0.1",
    "lint-staged": "^15.3.0",
    "node-mocks-http": "^1.16.2",
    "postcss": "^8.4.49",
    "prettier": "^3.4.2",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.3.3",
    "vitest": "^2.1.8"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="README.md">
This is a starter template for [Learn Next.js](https://nextjs.org/learn).
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx}',
    './src/components/**/*.{js,ts,jsx,tsx}',
    './src/ui-kit/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {
      // Custom button styles
      colors: {
        primary: {
          DEFAULT: '#4EADFF',
          hover: '#3B9EF3',
        },
        secondary: {
          DEFAULT: '#6B7280',
          hover: '#4B5563',
        },
      },
      // Custom spacing for components
      spacing: {
        button: '0.75rem 1.5rem',
        dropdown: '0.5rem 1rem',
      },
      // Custom border radius
      borderRadius: {
        button: '0.375rem',
        dropdown: '0.25rem',
      },
    },
  },
  plugins: [],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": [
    "node_modules",
    "**/*.test.ts",
    "**/*.test.tsx",
    "**/*.spec.ts",
    "**/*.spec.tsx",
    "src/test/**/*",
    "vitest.config.ts"
  ]
}
</file>

<file path="vitest.config.ts">
/// <reference types="vitest" />

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    include: [
      'src/**/*.test.{ts,tsx}',
      'src/**/*.spec.{ts,tsx}',
      'src/pages/api/**/__tests__/**/*.test.{ts,tsx}',
    ],
    exclude: ['.next/**', 'node_modules/**', '**/node_modules/**', 'dist/**'],
    coverage: {
      reporter: ['text', 'json', 'html'],
    },
    server: {
      deps: {
        inline: [/^(?!.*vitest).*$/],
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
});
</file>

</files>
